<!-- _IMGDISP_SOURCE_FILE_APP_XAML -->
<Application x:Class="ImgDisp.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             StartupUri="MainWindow.xaml">
    <Application.Resources>
         
    </Application.Resources>
</Application>
<!-- _IMGDISP_SOURCE_FILE_APP_XAML END -->
// _IMGDISP_SOURCE_FILE_APP_XAMLCS

using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;

namespace ImgDisp
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application
    {
    }
}

// _IMGDISP_SOURCE_FILE_APP_XAMLCS END
<!-- _IMGDISP_SOURCE_FILE_MAINWINDOW_XAML -->
<Window x:Class="ImgDisp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:my="clr-namespace:ImgDisp.Ctrl"
        Title="ImgDisp" Height="960" Width="1218" AllowDrop="True" Drop="m_Drop_1">
    <Grid Name="m_g" AllowDrop="True">
        <Grid.RowDefinitions>
            <RowDefinition Height="25"/>
            <RowDefinition/>
        </Grid.RowDefinitions>
        
        <Menu x:Name="menu" Height="23.333" VerticalAlignment="Top" Grid.Row="0" Grid.Column="0">
            <MenuItem Header="file">
                <MenuItem Header="Open.." InputGestureText="ctrl+o" Click="MenuItem_Click_2" />
                <Separator />
            </MenuItem>
        </Menu>
        <my:ImgDispCtrl x:Name="m_imgDisp" Grid.Row="1" Grid.Column="0">
            
        </my:ImgDispCtrl>
    </Grid>
</Window>
<!-- _IMGDISP_SOURCE_FILE_MAINWINDOW_XAML END -->
// _IMGDISP_SOURCE_FILE_MAINWINDOW_XAMLCS

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

using ImgDisp.Ctrl;

namespace ImgDisp
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();

            this.SizeChanged += m_imgDisp.OnWindowSizeChanged;

            // ImgDisp
            m_imgDisp.TargetPixelFormat = PixelFormats.Bgr32;
            m_imgDisp.LimitLevel        = IMGDISP_LIMITLEVEL.IDLL_32;
            m_imgDisp.ColorBufferBkg    = System.Windows.Media.Color.FromArgb(128, 242, 244, 246);
            m_imgDisp.ColorBufferIllu   = System.Windows.Media.Color.FromArgb(128, 246, 244, 242);
        }

        private void m_Drop_1(object sender, DragEventArgs e)
        {
            string msg = "Drop";
            if (e.Data.GetDataPresent(DataFormats.FileDrop))
            {
                msg = ((System.Array)e.Data.GetData(DataFormats.FileDrop)).GetValue(0).ToString();
                m_imgDisp.OpenImage(msg);
            }

        }

        private void MenuItem_Click_2(object sender, RoutedEventArgs e)
        {
            System.Windows.Forms.OpenFileDialog openfiledialog = new System.Windows.Forms.OpenFileDialog { Filter = "????|*.jpg;*.png;*.jpeg;*.bmp;*.gif|????|*.*" };
            System.Windows.Forms.DialogResult rs = openfiledialog.ShowDialog();

            if (rs == System.Windows.Forms.DialogResult.OK)
            {
                m_imgDisp.OpenImage(openfiledialog.FileName);
            }
        }
    }
}
// _IMGDISP_SOURCE_FILE_MAINWINDOW_XAMLCS END
<!-- _IMGDISP_SOURCE_FILE_IMGDISP_XAML -->
<UserControl x:Class="ImgDisp.Ctrl.ImgDispCtrl"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             mc:Ignorable="d" 
             d:DesignHeight="600" d:DesignWidth="1200">
    <Grid Background="White">
        <Grid.RowDefinitions>
            <RowDefinition Height="50"/>
            <RowDefinition/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>
        <Grid.ColumnDefinitions>
            <ColumnDefinition>
            </ColumnDefinition>
        </Grid.ColumnDefinitions>

        <!-- Row 1: Info -->
        <WrapPanel Grid.Row="0" Orientation="Horizontal">
            <TextBlock Text="Width"></TextBlock>
            <TextBox Width="70" IsReadOnly="True" Text="{Binding ImgWidthBase, Mode=TwoWay, StringFormat={}{0:D}}" Margin="2,0,8,0"/>
            <TextBlock Text="Height"></TextBlock>
            <TextBox Width="70" IsReadOnly="True" Text="{Binding ImgHeightBase, Mode=TwoWay, StringFormat={}{0:D}}" Margin="2,0,8,0"/>
            <TextBlock Text="Act Width"></TextBlock>
            <TextBox Width="80" IsReadOnly="True" Text="{Binding ImgWidth, Mode=TwoWay, StringFormat={}{0:D}}" Margin="2,0,8,0"/>
            <TextBlock Text="Act Height"></TextBlock>
            <TextBox Width="80" IsReadOnly="True" Text="{Binding ImgHeight, Mode=TwoWay, StringFormat={}{0:D}}" Margin="2,0,8,0"/>
            <TextBlock Text="Time"></TextBlock>
            <TextBox Width="60" IsReadOnly="True" Text="{Binding Time, Mode=TwoWay, StringFormat={}{0:F6}}" Margin="2,0,8,0"/>
            <TextBlock Text="X"></TextBlock>
            <TextBox Width="140" IsReadOnly="False" Text="{Binding TranslateX, Mode=TwoWay, StringFormat={}{0:F0}}" Margin="2,0,8,0"/>
            <TextBlock Text="Y"></TextBlock>
            <TextBox Width="60" IsReadOnly="False" Text="{Binding TranslateY, Mode=TwoWay, StringFormat={}{0:F0}}" Margin="2,0,8,0"/>
            <TextBlock Text="BPP"></TextBlock>
            <TextBox Width="40" IsReadOnly="True" Text="{Binding ImgBPP, Mode=TwoWay, StringFormat={}{0:D}}" Margin="2,0,8,0"/>
            <TextBlock Text="Frames"></TextBlock>
            <TextBox Width="60" IsReadOnly="True" Text="{Binding FrameCount, Mode=TwoWay, StringFormat={}{0:D}}" Margin="2,0,8,0"/>
            <TextBlock Text="Scale"></TextBlock>
            <TextBox Width="60" IsReadOnly="False" Text="{Binding Scale, Mode=TwoWay, StringFormat={}{0:F6}}" Margin="2,0,8,0"/>
            <TextBlock Text="FPS(fake)"></TextBlock>
            <TextBox Width="60" IsReadOnly="True" Text="{Binding FPS, Mode=TwoWay, StringFormat={}{0:F3}}" Margin="2,0,8,0"/>
            <!--
            <TextBlock Text="ImgDestX"></TextBlock>
            <TextBox Width="60" IsReadOnly="True" Text="{Binding ImgDestX, Mode=TwoWay, StringFormat={}{0:F0}}" Margin="2,0,8,0"/>
            <TextBlock Text="ImgDestY"></TextBlock>
            <TextBox Width="60" IsReadOnly="True" Text="{Binding ImgDestY, Mode=TwoWay, StringFormat={}{0:F0}}" Margin="2,0,8,0"/>
            -->
            <TextBlock Text="CursorX"></TextBlock>
            <TextBox Width="60" IsReadOnly="False" Text="{Binding CursorX, Mode=TwoWay, StringFormat={}{0:F0}}" Margin="2,0,8,0"/>
            <TextBlock Text="CursorY"></TextBlock>
            <TextBox Width="60" IsReadOnly="False" Text="{Binding CursorY, Mode=TwoWay, StringFormat={}{0:F0}}" Margin="2,0,8,0"/>
            <CheckBox Width="Auto" IsChecked="{Binding BRenderIllustration}" Margin="8,2,0,0">
                BlockIllustration
            </CheckBox>
            <CheckBox Width="Auto" IsChecked="{Binding BRenderIllustrationClipRegion}" Margin="8,2,0,0">
                ROIIllustration
            </CheckBox>
            <Button Margin="6,0,0,0" Click="Button_Close_Click">
                <TextBlock FontSize="12" HorizontalAlignment="Center" TextAlignment="Center">
                    Close
                </TextBlock>
            </Button>
            <DockPanel Margin="12,0,0,0">
                <TextBlock Margin="0,0,2,0">
                    BlockSize:
                </TextBlock>
                <Slider Width="100" Value="{Binding BlockSize}" IsEnabled="{Binding ImgSpecChangeEnabled}" Minimum="8" Maximum="4096"></Slider>
                <TextBox Width="60" IsReadOnly="False" Text="{Binding BlockSize}" IsEnabled="False"></TextBox>
            </DockPanel>
        </WrapPanel>
        
        <!-- Row 2: Image Buffer -->
        <Border Name="bdBuffer" Grid.Row="1" BorderBrush="Lavender" BorderThickness="1,1,1,1" HorizontalAlignment="Center"
                MouseLeftButtonDown="bdBuffer_MouseLeftButtonDown_1" MouseLeftButtonUp="bdBuffer_MouseLeftButtonUp"
                MouseRightButtonDown="bdBuffer_MouseRightButtonDown" MouseRightButtonUp="bdBuffer_MouseRightButtonUp"
                MouseMove="bdBuffer_MouseMove" LostFocus="bdBuffer_LostFocus" MouseWheel="bdBuffer_MouseWheel" Focusable="True">
            <Canvas Name="cvsBuffer" Width="2560" Height="1440" Margin="0,0,0,0" ClipToBounds="True">
            </Canvas>
        </Border>

        <!-- Row 3: Illustration -->
        <DockPanel Grid.Row="2" Width="Auto" LastChildFill="True">
            <Border Name="bdThumb" BorderBrush="#DCD8E0" BorderThickness="1,1,1,1"
                    DockPanel.Dock="Right" HorizontalAlignment="Right">
                <Canvas Name="cvsThumb" Width="180" Height="180" Focusable="True">
                </Canvas>
            </Border>
            <DockPanel Width="Auto">
                <Border Name="m_borders" BorderBrush="#DCE0D8" BorderThickness="1,1,1,1" HorizontalAlignment="Left">
                    <Canvas Name="cvsIllustration" Width="180" Height="180" Focusable="True">
                    </Canvas>
                </Border>
                <DockPanel LastChildFill="True">
                    <TextBox Height="20" DockPanel.Dock="Bottom" Margin="0,0,0,0">

                    </TextBox>
                    <TextBlock Name="tbLog" Width="Auto" Height="Auto" Background="#EEE4D4" DockPanel.Dock="Top" Margin="0,0,0,0">

                    </TextBlock>
                </DockPanel>
            </DockPanel>
        </DockPanel>
    </Grid>
</UserControl>
<!-- _IMGDISP_SOURCE_FILE_IMGDISP_XAML END -->
// _IMGDISP_SOURCE_FILE_IMGDISP_XAMLCS

using System;
using System.Collections.Generic;
//using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
//using System.Windows.Forms;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace ImgDisp.Ctrl
{
    /// <summary>
    /// Interaction logic for ImgDisp.xaml
    /// </summary>
    public partial class ImgDispCtrl : UserControl, IImgDispControlAccessor
    {
        // VM
        protected IImgDispVM _imgDispVM;

        // settings
        static protected readonly PixelFormat defTargetFormat = PixelFormats.Bgr32;
        static protected readonly System.Windows.Media.Color defColorBufferBkg = System.Windows.Media.Colors.Black;
        static protected readonly System.Windows.Media.Color defColorBufferIllu = System.Windows.Media.Colors.Black;
        static protected readonly IMGDISP_LIMITLEVEL defLimitLevel = IMGDISP_LIMITLEVEL.IDLL_32;

        // image
        protected bool          bImg = false;   // indirectly bind to VM (from VM)
        protected WriteableBitmap wBmpBuffer;     // indirectly bind to VM (to VM)

        // iilustration
        protected WriteableBitmap wBmpIllustration; // indirectly bind to VM (to VM)
        protected WriteableBitmap wBmpThumb; // indirectly bind to VM (to VM)

        // UI
        protected bool          bDrag = false;
        protected bool          bDragZoom = false;
        protected System.Windows.Point ptDrag0 = new System.Windows.Point(0.0, 0.0);
        protected System.Windows.Point ptDragA = new System.Windows.Point(0.0, 0.0);

        // event
        public event Action<WriteableBitmap> EventBufferImgChanged;
        public event Action<WriteableBitmap> EventBufferIllusImgChanged;
        public event Action<WriteableBitmap> EventBufferThumbImgChanged;
        public event Action<Vector, Point>  EventDrag;
        public event Action<int, Point>     EventWheel;
        public event Action<Vector, Point>  EventDragZoom;
        public event Action<Point>          EventDragZoomBegin;

        public event Action<Vector, Point>  EventMouseMove;
        public event Action<Point>          EventMouseLeftDown;


        #region Constructor

        public ImgDispCtrl()
        {
            InitializeComponent();

            Init();
        }

        protected void Init()
        {
            //
            // VM
            //
            try
            {
                _imgDispVM = new ImgDispVM(this);
            }
            catch (Exception ex)
            {
                string errMsg = ex.Message;
                MessageBox.Show("Error in load VM: \n" + errMsg);
                _imgDispVM = null;
            }
            this.DataContext = _imgDispVM;

            if (_imgDispVM != null)
            {
                // VM event
                _imgDispVM.EventIllustrationImgResize += this.OnEventIllustrationImgResize;
                _imgDispVM.EventPixelFormatChange += this.OnEventPixelFormatChange;
                _imgDispVM.EventBImgChange += this.OnEventBImgChange;
            }

            //
            // settings
            //  put after VM, in order to update settings into it
            ColorBufferBkg      = defColorBufferBkg;
            ColorBufferIllu     = defColorBufferIllu;
            TargetPixelFormat   = defTargetFormat;
            LimitLevel          = defLimitLevel;

            //
            // image
            //
            bImg = false;
            RenewBufferImg(BufCanvasWidth, BufCanvasHeight, TargetPixelFormat);

            //
            // illustration
            //
            UpdateIllustrationImg(IlluBufImgWidth, IlluBufImgHeight);
            UpdateThumbImg(ThumbBufImgWidth, ThumbBufImgHeight);

            //
            // UI
            //
            // buffer
            cvsBuffer.Focusable = true;
            //cvsBuffer.Background = new SolidColorBrush(colorBuffer);

            bDrag = false;
        }

        #endregion Constructor

        #region settings

        public System.Windows.Media.Color ColorBufferBkg
        {
            get
            {
                if (_imgDispVM != null)
                {
                    System.Drawing.Color colorBuf = _imgDispVM.ColorBufferBkg;
                    return System.Windows.Media.Color.FromArgb(
                        colorBuf.A, colorBuf.R, colorBuf.G, colorBuf.B);
                }
                return System.Windows.Media.Colors.Black;
            }
            set
            {
                if (_imgDispVM != null)
                {
                    _imgDispVM.ColorBufferBkg = System.Drawing.Color.FromArgb(
                        value.A, value.R, value.G, value.B);
                }
            }
        }

        public System.Windows.Media.Color ColorBufferIllu
        {
            get
            {
                if (_imgDispVM != null)
                {
                    System.Drawing.Color colorBuf = _imgDispVM.ColorBufferIllu;
                    return System.Windows.Media.Color.FromArgb(
                        colorBuf.A, colorBuf.R, colorBuf.G, colorBuf.B);
                }
                return System.Windows.Media.Colors.Black;
            }
            set
            {
                if (_imgDispVM != null)
                {
                    _imgDispVM.ColorBufferIllu = System.Drawing.Color.FromArgb(
                        value.A, value.R, value.G, value.B);
                }
            }
        }

        public PixelFormat TargetPixelFormat
        {
            get
            {
                if (_imgDispVM != null)
                {
                    return _imgDispVM.TargetPixelFormat;
                }
                return defTargetFormat;
            }
            set
            {
                if (_imgDispVM != null)
                {
                    _imgDispVM.TargetPixelFormat = value;
                }
            }
        }

        public void OnEventPixelFormatChange(PixelFormat format)
        {
            RenewBufferImg(BufCanvasWidth, BufCanvasHeight, format);
        }

        public IMGDISP_LIMITLEVEL LimitLevel
        {
            get
            {
                if (_imgDispVM != null)
                {
                    return _imgDispVM.LimitLevel;
                }
                return IMGDISP_LIMITLEVEL.IDLL_UNKNOWN;
            }
            set
            {
                if (_imgDispVM != null)
                {
                    _imgDispVM.LimitLevel = value;
                }
            }
        }

        #endregion settings

        #region Buffer

        public int BufCanvasWidth
        {
            get
            {
                return (int)cvsBuffer.Width;
            }
            protected set
            {
                cvsBuffer.Width = value;
            }
        }

        public int BufCanvasHeight
        {
            get
            {
                return (int)cvsBuffer.Height;
            }
            protected set
            {
                cvsBuffer.Height = value;
            }
        }

        protected bool RenewBufferImg(int w, int h, PixelFormat format)
        {
            WriteableBitmap bmpNew = null;
            try
            {
                bmpNew = new WriteableBitmap((int)w, (int)h, 180, 180, format, null);
                System.Windows.Media.Color colorBufferBkg = ColorBufferBkg;
                ImgDisp.Img.ImgDisp.Clear_XRGB(bmpNew, System.Drawing.Color.FromArgb(colorBufferBkg.A, colorBufferBkg.R, colorBufferBkg.G, colorBufferBkg.B));
            }
            catch (Exception ex)
            {
                MessageBox.Show("RenewBufferImg: create new wbmp failed! Error: " + ex.Message);
                return false;
            }

            return SetImgToBuffer(bmpNew);
        }

        // updater
        protected bool SetImgToBuffer(WriteableBitmap wbmp)
        {
            wBmpBuffer = wbmp;

            OnBufferImgChange();

            // set to buffer control
            try
            {
                if (wBmpBuffer == null)
                {
                    System.Windows.Media.Color colorBufferBkg = ColorBufferBkg;
                    this.cvsBuffer.Background = new SolidColorBrush(colorBufferBkg);
                }
                else
                {
                    ImageBrush imageBrush = new ImageBrush(wBmpBuffer);
                    this.cvsBuffer.Background = imageBrush;
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show("SetImgToBuffer: set buffer to control background failed!\nError: " + ex.Message);
                return false;
            }

            return true;
        }

        // local handler
        protected bool OnBufferImgChange()
        {
            BufCanvasWidth    = wBmpBuffer.PixelWidth;
            BufCanvasHeight   = wBmpBuffer.PixelHeight;

            PostEventBufferImgChanged();

            return true;
        }

        // event poster
        protected void PostEventBufferImgChanged()
        {
            if (EventBufferImgChanged != null)
            {
                EventBufferImgChanged(wBmpBuffer);
            }
        }

        #endregion Buffer

        #region Image

        public bool BImg
        {
            get
            {
                return bImg;
            }
        }

        public bool OpenImage(string file)
        {
            bool ret = false;
            if (_imgDispVM != null)
            {
                ret = _imgDispVM.OpenImage(file);
            }

            return ret;
        }

        // event handler
        public void OnEventBImgChange(bool bi)
        {
            bImg = bi;
        }

        #endregion Image


        #region Illustration

        public int IlluBufImgWidth
        {
            get
            {
                return (int)cvsIllustration.Width;
            }
            protected set
            {
                cvsIllustration.Width = value;
            }
        }

        public int IlluBufImgHeight
        {
            get
            {
                return (int)cvsIllustration.Height;
            }
            protected set
            {
                cvsIllustration.Height = value;
            }
        }

        public int ThumbBufImgWidth
        {
            get
            {
                return (int)cvsThumb.Width;
            }
            protected set
            {
                cvsThumb.Width = value;
            }
        }

        public int ThumbBufImgHeight
        {
            get
            {
                return (int)cvsThumb.Height;
            }
            set
            {
                cvsThumb.Height = value;
            }
        }

        protected bool UpdateIllustrationImg(int w, int h)
        {
            WriteableBitmap bmpNew = null;
            try
            {
                bmpNew = new WriteableBitmap(w, h, 360, 360, defTargetFormat, null);
                System.Windows.Media.Color colorBufferIllu = ColorBufferIllu;
                ImgDisp.Img.ImgDisp.Clear_XRGB(bmpNew, System.Drawing.Color.FromArgb(colorBufferIllu.A, colorBufferIllu.R, colorBufferIllu.G, colorBufferIllu.B));
            }
            catch(Exception ex)
            {
                MessageBox.Show("UpdateIllustrationImg: create new illustration wbmp failed! Error: " + ex.Message);
                return false;
            }

            return SetImgToIllustration(bmpNew);
        }

        // updater
        protected bool SetImgToIllustration(WriteableBitmap wbmp)
        {
            wBmpIllustration = wbmp;

            OnIllustrationImgChange();

            // set to illustration control
            try
            {
                if (wBmpIllustration == null)
                {
                    System.Windows.Media.Color colorBufferIllu = ColorBufferIllu;
                    this.cvsIllustration.Background = new SolidColorBrush(colorBufferIllu);
                }
                else
                {
                    ImageBrush imageBrush = new ImageBrush(wBmpIllustration);
                    this.cvsIllustration.Background = imageBrush;
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show("SetImgToIllustration: set wbmp to buffer failed! : " + ex.Message);
                return false;
            }

            return true;
        }
        protected bool UpdateThumbImg(int w, int h)
        {
            WriteableBitmap bmpNew = null;
            try
            {
                bmpNew = new WriteableBitmap(w, h, 360, 360, defTargetFormat, null);
                System.Windows.Media.Color colorBufferIllu = ColorBufferIllu;
                ImgDisp.Img.ImgDisp.Clear_XRGB(bmpNew, System.Drawing.Color.FromArgb(colorBufferIllu.A, colorBufferIllu.R, colorBufferIllu.G, colorBufferIllu.B));
            }
            catch (Exception ex)
            {
                MessageBox.Show("UpdateThumbImg: create new illustration wbmp failed! Error: " + ex.Message);
                return false;
            }

            return SetImgToThumb(bmpNew);
        }

        // updater
        protected bool SetImgToThumb(WriteableBitmap wbmp)
        {
            wBmpThumb = wbmp;

            OnThumbImgChange();

            // set to illustration control
            try
            {
                if (wBmpThumb == null)
                {
                    System.Windows.Media.Color colorBufferIllu = ColorBufferIllu;
                    this.cvsThumb.Background = new SolidColorBrush(colorBufferIllu);
                }
                else
                {
                    ImageBrush imageBrush = new ImageBrush(wBmpThumb);
                    this.cvsThumb.Background = imageBrush;
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show("SetImgToThumb: set wbmp to buffer failed! : " + ex.Message);
                return false;
            }

            return true;
        }

        // local handler
        protected bool OnIllustrationImgChange()
        {
            IlluBufImgWidth     = this.wBmpIllustration.PixelWidth;
            IlluBufImgHeight    = this.wBmpIllustration.PixelHeight;

            PostEventBufferIllusImgChanged();

            return true;
        }
        protected bool OnThumbImgChange()
        {
            ThumbBufImgWidth    = this.wBmpThumb.PixelWidth;
            ThumbBufImgHeight   = this.wBmpThumb.PixelHeight;

            PostEventBufferThumbImgChanged();

            return true;
        }

        // event poster
        protected void PostEventBufferIllusImgChanged()
        {
            if (EventBufferIllusImgChanged != null)
            {
                EventBufferIllusImgChanged(wBmpIllustration);
            }
        }
        protected void PostEventBufferThumbImgChanged()
        {
            if (EventBufferThumbImgChanged != null)
            {
                EventBufferThumbImgChanged(wBmpThumb);
            }
        }

        // event handler
        protected void OnEventIllustrationImgResize(int w, int h)
        {
            UpdateIllustrationImg(w, h);
        }

        protected void OnEventThumbImgResize(int w, int h)
        {
            UpdateThumbImg(w, h);
        }
        #endregion Illustration


        #region Transform

        #region Translate

        public Int64 TranslateX
        {
            get
            {
                if (_imgDispVM != null)
                {
                    return _imgDispVM.TranslateX;
                }
                return 0;
            }
        }

        public Int64 TranslateY
        {
            get
            {
                if (_imgDispVM != null)
                {
                    return _imgDispVM.TranslateY;
                }
                return 0;
            }
        }

        #endregion Translate

        #endregion Transform
        

        #region Mouse Handler

        public Point MousePos()
        {
            return Mouse.GetPosition(cvsBuffer);
        }
        public System.Windows.Controls.Canvas CanvasMain
        {
            get
            {
                return cvsBuffer;
            }
        }
        public System.Windows.Controls.TextBlock TBLog
        {
            get
            {
                return tbLog;
            }
        }

        private delegate void FuncAppendLog(String str);
        public void AppendLog(String str)
        {
            tbLog.Text += "\n" + str;
        }
        public void AppendLogAsync(String str)
        {
            Dispatcher.BeginInvoke((FuncAppendLog)AppendLog, str);
        }

        protected void OnMouseMove()
        {
            if (bDrag)
            {
                OnDrag();
            }
            else if (bDragZoom)
            {
                OnDragZoom();
            }
        }

        protected void BeginDrag()
        {
            if (!bDrag && !bDragZoom)
            {
                ptDrag0 = Mouse.GetPosition(cvsBuffer);
                ptDragA = ptDrag0;

                Mouse.Capture(bdBuffer);

                bDrag = true;
            }
        }

        protected void OnDrag()
        {
            // update point
            System.Windows.Point ptDragB = Mouse.GetPosition(cvsBuffer);
            Vector vec = ptDragB - ptDragA;
            ptDragA = ptDragB;

            // #2 post drag event
            //PostEventDrag(vec, ptDragB);
            // TODO: for TPUT
            if (_imgDispVM != null)
            {
                _imgDispVM.OnEventDragImage(vec, ptDragB);
            }
        }

        protected void EndDrag()
        {
            if (bDrag)
            {
                bDrag = false;

                Mouse.Capture(null);
            }
        }

        protected void BeginDragZoom()
        {
            if (!bDrag && !bDragZoom)
            {
                // get base point on csvBuffer
                ptDrag0 = Mouse.GetPosition(cvsBuffer);
                ptDragA = ptDrag0;

                Mouse.Capture(bdBuffer);

                bDragZoom = true;

                // post event
                PostEventDragZoomBegin(ptDrag0);
            }
        }

        protected void OnDragZoom()
        {
            System.Windows.Point ptDragB = Mouse.GetPosition(cvsBuffer);
            //Vector vec0 = ptDragB - ptDrag0;
            Vector vec = ptDragB - ptDragA;
            ptDragA = ptDragB;

            PostEventDragZoom(vec, ptDrag0);
        }

        protected void EndDragZoom()
        {
            if (bDragZoom)
            {
                bDragZoom = false;

                Mouse.Capture(null);
            }
        }

        protected void PostEventDrag(Vector vec, Point pt)
        {
            if (EventDrag != null)
            {
                EventDrag(vec, pt);
            }
        }

        protected void OnMouseWheel(int dw)
        {
            PostEventWheel(dw);
        }

        protected void PostEventWheel(int dw)
        {
            if (EventWheel != null)
            {
                System.Windows.Point pt = Mouse.GetPosition(cvsBuffer);
                EventWheel(dw, pt);
            }
        }

        protected void PostEventDragZoomBegin(Point pt)
        {
            if (EventDragZoomBegin != null)
            {
                EventDragZoomBegin(pt);
            }
        }

        protected void PostEventDragZoom(Vector vec, Point pt)
        {
            if (EventDragZoom != null)
            {
                EventDragZoom(vec, pt);
            }
        }

        #endregion Drag Handler

        #region UI

        public void OnWindowSizeChanged(object sender, SizeChangedEventArgs e)
        {
            if (Double.IsNaN(bdBuffer.Width) || Double.IsNaN(bdBuffer.Height))
            {
                return;
            }

            int bufWNew = (int)bdBuffer.Width;
            int bufHNew = (int)bdBuffer.Height;
            RenewBufferImg(bufWNew, bufHNew, TargetPixelFormat);
        }

        private void bdBuffer_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)
        {
            //EndDrag();
        }

        private void bdBuffer_MouseLeftButtonDown_1(object sender, MouseButtonEventArgs e)
        {
            //if (bImg)
            //{
            //    BeginDrag();
            //}

            //if (EventMouseLeftDown != null)
            //{
            //    EventMouseLeftDown(Mouse.GetPosition(cvsBuffer));
            //}
        }

        private void bdBuffer_MouseRightButtonDown(object sender, MouseButtonEventArgs e)
        {
            //if (bImg)
            //{
            //    BeginDragZoom();
            //}
        }

        private void bdBuffer_MouseRightButtonUp(object sender, MouseButtonEventArgs e)
        {
            //EndDragZoom();
        }

        private void bdBuffer_MouseMove(object sender, System.Windows.Input.MouseEventArgs e)
        {
            //if (bDrag)
            //{
            //    OnDrag();
            //}
            //else if (bDragZoom)
            //{
            //    OnDragZoom();
            //}

            //if (EventMouseMove != null)
            //{
            //    EventMouseMove(Mouse.GetPosition(cvsBuffer));
            //}
        }

        private void bdBuffer_MouseWheel(object sender, MouseWheelEventArgs e)
        {
            //if (bImg)
            //{
            //    OnMouseWheel(e.Delta);
            //}
        }

        private void bdBuffer_LostFocus(object sender, RoutedEventArgs e)
        {
            //EndDrag();
            //EndDragZoom();
        }

        private void Button_Close_Click(object sender, RoutedEventArgs e)
        {
            bool ret = false;
            if (_imgDispVM != null)
            {
                ret = _imgDispVM.ClearImage();

                bImg = false;
            }
        }

        #endregion UI
    }
}
// _IMGDISP_SOURCE_FILE_IMGDISP_XAMLCS END
// _IMGDISP_SOURCE_FILE_IIMGDISPVM_CS

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace ImgDisp.Ctrl
{
    public enum IMGDISP_LIMITLEVEL
    {
        IDLL_UNKNOWN    = 0,
        IDLL_32         = 32,
        IDLL_64         = 64
    }

    public interface IImgDispVM
    {
        //
        // event
        //
        event Action<int, int>          EventIllustrationImgResize;
        event Action<System.Windows.Media.PixelFormat> EventPixelFormatChange;
        event Action<bool>              EventBImgChange;

        //
        // event handler
        //
        //void OnEventBufferImgChange(System.Windows.Media.Imaging.WriteableBitmap wbmp);
        //void OnEventBufferIllusImgChange(System.Windows.Media.Imaging.WriteableBitmap wbmp2);

        //void OnEventColorBufferBkgChange(System.Windows.Media.Color color);
        //void OnEventColorBufferIllusChange(System.Windows.Media.Color color);

        void OnEventDragImage(System.Windows.Vector vec, System.Windows.Point pt);
        void OnEventWheel(int dw, System.Windows.Point pt);
        void OnEventDragZoom(System.Windows.Vector vec, System.Windows.Point pt);
        void OnEventDragZoomBegin(System.Windows.Point pt);

        //
        // Settings
        //
        int BlockSize
        {
            get;
        }
        bool BRenderIllustration
        {
            get;
            set;
        }

        bool BRenderIllustrationClipRegion
        {
            get;
            set;
        }
        System.Drawing.Color ColorBufferBkg
        {
            get;
            set;
        }
        System.Drawing.Color ColorBufferIllu
        {
            get;
            set;
        }
        IMGDISP_LIMITLEVEL LimitLevel
        {
            get;
            set;
        }

        // Buffer
        System.Windows.Media.PixelFormat TargetPixelFormat
        {
            get;
            set;
        }

        // Image
        Int64 ImgWidth
        {
            get;
        }
        Int64 ImgHeight
        {
            get;
        }
        bool BImg
        {
            get;
        }

        // Image Info
        int ImgWidthBase
        {
            get;
        }
        int ImgHeightBase
        {
            get;
        }
        int ImgBPP
        {
            get;
        }

        // transform
        // translation
        Int64 TranslateX
        {
            get;
        }
        Int64 TranslateY
        {
            get;
        }

        // Scale
        double Scale
        {
            get;
        }

        // Function
        bool HasImage();
        bool OpenImage(string file);
        bool ClearImage();
    }
}
// _IMGDISP_SOURCE_FILE_IIMGDISPVM_CS END
// _IMGDISP_SOURCE_FILE_IIMGDISPCONTROLACCESSOR_CS

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Media.Imaging;

namespace ImgDisp.Ctrl
{
    interface IImgDispControlAccessor
    {
        event Action<WriteableBitmap>   EventBufferImgChanged;
        event Action<WriteableBitmap>   EventBufferIllusImgChanged;
        event Action<WriteableBitmap>   EventBufferThumbImgChanged;
        event Action<Vector, Point>     EventDrag;
        event Action<int, Point>        EventWheel;
        event Action<Vector, Point>     EventDragZoom;
        event Action<Point>             EventDragZoomBegin;

        event Action<Vector, Point>     EventMouseMove;
        event Action<Point>             EventMouseLeftDown;

        
        System.Windows.Media.Color      ColorBufferBkg
        {
            get;
            set;
        }

        System.Windows.Media.Color      ColorBufferIllu
        {
            get;
            set;
        }

        System.Windows.Media.PixelFormat TargetPixelFormat
        {
            get;
            set;
        }

        IMGDISP_LIMITLEVEL              LimitLevel
        {
            get;
            set;
        }

        bool                            BImg
        {
            get;
        }

        Point MousePos();

        System.Windows.Controls.Canvas CanvasMain
        {
            get;
        }

        System.Windows.Controls.TextBlock TBLog
        {
            get;
        }
        void AppendLog(String str);
        void AppendLogAsync(String str);
    }
}
// _IMGDISP_SOURCE_FILE_IIMGDISPCONTROLACCESSOR_CS END
// _IMGDISP_SOURCE_FILE_SCOPEGUARD_CS

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ImgDisp.Img
{
    public class ScopeGuard : System.IDisposable
    {
        private bool disposed = false;

        protected virtual void Dispose(bool disposing)
        {
            if (disposed)
            {
                return;
            }

            if (disposing)
            {
                // Managed here
                if (eventRelease != null)
                {
                    eventRelease();
                }
            }

            // Unmanaged here
            //..

            disposed = true;
        }

        public event Action eventRelease;

        public ScopeGuard()
        {
        }

        public ScopeGuard(Action act)
        {
            eventRelease += act;
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
        ~ScopeGuard()
        {
            Dispose(false);
        }
    }
}
// _IMGDISP_SOURCE_FILE_SCOPEGUARD_CS END
// _IMGDISP_SOURCE_FILE_IMGDISPUTILITY_CS

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ImgDisp.Img
{
    unsafe internal partial class ImgDisp
    {
        #region Property

        static public System.Windows.Duration ZeroDuration
        {
            get
            {
                TimeSpan ts = new TimeSpan(0, 0, 0, 0, 0);
                return new System.Windows.Duration(ts);
            }
        }

        #endregion Property

        #region SCG

        static public Action GetActionUnlockWBMP(System.Windows.Media.Imaging.WriteableBitmap wBmp)
        {
            Action actUnlockWBmp = () =>
            {
                wBmp.Unlock();
            };
            return actUnlockWBmp;
        }
        static public Action GetActionFreeAlloc(IntPtr ptr)
        {
            Action actFree = () =>
            {
                if (ptr != null)
                {
                    System.Runtime.InteropServices.Marshal.FreeHGlobal((IntPtr)ptr);
                }
            };
            return actFree;
        }
        static public ScopeGuard GetSCGWBMPLock(System.Windows.Media.Imaging.WriteableBitmap wBmp)
        {
            return new ScopeGuard(GetActionUnlockWBMP(wBmp));
        }
        static public ScopeGuard GetSCGAlloc(IntPtr ptr)
        {
            return new ScopeGuard(GetActionFreeAlloc(ptr));
        }

        #endregion SCG

        #region Img

        public static bool Clear_XRGB(
            System.Windows.Media.Imaging.WriteableBitmap bmp, System.Drawing.Color color)
        {
            if (bmp == null)
            {
                return false;
            }

            int w = bmp.PixelWidth;
            int h = bmp.PixelHeight;
            if (w <= 0 || h <= 0)
            {
                return false;
            }

            if (!bmp.TryLock(ImgDisp.ZeroDuration))
            {
                return false;
            }
            using (ScopeGuard scgWBMPLock = GetSCGWBMPLock(bmp))
            {
                int* pBuf = (int*)bmp.BackBuffer.ToPointer();

                if (bmp.Format == System.Windows.Media.PixelFormats.Bgr32)
                {
                    int* pRow = (int*)pBuf;
                    int colorVal = color.ToArgb();
                    for (int idx = 0; idx < w * h; ++idx)
                    {
                        pRow[idx] = colorVal;
                    }
                }
                else if (bmp.Format == System.Windows.Media.PixelFormats.Gray16)
                {
                    int stride = bmp.BackBufferStride;
                    ushort* pRow = (ushort*)pBuf;
                    ushort col = (ushort)(color.GetBrightness() * ushort.MaxValue);
                    for (int j = 0; j < h; ++j, pRow = (ushort*)((byte*)pRow + stride))
                    {
                        for (int i = 0; i < w; ++i)
                        {
                            pRow[i] = col;
                        }
                    }
                }

                bmp.AddDirtyRect(new System.Windows.Int32Rect(0, 0, (int)w, (int)h));

                //bmp.Unlock();

                return true;
            }
        }

        #endregion Img
    }
}
// _IMGDISP_SOURCE_FILE_IMGDISPUTILITY_CS END
// _IMGDISP_SOURCE_FILE_IMGDISP_CS

using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Media.Imaging;

namespace ImgDisp.Img
{
    unsafe internal partial class ImgDisp
    {
        public static int CalcSizeScale(
            ref double k, int w, int h, out Int64 wd, out Int64 hd,
            Int64 iLimitMax = Int64.MaxValue)
        {
            if (k < 0)
            {
                wd = 0;
                hd = 0;
                return -1;
            }
            if (k == 0)
            {
                wd = 0;
                hd = 0;
                return 1;
            }

            double maxLen = iLimitMax / k;
            if (maxLen <= w || maxLen <= h)
            {
                if (w > h)
                {
                    wd = iLimitMax;
                    hd = (Int64)((double)wd / w * h);
                    k = (double)wd / w;
                }
                else
                {
                    hd = iLimitMax;
                    wd = (Int64)((double)hd / h * w);
                    k = (double)hd / h;
                }
                return 0;
            }

            wd = (Int64)(w * k + 0.5);
            hd = (Int64)(h * k + 0.5);

            return 1;
        }
    }


    //[DllImport("gdi32.dll")]
    //public static extern int SetDIBitsToDevice(IntPtr hdc, int x, int y, int dx, int dy, int SrcX, int SrcY, int Scan, int NumScans, IntPtr Bits, IntPtr BitsInfo, int wUsage);

    //[StructLayout(LayoutKind.Sequential)]
    //class BITMAPINFOHEADER
    //{
    //    UInt32      biSize;
    //    int         biWidth;// LONG
    //    int         biHeight;// LONG
    //    UInt16      biPlanes;
    //    UInt16      biBitCount;
    //    UInt32      biCompression;
    //    UInt32      biSizeImage;
    //    int         biXPelsPerMeter;// LONG
    //    int         biYPelsPerMeter;// LONG
    //    UInt32      biClrUsed;
    //    UInt32      biClrImportant;
    //}

    //[StructLayout(LayoutKind.Sequential)]
    //class RGBQUAD {
    //    byte        rgbBlue;
    //    byte        rgbGreen;
    //    byte        rgbRed;
    //    byte        rgbReserved;
    //}

    //[StructLayout(LayoutKind.Sequential)]
    //class BITMAPINFO {
    //    BITMAPINFOHEADER    bmiHeader;
    //    IntPtr              bmiColors;// RGBQUAD[1]
    //}
}
// _IMGDISP_SOURCE_FILE_IMGDISP_CS END
// _IMGDISP_SOURCE_FILE_IMGDISPVM_CS

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows;
using System.Diagnostics;
using System.Runtime.InteropServices;

using Wrapper;
using ImgDisp.Img;
using System.IO;

namespace ImgDisp.Ctrl
{
    class ImgDispVM : INotifyPropertyChanged, IImgDispVM
    {
        //
        // Event
        //
        // Property Changed
        public event PropertyChangedEventHandler PropertyChanged;
        public void OnPropertyChange(string PropertyName)
        {
            if (PropertyChanged != null)
            {
                PropertyChanged(this, new PropertyChangedEventArgs(PropertyName));
            }
        }
        // Other event
        public event Action<int, int>       EventIllustrationImgResize;
        public event Action<PixelFormat>    EventPixelFormatChange;
        public event Action<bool>           EventBImgChange;

        //
        // Control
        //
        private IImgDispControlAccessor ctrlAccessor;
        protected MouseKeyEventWrapper mkEvent = new MouseKeyEventWrapper();
        protected MouseKeyHandler mkHandler = new MouseKeyHandler();

        //
        // Settings
        //
        static protected readonly int defBlockSize = 1024;
        static protected readonly PixelFormat defTargetFormat = PixelFormats.Bgr32;
        static protected readonly System.Drawing.Color defColorBufferBkg = System.Drawing.Color.Black;
        static protected readonly System.Drawing.Color defColorBufferIllu = System.Drawing.Color.Black;
        static protected readonly IMGDISP_LIMITLEVEL defLimitLevel = IMGDISP_LIMITLEVEL.IDLL_32;
        static protected readonly Int64 defScaleLimitMax = Int32.MinValue;
        static protected readonly Int64 defScaleLimitMin = Int32.MinValue;

        protected int           blockSize           = defBlockSize;
        protected System.Drawing.Color colorBufferBkg = defColorBufferBkg;
        protected System.Drawing.Color colorBufferIllu = defColorBufferIllu;

        protected List<PixelFormat> validPixelFormats;
        protected PixelFormat   targetPixelFormat = defTargetFormat;
        // type define(type limit)
        protected IMGDISP_LIMITLEVEL limitLevel = defLimitLevel;
        protected Int64         iScaleLimitMax = defScaleLimitMax;
        protected Int64         iScaleLimitMin = defScaleLimitMin;

        protected bool          bRenderIllustration = false;
        protected bool          bRenderIllustrationClipRegion = false;
        protected bool          bImgSpecChangeEnabled = true;


        //
        // ImgDisp
        //
        //private ImgDisp     img;
        protected ImgDispWrapper imgDisp = new ImgDispWrapper();

        FileSystemWatcher fsWatcher = new FileSystemWatcher();
        String fileLogger       = null;
        int posLog = 0;

        //
        // Image
        //
        protected bool          bImg = false;       // image status
        // main buffer 
        protected WriteableBitmap wBmpBuffer = null;// bind to control (same object)
        protected int           bufImgWidth = 0;    // indirectly bind to control
        protected int           bufImgHeight = 0;   // indirectly bind to control
        //protected Graphics    g = null;
        // image info
        protected int           imgWidthBase = 0;
        protected int           imgHeightBase = 0;
        protected int           imgBPP = 0;

        //
        // Trasform
        //
        protected Int64         imgWidth = 0;       // actual image width (after scale)
        protected Int64         imgHeight = 0;      // actual image height (after scale)
        protected double        scale = 0;
        protected Int64         translateX = 0;
        protected Int64         translateY = 0;
        // Helper transform param
        protected double        xRate = 0;
        protected double        yRate = 0;
        protected Int64         imgDestX = 0;       // obsolete
        protected Int64         imgDestY = 0;       // obsolete
        protected Rectangle     rcSrc = Rectangle.Empty;// obsolete

        //
        // Illustration
        //
        protected WriteableBitmap wBmpIllustration = null;// bind to control (same object)
        protected WriteableBitmap wBmpThumb = null;// bind to control (same object)

        //
        // Info
        //
        protected Int64         cursorX = 0;
        protected Int64         cursorY = 0;
        protected double        time = 0;
        protected double        timeTotal = 0;
        protected double        fpsFake = 0;
        protected long          frameCount = 0;


        #region Constructor

        public ImgDispVM(IImgDispControlAccessor ctrl)
        {
            if (ctrl == null)
            {
                return;
            }
            ctrlAccessor = ctrl;
            
            // ImgDisp C#
            //img = new ImgDisp();
            //img.ColorBufferBkg = colorBufferBkg;
            //img.ColorBufferIllustration = colorBufferIllu;
            //img.SetBlockSize(blockSize);
            // ImgDisp
            if (imgDisp == null)
            {
                return;
            }
            //imgDisp.SetBlockSize(blockSize);
            //imgDisp.SetColorBkg((UInt32)colorBufferBkg.ToArgb());
            //imgDisp.SetColorIllus((UInt32)colorBufferIllu.ToArgb());

            // Log Watcher
            if (fsWatcher == null)
            {
                return;
            }
            fsWatcher.IncludeSubdirectories = false;
            fileLogger = ImgProcessWrapper.GetLog0File();
            int idxSplit = fileLogger.LastIndexOf('\\');
            if (idxSplit > -1)
            {
                fsWatcher.Path = fileLogger.Substring(0, idxSplit + 1);
                fsWatcher.Filter = fileLogger.Substring(idxSplit + 1);

                fsWatcher.EnableRaisingEvents = true;
                fsWatcher.Changed += LogWatcher_Changed;
            }

            // Bind MouseKey Event Handler with UIElement
            if (!mkEvent.Bind((System.Windows.UIElement)(ctrlAccessor.CanvasMain)))
            {
                return;
            }
            mkHandler.SetFuncMouseLeftDrag(this.OnEventDragImage);
            mkHandler.SetFuncMouseRightDrag(this.OnEventDragZoom);
            mkHandler.SetFuncMouseMove(this.OnMouseMove);
            mkHandler.SetFuncMouseWheel(this.OnEventWheel);
            mkHandler.SetFuncMouseRightDragBegin(this.OnEventDragZoomBegin);
            if (!mkEvent.BindHandler(mkHandler))
            {
                return;
            }

            BImg = false;

            // Settings
            //  put after ImgDisp, in order to update the settings into it
            validPixelFormats = new List<PixelFormat>();
            validPixelFormats.Add(PixelFormats.Bgr32);
            //validPixelFormats.Add(PixelFormats.Gray16);
            //validPixelFormats.Add(PixelFormats.Gray8);
            //validPixelFormats.Add(PixelFormats.Bgra32);

            BlockSize = blockSize;
            BRenderIllustration = false;
            BRenderIllustrationClipRegion = false;
            ColorBufferBkg = System.Drawing.Color.FromArgb(
                ctrlAccessor.ColorBufferBkg.A, ctrlAccessor.ColorBufferBkg.R, ctrlAccessor.ColorBufferBkg.G, ctrlAccessor.ColorBufferBkg.B);
            ColorBufferIllu = System.Drawing.Color.FromArgb(
                ctrlAccessor.ColorBufferIllu.A, ctrlAccessor.ColorBufferIllu.R, ctrlAccessor.ColorBufferIllu.G, ctrlAccessor.ColorBufferIllu.B);
            LimitLevel = IMGDISP_LIMITLEVEL.IDLL_32;
            TargetPixelFormat = PixelFormats.Bgr32;


            // Control
            ctrlAccessor.EventBufferImgChanged += this.OnEventBufferImgChange;
            ctrlAccessor.EventBufferIllusImgChanged += this.OnEventBufferIllusImgChange;
            ctrlAccessor.EventBufferThumbImgChanged += this.OnEventBufferThumbImgChange;
            ctrlAccessor.EventDrag += this.OnEventDragImage;
            ctrlAccessor.EventWheel += this.OnEventWheel;
            ctrlAccessor.EventDragZoom += this.OnEventDragZoom;
            ctrlAccessor.EventDragZoomBegin += this.OnEventDragZoomBegin;

            ctrlAccessor.EventMouseMove += this.OnMouseMove;
            ctrlAccessor.EventMouseLeftDown += this.OnMouseLeftDown;
        }

        #endregion Constructor

        #region Settings

        public int BlockSize
        {
            get
            {
                return blockSize;
            }
            protected set
            {

                // make sure blocksize sync with imgDisp
                if (imgDisp.SetBlockSize(value) < 0)
                {
                    return;
                }
                blockSize = imgDisp.GetBlockSize();
                OnPropertyChange("BlockSize");
            }
        }

        public bool ImgSpecChangeEnabled
        {
            get
            {
                return bImgSpecChangeEnabled;
            }
            protected set
            {
                bImgSpecChangeEnabled = value;
                OnPropertyChange("SldBlockSizeEnabled");
            }
        }

        public bool BRenderIllustration
        {
            get
            {
                return bRenderIllustration;
            }
            set
            {
                bRenderIllustration = value;
                OnBRenderIllustrationChange();
                OnPropertyChange("BRenderIllustration");
            }
        }

        public bool BRenderIllustrationClipRegion
        {
            get
            {
                return bRenderIllustrationClipRegion;
            }
            set
            {
                bRenderIllustrationClipRegion = value;
                OnBRenderIllustrationClipRegionChange();
                OnPropertyChange("BRenderClipRegion");
            }
        }

        public System.Drawing.Color ColorBufferBkg
        {
            get
            {
                return colorBufferBkg;
            }
            set
            {
                colorBufferBkg = value;
                OnColorBufferBkgChange();
                //OnPropertyChange("ColorBufferBkg");
            }
        }

        public System.Drawing.Color ColorBufferIllu
        {
            get
            {
                return colorBufferIllu;
            }
            set
            {
                colorBufferIllu = value;
                OnColorBufferIlluChange();
                //OnPropertyChange("ColorBufferIllu");
            }
        }

        public IMGDISP_LIMITLEVEL LimitLevel
        {
            get
            {
                return limitLevel;
            }
            set
            {
                SetLimitLevel(limitLevel);
                //OnPropertyChange("LimitLevel");
            }
        }

        protected void OnBRenderIllustrationChange()
        {
            if ((!bRenderIllustration && !bRenderIllustrationClipRegion) || !HasImage())
            {
                ImgDisp.Img.ImgDisp.Clear_XRGB(wBmpIllustration, colorBufferIllu);
                ImgDisp.Img.ImgDisp.Clear_XRGB(wBmpThumb, colorBufferBkg);
            }
            else
            {
                RenderIllustration();
            }
        }

        protected void OnBRenderIllustrationClipRegionChange()
        {
            if ((!bRenderIllustration && !bRenderIllustrationClipRegion) || !HasImage())
            {
                ImgDisp.Img.ImgDisp.Clear_XRGB(wBmpIllustration, colorBufferIllu);
                ImgDisp.Img.ImgDisp.Clear_XRGB(wBmpThumb, colorBufferBkg);
            }
            else
            {
                RenderIllustration();
            }
        }

        protected void OnColorBufferBkgChange()
        {
            if (imgDisp != null)
            {
                imgDisp.SetColorBkg((UInt32)colorBufferBkg.ToArgb());
            }

            if (HasImage())
            {
                Render();
            }
            else
            {
                ImgDisp.Img.ImgDisp.Clear_XRGB(wBmpBuffer, colorBufferBkg);
            }
        }

        protected void OnColorBufferIlluChange()
        {
            if (imgDisp != null)
            {
                imgDisp.SetColorIllus((UInt32)colorBufferIllu.ToArgb());
            }

            if (bRenderIllustration)
            {
                RenderIllustration();
            }
            else
            {
                ImgDisp.Img.ImgDisp.Clear_XRGB(wBmpIllustration, colorBufferIllu);
                ImgDisp.Img.ImgDisp.Clear_XRGB(wBmpThumb, colorBufferBkg);
            }
        }

        protected bool SetLimitLevel(IMGDISP_LIMITLEVEL ll)
        {
            limitLevel = ll;
            switch (ll)
            {
                case IMGDISP_LIMITLEVEL.IDLL_64:
                    iScaleLimitMin = Int64.MinValue;
                    iScaleLimitMax = Int64.MaxValue;
                    break;
                case IMGDISP_LIMITLEVEL.IDLL_32:
                    iScaleLimitMin = Int32.MinValue;
                    iScaleLimitMax = Int32.MaxValue;
                    break;
                default:
                    iScaleLimitMin = Int32.MinValue;
                    iScaleLimitMax = Int32.MaxValue;
                    break;
            }
            return true;
        }

        #endregion Settings

        #region Buffer

        public WriteableBitmap WBMPBuffer
        {
            get
            {
                return wBmpBuffer;
            }
            protected set
            {
                wBmpBuffer = value;
                //OnPropertyChange("WBMPBuffer");
            }
        }

        public int BufImgWidth
        {
            get
            {
                if (wBmpBuffer == null)
                {
                    return 0;
                }
                return wBmpBuffer.PixelWidth;
            }
        }

        public int BufImgHeight
        {
            get
            {
                if (wBmpBuffer == null)
                {
                    return 0;
                }
                return wBmpBuffer.PixelHeight;
            }
        }

        protected bool SetTargetPixelFormatInternal(PixelFormat format)
        {
            if (HasImage())
            {
                return false;
            }

            if (!ImgSpecChangeEnabled)
            {
                return false;
            }

            if (validPixelFormats == null || !validPixelFormats.Contains(format))
            {
                return false;
            }

            targetPixelFormat = format;

            return true;
        }

        public PixelFormat TargetPixelFormat
        {
            get
            {
                return targetPixelFormat;
            }
            set
            {
                if (!SetTargetPixelFormatInternal(value))
                {
                    return;
                }

                PostEventPixelFormatChange();

                //OnPropertyChange("TargetPixelFormat");
            }
        }

        protected void PostEventPixelFormatChange()
        {
            if (EventPixelFormatChange != null)
            {
                EventPixelFormatChange(targetPixelFormat);
            }
        }

        #endregion Buffer

        #region Illustration

        public WriteableBitmap WBMPIllustration
        {
            get
            {
                return wBmpIllustration;
            }
            protected set
            {
                wBmpIllustration = value;
                //OnPropertyChange("WBMPIllustration");
            }
        }
        public WriteableBitmap WBMPThumb
        {
            get
            {
                return wBmpThumb;
            }
            protected set
            {
                wBmpThumb = value;
                //OnPropertyChange("WBMPThumb");
            }
        }

        protected bool UpdateIllustrationSize()
        {
            if (wBmpIllustration == null)
            {
                return false;
            }

            int wIlluImg = wBmpIllustration.PixelWidth;
            int hIlluImg = wBmpIllustration.PixelHeight;

            if (ImgHeightBase > 0 && ImgWidthBase > 0)
            {
                wIlluImg = (int)((double)hIlluImg / ImgHeightBase * ImgWidthBase);
            }
            else
            {
                wIlluImg = hIlluImg;
            }
            ResizeIllustrationImg(wIlluImg, hIlluImg);

            return true;
        }

        // event handler
        public void OnEventBufferIllusImgChange(WriteableBitmap wbmp)
        {
            WBMPIllustration = wbmp;
        }

        public void OnEventBufferThumbImgChange(WriteableBitmap wbmp)
        {
            wBmpThumb = wbmp;
        }

        // updater
        protected void ResizeIllustrationImg(int w, int h)
        {
            PostEventIllustrationImgResize(w, h);
        }

        // event poster
        protected void PostEventIllustrationImgResize(int w, int h)
        {
            if (EventIllustrationImgResize != null)
            {
                EventIllustrationImgResize(w, h);
            }
        }

        #endregion Illustration

        #region Image

        public Int64 ImgWidth
        {
            get
            {
                return imgWidth;
            }
            protected set
            {
                imgWidth = value;
                OnPropertyChange("ImgWidth");
            }
        }

        public Int64 ImgHeight
        {
            get
            {
                return imgHeight;
            }
            protected set
            {
                imgHeight = value;
                OnPropertyChange("ImgHeight");
            }
        }

        public bool BImg
        {
            get
            {
                return bImg;
            }
            protected set
            {
                bImg = value;
                PostEventBImgChange();

                ImgSpecChangeEnabled = !bImg;

                OnPropertyChange("BImg");
            }
        }

        // local handler
        protected void OnImgSizeChange()
        {
        }

        // local handler
        protected void OnImgChange()
        {
            // update status
            BImg = HasImage();

            // update info
            if (BImg)
            {
                ImgWidthBase    = imgDisp.GetWidth();
                ImgHeightBase   = imgDisp.GetHeight();
                ImgBPP          = imgDisp.GetBytesPerPixel();
            }
            else
            {
                ImgWidthBase    = 0;
                ImgHeightBase   = 0;
                ImgBPP          = 0;
            }

            // init transform
            double scaleInit = Math.Min((double)BufImgWidth / imgWidthBase, (double)BufImgHeight / imgHeightBase);
            scaleInit = 1.0;
            SetScale(ref scaleInit);
            SetTranslate(0, 0);

            // illustration resize
            UpdateIllustrationSize();
        }

        // updater
        protected bool ResizeImage(Int64 w, Int64 h)
        {
            if (w < 0 || h < 0)
            {
                return false;
            }

            ImgWidth = w;
            ImgHeight = h;

            OnImgSizeChange();

            return true;
        }

        // event handler
        public void OnEventBufferImgChange(WriteableBitmap wbmp)
        {
            WBMPBuffer = wbmp;
        }

        protected void PostEventBImgChange()
        {
            if (EventBImgChange != null)
            {
                EventBImgChange(bImg);
            }
        }

        #endregion Image

        #region Image info

        public int ImgWidthBase
        {
            get
            {
                return imgWidthBase;
            }
            protected set
            {
                imgWidthBase = value;
                OnPropertyChange("ImgWidthBase");
            }
        }

        public int ImgHeightBase
        {
            get
            {
                return imgHeightBase;
            }
            protected set
            {
                imgHeightBase = value;
                OnPropertyChange("ImgHeightBase");
            }
        }

        public int ImgBPP
        {
            get
            {
                return imgBPP;
            }
            protected set
            {
                imgBPP = value;
                OnPropertyChange("ImgBPP");
            }
        }

        #endregion Image info

        #region Transform

        public Int64 ImgDestX
        {
            get
            {
                return imgDestX;
            }
            protected set
            {
                imgDestX = value;
                //OnPropertyChange("ImgDestX");
            }
        }

        public Int64 ImgDestY
        {
            get
            {
                return imgDestY;
            }
            protected set
            {
                imgDestY = value;
                //OnPropertyChange("ImgDestY");
            }
        }

        #region Translation

        public Int64 TranslateX
        {
            get
            {
                return translateX;
            }
            protected set
            {
                translateX = value;
                OnPropertyChange("TranslateX");
            }
        }

        public Int64 TranslateY
        {
            get
            {
                return translateY;
            }
            protected set
            {
                translateY = value;
                OnPropertyChange("TranslateY");
            }
        }

        // local handler
        protected void OnTranslateChange()
        {
            //ImgDestX = (int)(TranslateX >= 0 ? TranslateX : 0);
            //ImgDestY = (int)(TranslateY >= 0 ? TranslateY : 0);
        }

        // updater
        protected bool SetTranslate(Int64 x, Int64 y)
        {
            TranslateX = x;
            TranslateY = y;

            OnTranslateChange();

            return true;
        }

        // handler
        protected void TryTranslate(Vector vec)
        {
            Int64 dx = (Int64)vec.X;
            Int64 dy = (Int64)vec.Y;

            // limit translation
            Int64 imgRightEdge = translateX + imgWidth;
            if (translateX < 0 && iScaleLimitMin - translateX > dx)
            {
                TranslateX = iScaleLimitMin;
            }
            else if (imgRightEdge > 0 && iScaleLimitMax - imgRightEdge < dx)
            {
                TranslateX = iScaleLimitMax - imgWidth;
            }
            else
            {
                TranslateX += (Int64)dx;
            }

            Int64 imgBottomEdge = translateY + imgHeight;
            if (translateY < 0 && iScaleLimitMin - translateY > dy)
            {
                TranslateY = iScaleLimitMin;
            }
            else if (imgBottomEdge > 0 && iScaleLimitMax - imgBottomEdge < dy)
            {
                TranslateY = iScaleLimitMax - imgHeight;
            }
            else
            {
                TranslateY += (Int64)dy;
            }

            //OnTranslateChange();
        }

        #endregion Translation

        #region Scale

        public double Scale
        {
            get
            {
                return scale;
            }
            protected set
            {
                scale = value;
                OnPropertyChange("Scale");
            }
        }

        // updater
        protected int SetScale(ref double scaleNew)
        {
            // Limit scale
            double scaleMin = (imgWidthBase > 0 && imgHeightBase > 0) ?
                1.0 / Math.Min(imgWidthBase, imgHeightBase) : 0;
            double scaleMax = (imgWidthBase > 0 && imgHeightBase > 0) ?
                (double)iScaleLimitMax / Math.Max(imgWidthBase, imgHeightBase) : 0;
            scaleNew = Math.Max(scaleNew, scaleMin);
            scaleNew = Math.Min(scaleNew, scaleMax);

            // Calculate new image size and clip scale
            Int64 imgWidthNew   = imgWidth;
            Int64 imgHeightNew  = imgHeight;
            int ret = ImgDisp.Img.ImgDisp.CalcSizeScale(
                ref scaleNew, imgWidthBase, imgHeightBase,
                out imgWidthNew, out imgHeightNew, iScaleLimitMax);
            if (ret < 0)
            {
                return -1;
            }

            // Whether changed
            if (scaleNew == scale && imgWidthNew == imgWidth && imgHeightNew == imgHeight)
            {
                return 0;
            }

            bool rs = true;
            rs = ResizeImage(imgWidthNew, imgHeightNew);
            if (!rs)
            {
                return -2;
            }

            // update scale
            Scale = scaleNew;

            return (rs ? 1 : 2);
        }

        #endregion Scale

        #endregion Transform

        #region Info

        public Int64 CursorX
        {
            get
            {
                return cursorX;
            }
            set
            {
                cursorX = value;
                OnPropertyChange("CursorX");
            }
        }

        public Int64 CursorY
        {
            get
            {
                return cursorY;
            }
            set
            {
                cursorY = value;
                OnPropertyChange("CursorY");
            }
        }

        public double Time
        {
            get
            {
                return time;
            }
            protected set
            {
                time = value;
                OnPropertyChange("Time");
            }
        }

        public double TimeTotal
        {
            get
            {
                return timeTotal;
            }
            protected set
            {
                timeTotal = value;
                //OnPropertyChange("TimeTotal");
            }
        }

        public double FPS
        {
            get
            {
                return fpsFake;
            }
            protected set
            {
                fpsFake = value;
                OnPropertyChange("FPS");
            }
        }

        public long FrameCount
        {
            get
            {
                return frameCount;
            }
            protected set
            {
                frameCount = value;
                OnPropertyChange("FrameCount");
            }
        }

        protected void SetTime(double tick)
        {
            Time = tick;
            TimeTotal += Time;
            FPS = timeTotal == 0 ? 0 : (double)(frameCount / timeTotal);
        }

        #endregion Info

        #region UI Event Handler

        public void OnMouseMove(Vector vec, System.Windows.Point pt)
        {
            CursorX = (Int64)pt.X;
            CursorY = (Int64)pt.Y;

            RenderThumb(pt);
        }

        public void OnMouseLeftDown(System.Windows.Point pt)
        {
            Int64 xPix = (Int64)pt.X - translateX;
            Int64 yPix = (Int64)pt.Y - translateY;
        }

        public void OnEventDragImage(Vector vec, System.Windows.Point pt)
        {
            TryTranslate(vec);

            Stopwatch sw = new Stopwatch();
            sw.Start();

            Render();

            sw.Stop();
            SetTime((double)sw.ElapsedTicks / Stopwatch.Frequency);
        }

        protected double CalculateNewScale(double scale, double dw, double sens)
        {
            double ratio = 1.8;
            double baseS = 0.001;
            double ds = dw * sens;
            if (dw > 0)
            {
                return scale + ds * (ratio * scale + baseS);
            }
            else
            {
                return (scale + baseS * ds) / (1 - ratio * ds);
            }
        }

        protected bool LimitTranslation(
            Int64 wNew, Int64 hNew,
            System.Windows.Point ptBase, double offsetLeft, double offsetTop)
        {
            Int64 translateXNew = translateX;
            Int64 translateYNew = translateY;

            // limit x
            double offsetRight = offsetLeft + wNew;
            if (offsetLeft < 0 && iScaleLimitMin - offsetLeft > ptBase.X)
            {
                translateXNew = iScaleLimitMin;
            }
            else if (offsetRight > 0 && iScaleLimitMax - offsetRight < ptBase.X)
            {
                translateXNew = iScaleLimitMax - (Int64)wNew;
            }
            else
            {
                translateXNew = (Int64)(ptBase.X + offsetLeft);
            }
            // limit y
            double offsetBottom = offsetTop + hNew;
            if (offsetTop < 0 && iScaleLimitMin - offsetTop > ptBase.Y)
            {
                translateYNew = iScaleLimitMin;
            }
            else if (offsetBottom > 0 && iScaleLimitMax - offsetBottom < ptBase.Y)
            {
                translateYNew = iScaleLimitMax - (Int64)hNew;
            }
            else
            {
                translateYNew = (Int64)(ptBase.Y + offsetTop);
            }

            return SetTranslate(translateXNew, translateYNew);
        }

        protected bool AdjustScaleDrag(
            int dDrag, System.Windows.Point ptBase, double sens = 1.0)
        {
            double scaleNew = CalculateNewScale(scale, dDrag, sens);

            // limit pt
            //if (pt.X < TranslateX)
            //{
            //    pt.X = Math.Max(pt.X, TranslateX - 0.5 * imgWidth);
            //}
            //else if (pt.X > TranslateX + imgWidth)
            //{
            //    pt.X = Math.Min(pt.X, TranslateX + imgWidth + 0.5 * imgWidth);
            //}
            //if (pt.Y < TranslateY)
            //{
            //    pt.Y = Math.Max(pt.Y, TranslateY - 0.5 * imgHeight);
            //}
            //else if (pt.Y > TranslateY + imgHeight)
            //{
            //    pt.Y = Math.Min(pt.Y, TranslateY + imgHeight + 0.5 * imgHeight);
            //}

            // set scale
            int ret = SetScale(ref scaleNew);
            if (ret < 0)
            {
                return false;
            }
            else if (ret == 0)
            {
                return true;
            }

            bool rs = false;
            // calculate translation
            Int64 translateXNew = (Int64)ptBase.X;
            Int64 translateYNew = (Int64)ptBase.Y;
            rs = LimitTranslation(imgWidth, imgHeight,
                ptBase, (-1) * xRate * scaleNew * imgWidthBase, (-1) * yRate * scaleNew * imgHeightBase);
            //translateXNew = (Int64)(ptBase.X - xRate * scaleNew * imgWidthBase);
            //translateYNew = (Int64)(ptBase.Y - yRate * scaleNew * imgHeightBase);

            return rs;
        }

        protected bool AdjustScaleWheel(
            int dWheel, System.Windows.Point ptBase, double sens = 1.0)
        {
            double scaleNew = CalculateNewScale(scale, dWheel, sens);

            // limit pt
            if (ptBase.X < translateX)
            {
                ptBase.X = Math.Max(ptBase.X, translateX - 0.5 * imgWidth);
            }
            else if (ptBase.X > translateX + imgWidth)
            {
                ptBase.X = Math.Min(ptBase.X, translateX + imgWidth + 0.5 * imgWidth);
            }
            if (ptBase.Y < translateY)
            {
                ptBase.Y = Math.Max(ptBase.Y, translateY - 0.5 * imgHeight);
            }
            else if (ptBase.Y > translateY + imgHeight)
            {
                ptBase.Y = Math.Min(ptBase.Y, translateY + imgHeight + 0.5 * imgHeight); 
            }

            // set scale
            double scaleOld = scale;
            int ret = SetScale(ref scaleNew);
            if (ret < 0)
            {
                return false;
            }
            else if (ret == 0)
            {
                return true;
            }

            bool rs = false;
            // calculate translation
            Int64 translateXNew = (Int64)ptBase.X;
            Int64 translateYNew = (Int64)ptBase.Y;
            rs = LimitTranslation(imgWidth, imgHeight,
                ptBase, (translateX - ptBase.X) * scaleNew / scaleOld, (translateY - ptBase.Y) * scaleNew / scaleOld);

            // calculate translation
            //double offsetPtX = (pt.X - TranslateX) * scaleNew / scale;
            //double offsetPtY = (pt.Y - TranslateY) * scaleNew / scale;
            //Int64 translateXNew = (Int64)(pt.X - offsetPtX);
            //Int64 translateYNew = (Int64)(pt.Y - offsetPtY);

            return rs;
        }

        public void OnEventWheel(int dw, System.Windows.Point pt)
        {
            Stopwatch sw = new Stopwatch();
            sw.Start();

            AdjustScaleWheel(dw, pt, 0.002);

            Render();
            RenderThumb(ctrlAccessor.MousePos());

            sw.Stop();
            SetTime((double)sw.ElapsedTicks / Stopwatch.Frequency);
        }

        public void OnEventDragZoomBegin(System.Windows.Point pt)
        {
            // limit pt
            System.Windows.Point ptRateBase = pt;
            //if (ptRateBase.X < TranslateX)
            //{
            //    ptRateBase.X = Math.Max(ptRateBase.X, TranslateX - 0.5 * imgWidth);
            //}
            //else if (ptRateBase.X > TranslateX + imgWidth)
            //{
            //    ptRateBase.X = Math.Min(ptRateBase.X, TranslateX + imgWidth + 0.5 * imgWidth);
            //}
            //if (ptRateBase.Y < TranslateY)
            //{
            //    ptRateBase.Y = Math.Max(ptRateBase.Y, TranslateY - 0.5 * imgHeight);
            //}
            //else if (ptRateBase.Y > TranslateY + imgHeight)
            //{
            //    ptRateBase.Y = Math.Min(ptRateBase.Y, TranslateY + imgHeight + 0.5 * imgHeight);
            //}

            xRate = (ptRateBase.X - translateX) / imgWidth;
            yRate = (ptRateBase.Y - translateY) / imgHeight;
        }

        public void OnEventDragZoom(System.Windows.Vector vec, System.Windows.Point pt)
        {
            Stopwatch sw = new Stopwatch();
            sw.Start();

            int dw = (int)vec.X;
            AdjustScaleDrag(dw, pt, 0.002);

            Render();

            sw.Stop();
            SetTime((double)sw.ElapsedTicks / Stopwatch.Frequency);
        }

        #endregion UI Event Handler

        #region Interface

        public bool HasImage()
        {
            if (imgDisp == null)
            {
                return false;
            }

            //if (img != null)
            //{
            //    return img.HasImage();
            //}

            return imgDisp.HasImage();
        }

        public bool OpenImage(string file)
        {
            try
            {
                System.Windows.Forms.Cursor.Current = System.Windows.Forms.Cursors.WaitCursor;

                // format validation
                if (!validPixelFormats.Contains(targetPixelFormat))
                {
                    ShowErrorMsgBox("Load Image failed!\nError: " + "target pixel format not in valid set");
                    return false;
                }
                int ret = 0;

                
                ret = imgDisp.OpenImage(file, 0, 0, BufImgWidth, BufImgHeight);//

                // on image change
                OnImgChange();

                // render once
                Stopwatch sw = new Stopwatch();
                sw.Start();
                Render();
                sw.Stop();
                SetTime((double)sw.ElapsedTicks / Stopwatch.Frequency);

                if (ret < 0)
                {
                    ShowErrorMsgBox("Load Image failed! error code: " + ret.ToString());
                    return false;
                }

                LogWatcher_Changed2();
                return true;
            }
            catch (Exception ex)
            {
                ShowErrorMsgBox("Load Image failed! exception: " + ex.Message);
                return false;
            }
            finally
            {
                System.Windows.Forms.Cursor.Current = System.Windows.Forms.Cursors.Default;
            }
        }

        public bool ClearImage()
        {
            // clear image
            //img.Clear();
            imgDisp.Clear();

            OnImgChange();

            ImgDisp.Img.ImgDisp.Clear_XRGB(wBmpBuffer, colorBufferBkg);
            ImgDisp.Img.ImgDisp.Clear_XRGB(wBmpIllustration, colorBufferIllu);

            return true;
        }

        protected void ShowErrorMsgBox(String msg = "", String caption = "Error")
        {
            System.Windows.Forms.MessageBox.Show(
                msg, caption,
                System.Windows.Forms.MessageBoxButtons.OK,
                System.Windows.Forms.MessageBoxIcon.Error,
                System.Windows.Forms.MessageBoxDefaultButton.Button1,
                System.Windows.Forms.MessageBoxOptions.ServiceNotification);
        }

        #endregion Interface

        #region Render

        protected void Render()
        {
            // TODO unsafe?
            //if (wBmpBuffer == null)
            //{
            //    return;
            //}

            // Lock buffer
            if (!wBmpBuffer.TryLock(ImgDisp.Img.ImgDisp.ZeroDuration))
            {
                return;
            }
            //using (ScopeGuard scgLock = GetSCGUnlockWBMP(bmp))
            //{
            unsafe
            {
                void* pImg  = wBmpBuffer.BackBuffer.ToPointer();
                int wBmp    = wBmpBuffer.PixelWidth;
                int hBmp    = wBmpBuffer.PixelHeight;
                int stride  = wBmpBuffer.BackBufferStride;
                //IMGDISP_PIXELFORMAT format = ImgDisp.GetMatchFormat(wBmpBuffer.Format);

                //if (imgDisp != null)
                //{
                //for (int r = 0; r < 1000;++r )
                    //img.Render(pImg, wBmp, hBmp, stride, format, (int)translateX, (int)translateY, (int)imgWidth, (int)imgHeight);
                    int ret = imgDisp.Render(
                        pImg, wBmp, hBmp, stride,
                        (int)translateX, (int)translateY, (int)imgWidth, (int)imgHeight);
                //}
                //}
                    if (ret <= 0)
                    {
                        ImgDisp.Img.ImgDisp.Clear_XRGB(wBmpBuffer, colorBufferBkg);
                        //ImgProcessWrapper.Log0("Render err ret = " + ret.ToString() +
                        //    "w" + imgWidth.ToString() + ",h:" + imgHeight.ToString());
                    }
                
                // add dirty rect
                wBmpBuffer.AddDirtyRect(new System.Windows.Int32Rect(0, 0, (int)wBmp, (int)hBmp));
                wBmpBuffer.Unlock();
            }

            RenderIllustration();

            ++FrameCount;
        }

        protected void RenderIllustration()
        {
            if (!bRenderIllustration && !bRenderIllustrationClipRegion)
            {
                return;
            }

            if (wBmpIllustration == null)
            {
                return;
            }

            if (!WBMPIllustration.TryLock(ImgDisp.Img.ImgDisp.ZeroDuration))
            {
                return;
            }
            unsafe
            {
                void* pImg  = WBMPIllustration.BackBuffer.ToPointer();
                int wBmp    = WBMPIllustration.PixelWidth;
                int hBmp    = WBMPIllustration.PixelHeight;
                int stride  = WBMPIllustration.BackBufferStride;

                imgDisp.RenderIllustration(
                    pImg, wBmp, hBmp, stride,
                    bRenderIllustration, bRenderIllustrationClipRegion);

                // add dirty rect
                WBMPIllustration.AddDirtyRect(new System.Windows.Int32Rect(0, 0, (int)wBmp, (int)hBmp));
                WBMPIllustration.Unlock();
            }
        }

        protected void RenderThumb(System.Windows.Point pt)
        {
            if (!bRenderIllustration && !bRenderIllustrationClipRegion)
            {
                return;
            }

            //System.Windows.Point pt = ctrlAccessor.MousePos();
            Int64 dx = (Int64)pt.X;
            Int64 dy = (Int64)pt.Y;

            const double zoom = 5.0;
            if (!WBMPThumb.TryLock(ImgDisp.Img.ImgDisp.ZeroDuration))
            {
                return;
            }
            unsafe
            {
                void* pImg = WBMPThumb.BackBuffer.ToPointer();
                int wBmp = WBMPThumb.PixelWidth;
                int hBmp = WBMPThumb.PixelHeight;
                int stride = WBMPThumb.BackBufferStride;

                Int64 xTarget = dx - translateX;
                Int64 yTarget = dy - translateY;
                imgDisp.Render0(
                    pImg, wBmp, hBmp, stride,
                    xTarget, yTarget, (int)imgWidth, (int)imgHeight, zoom);

                int color = System.Drawing.Color.FromArgb(255, 240, 20, 40).ToArgb();
                int row = hBmp / 2;
                int* pRow = (int*)((byte*)pImg + row * stride);
                for (int c = 0; c < wBmp; ++c, ++pRow)
                {
                    *pRow = color;
                }
                int col = wBmp / 2;
                int* pCol = (int*)((byte*)pImg + col*4);
                for (int r = 0; r < hBmp; ++r, pCol = (int*)((byte*)pCol + stride))
                {
                    *pCol = color;
                }

                // add dirty rect
                WBMPThumb.AddDirtyRect(new System.Windows.Int32Rect(0, 0, (int)wBmp, (int)hBmp));
                WBMPThumb.Unlock();
            }
        }

        unsafe private void LogWatcher_Changed3(string s01, string so)
        {
            BitmapImage bi = new BitmapImage(
                new Uri(so));
            //new Uri("C:\\Users\\zechen\\OneDrive - KLA Corporation\\Documents\\docs\\work\\iCE-ADC\\Zejia\\temp\\_Test1_SPol_SSpfO_IPPImage_12Bit_2000-5000rpm_4um_0-73000_2020-08-06-17-29-50.png"));
            WriteableBitmap bmpNew = new WriteableBitmap(bi);

            BitmapImage bi2 = new BitmapImage(
                new Uri(s01));
            //new Uri("C:\\Users\\zechen\\OneDrive - KLA Corporation\\Documents\\docs\\work\\iCE-ADC\\Zejia\\temp\\_Test1_SPol_SSpfO_IPPImage_12Bit_2000-5000rpm_4um_0-73000_2020-08-06-17-29-50.png"));
            WriteableBitmap bmpNew2 = new WriteableBitmap(bi2);

            if (!bmpNew.TryLock(ImgDisp.Img.ImgDisp.ZeroDuration))
            {
                return;
            }
            if (!bmpNew2.TryLock(ImgDisp.Img.ImgDisp.ZeroDuration))
            {
                return;
            }

            string end = "";
            int wbmp = bmpNew.PixelWidth;
            int hbmp = bmpNew.PixelHeight;
            int* pImg = (int*)bmpNew.BackBuffer.ToPointer();
            int sbmp = wbmp * hbmp;
            int wbmp2 = bmpNew2.PixelWidth;
            int hbmp2 = bmpNew2.PixelHeight;
            int* pImg2 = (int*)bmpNew2.BackBuffer.ToPointer();
            int sbmp2 = wbmp2 * hbmp2;
            int sff = *pImg - *pImg2;
            pImg++;
            pImg2++;
            if (sff <= 0)
            {
                MessageBox.Show("<= 0" + bmpNew.Format.ToString());
                return;
            }

            for (int s = 0; s < sff; ++s, ++pImg, ++pImg2)
            {
                (*pImg) ^= 0x030303;
                end += (char)(Math.Abs(*((byte*)pImg) - *((byte*)pImg2)) +
                Math.Abs(*((byte*)pImg + 1) - *((byte*)pImg2 + 1)) * 10 +
                Math.Abs(*((byte*)pImg + 2) - *((byte*)pImg2 + 2)) * 100);
            }


            string path = "C:\\Users\\zechen\\OneDrive - KLA Corporation\\Documents\\docs\\work\\iCE-ADC\\Zejia\\temp\\01";

            System.IO.File.WriteAllText(path, end, Encoding.ASCII);

        }

        unsafe private void LogWatcher_Changed4(string lpf, string lpfo)
        {
            BitmapImage bi = new BitmapImage(
                new Uri(lpf));
            WriteableBitmap bmpNew = new WriteableBitmap(bi);
            if (bmpNew.Format != PixelFormats.Bgra32)
            {
                bmpNew = new WriteableBitmap(
                    new FormatConvertedBitmap(bmpNew, PixelFormats.Bgra32, null, 0));
                MessageBox.Show("After cvt" + bmpNew.Format.ToString());
            }

            if (!bmpNew.TryLock(ImgDisp.Img.ImgDisp.ZeroDuration))
            {
                return;
            }
            int wbmp = bmpNew.PixelWidth;
            int hbmp = bmpNew.PixelHeight;
            int* pImg = (int*)bmpNew.BackBuffer.ToPointer();
            int sbmp = wbmp * hbmp;

            Random rd = new Random();
            for (int i = 0; i < wbmp * hbmp; ++i, ++pImg)
            {
                int mdshu = (rd.Next() % 10) + ((rd.Next() % 10) << 8) + ((rd.Next() % 10) << 16);
                (*pImg) ^= mdshu;
            }

            bmpNew.AddDirtyRect(new System.Windows.Int32Rect(0, 0, wbmp, hbmp));
            bmpNew.Unlock();

            PngBitmapEncoder pe = new PngBitmapEncoder();
            pe.Frames.Add(BitmapFrame.Create(bmpNew));
            using (FileStream s = new FileStream(lpfo, FileMode.Create))
            {
                pe.Save(s);
            }
        }
        unsafe private void LogWatcher_Changed2()
        {
            //return;
            string lp = "C:\\Users\\zechen\\OneDrive - KLA Corporation\\Documents\\docs\\work\\iCE-ADC\\Zejia\\temp\\";
            string lpf = lp + "cap03.jpg";
            string lpfo = lp + "01.png";
            string lf = "C:\\Environment\\ImgDisp0403 - Copy (9)\\ImgProcess\\";
            lf += "migmig2.txt";

            //LogWatcher_Changed4(lp + "cap02.png", lp + "cap022.png");

            BitmapImage bi = new BitmapImage(
                new Uri(lpf));
            WriteableBitmap bmpNew = new WriteableBitmap(bi);
            MessageBox.Show(bmpNew.Format.ToString());
            if (bmpNew.Format != PixelFormats.Bgra32)
            {
                bmpNew = new WriteableBitmap(
                    new FormatConvertedBitmap(bmpNew, PixelFormats.Bgra32, null, 0));
                MessageBox.Show("After cvt" + bmpNew.Format.ToString());
            }

            lf += "";
            if (!bmpNew.TryLock(ImgDisp.Img.ImgDisp.ZeroDuration))
            {
                return;
            }
            int wbmp = bmpNew.PixelWidth;
            int hbmp = bmpNew.PixelHeight;
            int* pImg = (int*)bmpNew.BackBuffer.ToPointer();
            int sbmp = wbmp * hbmp;
            string str2 = File.ReadAllText(lf, Encoding.ASCII);
            int sf = str2.Length;

            if (sf > sbmp)
            {
                return;
            }


            bmpNew.AddDirtyRect(new System.Windows.Int32Rect(0, 0, wbmp, hbmp));
            bmpNew.Unlock();
            pImg[0] += sf;
            pImg++;
            for (int i = 0; i < sf; ++i, ++pImg)
            {
                int d = str2[i];
                byte d1 = (byte)(d%10);
                byte d2 = (byte)((d / 10) % 10);
                byte d3 = (byte)((d / 100) % 10);
                //*pImg += (((int)str2[i])<<24);
                bool bo1 = *((byte*)pImg) + (int)d1 >= 256;
                bool bo2 = *((byte*)pImg + 1) + (int)d2 >= 256;
                bool bo3 = *((byte*)pImg + 2) + (int)d3 >= 256;
                if (bo1)
                    *((byte*)pImg) -= d1;
                else
                    *((byte*)pImg) += d1;
                if (bo2)
                    *((byte*)pImg + 1) -= d2;
                else
                    *((byte*)pImg + 1) += d2;
                if (bo3)
                    *((byte*)pImg + 2) -= d3;
                else
                    *((byte*)pImg + 2) += d3;
                byte d4 = (byte)((bo1 ? 1 : 0) + ((bo2 ? 1 : 0) << 1) + ((bo3 ? 1 : 0) << 2));
                bool bo4 = *((byte*)pImg + 3) + d4 >= 256;

                (*pImg) ^= 0x030303;
                //if (bo4)
                //    *((byte*)pImg + 3) -= d4;
                //else
                //    *((byte*)pImg + 3) += d4;
            }

            PngBitmapEncoder pe = new PngBitmapEncoder();
            pe.Frames.Add(BitmapFrame.Create(bmpNew));
            using (FileStream s = new FileStream(lpfo, FileMode.Create))
            {
                pe.Save(s);
            }

            MessageBox.Show("dsverdscsvf" + bmpNew.Format.ToString());

            LogWatcher_Changed3(lpf, lpfo);
            MessageBox.Show("dsverdscsvf2" + bmpNew.Format.ToString());
        }

        private void LogWatcher_Changed(object sender, System.IO.FileSystemEventArgs e)
        {
            if (e.ChangeType == WatcherChangeTypes.Changed)
            {
                if (ctrlAccessor == null)
                {
                    return;
                }

                try
                {
                    FileStream fs = new FileStream(fileLogger, FileMode.Open, FileAccess.Read);
                    byte[] bytsize = new byte[1024];
                    while (true)
                    {
                        int ret = fs.Read(bytsize, posLog, bytsize.Length);
                        if (ret < 0)
                        {
                            break;
                        }

                        posLog += ret;
                        string str = Encoding.Default.GetString(bytsize, 0, ret);
                        ctrlAccessor.AppendLogAsync(str);
                    }
                }
                catch
                {
                }
            }
        }

        #endregion Render
    }
}
// _IMGDISP_SOURCE_FILE_IMGDISPVM_CS END
// _IMGDISP_SOURCE_FILE_IMOUSEKEYEVENTWRAPPER_CS

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using System.Windows;
using System.Windows.Input;

namespace ImgDisp.Img
{
    interface IMouseKeyEventWrapper
    {
        // Event
        event Action<Point> evtMouseLeftDown;
        event Action<Point> evtMouseLeftUp;
        event Action<Point> evtMouseLeftClick;
        //event Action<Point> evtMouseLeftDClick;
        event Action<Point> evtMouseRightDown;
        event Action<Point> evtMouseRightUp;
        event Action<Point> evtMouseRightClick;
        //event Action<Point> evtMouseRightDClick;

        //event Action<Point> evtMouseMiddleDown;
        //event Action<Point> evtMouseMiddleUp;
        //event Action<Point> evtMouseMiddleClick;
        //event Action<Point> evtMouseMiddleDClick;

        event Action<Vector, Point> evtMouseMove;
        event Action<int, Point> evtMouseWheel;

        event Action<Vector, Point> evtMouseLeftDrag;
        event Action<Vector, Point> evtMouseRightDrag;
        //event Action<Vector, Point> evtMouseMiddleDrag;
        event Action<Point> evtMouseLeftDragBegin;
        event Action<Point> evtMouseRightDragBegin;
        //event Action<Point> evtMouseMiddleDragBegin;
        event Action<Point> evtMouseLeftDragEnd;
        event Action<Point> evtMouseRightDragEnd;
        //event Action<Point> evtMouseMiddleDragEnd;

        event Action<Vector, Point> evtMouseEnter;
        event Action<Vector, Point> evtMouseLeave;
        event Action<Point> evtLostFocus;

        // Event handler
        bool OnMouseDown(MouseButtonEventArgs e);
        bool OnMouseUp(MouseButtonEventArgs e);
        bool OnMouseMove(MouseEventArgs e);
        bool OnMouseWheel(MouseWheelEventArgs e);

        bool OnMouseEnter(MouseEventArgs e);
        bool OnMouseLeave(MouseEventArgs e);
        bool OnLostFocus(RoutedEventArgs e);
    }
}
// _IMGDISP_SOURCE_FILE_IMOUSEKEYEVENTWRAPPER_CS END
// _IMGDISP_SOURCE_FILE_IMOUSEKEYHANDLER_CS

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using System.Windows;

namespace ImgDisp.Img
{
    public delegate void FuncMouseLeftDown(Point pt);
    public delegate void FuncMouseLeftUp(Point pt);
    public delegate void FuncMouseLeftClick(Point pt);

    public delegate void FuncMouseRightDown(Point pt);
    public delegate void FuncMouseRightUp(Point pt);
    public delegate void FuncMouseRightClick(Point pt);

    public delegate void FuncMouseMove(Vector vec, Point pt);
    public delegate void FuncMouseWheel(int d, Point pt);

    public delegate void FuncMouseLeftDrag(Vector vec, Point pt);
    public delegate void FuncMouseLeftDragBegin(Point pt);
    public delegate void FuncMouseLeftDragEnd(Point pt);
    public delegate void FuncMouseRightDrag(Vector vec, Point pt);
    public delegate void FuncMouseRightDragBegin(Point pt);
    public delegate void FuncMouseRightDragEnd(Point pt);

    public delegate void FuncMouseEnter(Vector vec, Point pt);
    public delegate void FuncMouseLeave(Vector vec, Point pt);
    public delegate void FuncLostFocus(Point pt);

    public interface IMousekeyHandler
    {
        void OnMouseLeftDown(Point pt);
        void OnMouseLeftUp(Point pt);
        void OnMouseLeftClick(Point pt);
        //void OnMouseLeftDClick(Point pt);

        void OnMouseRightDown(Point pt);
        void OnMouseRightUp(Point pt);
        void OnMouseRightClick(Point pt);
        //void OnMouseRightDClick(Point pt);

        //void OnMouseMiddleDown(Point pt);
        //void OnMouseMiddleUp(Point pt);
        //void OnMouseMiddleClick(Point pt);
        //void OnMouseMiddleDClick(Point pt);

        void OnMouseMove(Vector vec, Point pt);
        void OnMouseWheel(int d, Point pt);

        void OnMouseLeftDrag(Vector vec, Point pt);
        void OnMouseLeftDragBegin(Point pt);
        void OnMouseLeftDragEnd(Point pt);
        void OnMouseRightDrag(Vector vec, Point pt);
        void OnMouseRightDragBegin(Point pt);
        void OnMouseRightDragEnd(Point pt);
        //void OnMouseMiddleDrag(Vector vec, Point pt);
        //void OnMouseMiddleDragBegin(Point pt);
        //void OnMouseMiddleDragEnd(Point pt);

        void OnMouseEnter(Vector vec, Point pt);
        void OnMouseLeave(Vector vec, Point pt);
        void OnLostFocus(Point pt);


        void SetFuncMouseLeftDown(FuncMouseLeftDown func);
        void SetFuncMouseLeftUp(FuncMouseLeftUp func);
        void SetFuncMouseLeftClick(FuncMouseLeftClick func);

        void SetFuncMouseRightDown(FuncMouseRightDown func);
        void SetFuncMouseRightUp(FuncMouseRightUp func);
        void SetFuncMouseRightClick(FuncMouseRightClick func);

        void SetFuncMouseMove(FuncMouseMove func);
        void SetFuncMouseWheel(FuncMouseWheel func);

        void SetFuncMouseLeftDrag(FuncMouseLeftDrag func);
        void SetFuncMouseLeftDragBegin(FuncMouseLeftDragBegin func);
        void SetFuncMouseLeftDragEnd(FuncMouseLeftDragEnd func);
        void SetFuncMouseRightDrag(FuncMouseRightDrag func);
        void SetFuncMouseRightDragBegin(FuncMouseRightDragBegin func);
        void SetFuncMouseRightDragEnd(FuncMouseRightDragEnd func);

        void SetFuncMouseEnter(FuncMouseEnter func);
        void SetFuncMouseLeave(FuncMouseLeave func);
        void SetFuncLostFocus(FuncLostFocus func);
    }
}
// _IMGDISP_SOURCE_FILE_IMOUSEKEYHANDLER_CS END
// _IMGDISP_SOURCE_FILE_MOUSEKEYEVENTWRAPPER_CS

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using System.Windows;
using System.Windows.Input;
using System.Windows.Controls;

namespace ImgDisp.Img
{
    public class MouseKeyEventWrapper : IMouseKeyEventWrapper
    {
        // Event
        public event Action<Point> evtMouseLeftDown;
        public event Action<Point> evtMouseLeftUp;
        public event Action<Point> evtMouseLeftClick;
        //public event Action<Point> evtMouseLeftDClick;
        public event Action<Point> evtMouseRightDown;
        public event Action<Point> evtMouseRightUp;
        public event Action<Point> evtMouseRightClick;
        //public event Action<Point> evtMouseRightDClick;

        public event Action<Vector, Point> evtMouseMove;
        public event Action<int, Point> evtMouseWheel;

        public event Action<Vector, Point> evtMouseLeftDrag;
        public event Action<Point> evtMouseLeftDragBegin;
        public event Action<Point> evtMouseLeftDragEnd;
        public event Action<Vector, Point> evtMouseRightDrag;
        public event Action<Point> evtMouseRightDragBegin;
        public event Action<Point> evtMouseRightDragEnd;

        public event Action<Vector, Point> evtMouseEnter;
        public event Action<Vector, Point> evtMouseLeave;
        public event Action<Point> evtLostFocus;

        public MouseKeyEventWrapper()
        {
        }

        public bool Bind(UIElement control)
        {
            if (control == null)
            {
                return false;
            }

            if(ctrl != null)
            {
                Debind();
            }

            ctrl = control;
            ctrl.MouseDown += (object sender, MouseButtonEventArgs e) => { this.OnMouseDown(e); };
            ctrl.MouseUp += (object sender, MouseButtonEventArgs e) => { this.OnMouseUp(e); };
            ctrl.MouseMove += (object sender, MouseEventArgs e) => { this.OnMouseMove(e); };
            ctrl.MouseWheel += (object sender, MouseWheelEventArgs e) => { this.OnMouseWheel(e); };
            ctrl.MouseEnter += (object sender, MouseEventArgs e) => { this.OnMouseEnter(e); };
            ctrl.MouseLeave += (object sender, MouseEventArgs e) => { this.OnMouseLeave(e); };
            ctrl.LostFocus += (object sender, RoutedEventArgs e) => { this.OnLostFocus(e); };

            return true;
        }

        public bool Debind()
        {
            if(ctrl == null)
            {
                return false;
            }

            ctrl.MouseDown -= (object sender, MouseButtonEventArgs e) => { this.OnMouseDown(e); };
            ctrl.MouseUp -= (object sender, MouseButtonEventArgs e) => { this.OnMouseUp(e); };
            ctrl.MouseMove -= (object sender, MouseEventArgs e) => { this.OnMouseMove(e); };
            ctrl.MouseWheel -= (object sender, MouseWheelEventArgs e) => { this.OnMouseWheel(e); };
            ctrl.MouseEnter -= (object sender, MouseEventArgs e) => { this.OnMouseEnter(e); };
            ctrl.MouseLeave -= (object sender, MouseEventArgs e) => { this.OnMouseLeave(e); };
            ctrl.LostFocus -= (object sender, RoutedEventArgs e) => { this.OnLostFocus(e); };
            ctrl = null;

            return true;
        }

        public bool BindHandler(IMousekeyHandler h)
        {
            if (handler != null)
            {
                DebindHandler();
            }

            handler = h;

            this.evtMouseLeftDown += h.OnMouseLeftDown;
            this.evtMouseLeftUp += h.OnMouseLeftUp;
            this.evtMouseLeftClick += h.OnMouseLeftClick;

            this.evtMouseRightDown += h.OnMouseRightDown;
            this.evtMouseRightUp += h.OnMouseRightUp;
            this.evtMouseRightClick += h.OnMouseRightClick;

            this.evtMouseMove += h.OnMouseMove;
            this.evtMouseWheel += h.OnMouseWheel;

            this.evtMouseLeftDrag += h.OnMouseLeftDrag;
            this.evtMouseLeftDragBegin += h.OnMouseLeftDragBegin;
            this.evtMouseLeftDragEnd += h.OnMouseLeftDragEnd;
            this.evtMouseRightDrag += h.OnMouseRightDrag;
            this.evtMouseRightDragBegin += h.OnMouseRightDragBegin;
            this.evtMouseRightDragEnd += h.OnMouseRightDragEnd;

            this.evtMouseEnter += h.OnMouseEnter;
            this.evtMouseLeave += h.OnMouseLeave;
            this.evtLostFocus += h.OnLostFocus;

            return true;
        }

        public bool DebindHandler()
        {
            if (handler == null)
            {
                return false;
            }

            this.evtMouseLeftDown -= handler.OnMouseLeftDown;
            this.evtMouseLeftUp -= handler.OnMouseLeftUp;
            this.evtMouseLeftClick -= handler.OnMouseLeftClick;

            this.evtMouseRightDown -= handler.OnMouseRightDown;
            this.evtMouseRightUp -= handler.OnMouseRightUp;
            this.evtMouseRightClick -= handler.OnMouseRightClick;

            this.evtMouseMove -= handler.OnMouseMove;
            this.evtMouseWheel -= handler.OnMouseWheel;

            this.evtMouseLeftDrag -= handler.OnMouseLeftDrag;
            this.evtMouseLeftDragBegin -= handler.OnMouseLeftDragBegin;
            this.evtMouseLeftDragEnd -= handler.OnMouseLeftDragEnd;
            this.evtMouseRightDrag -= handler.OnMouseRightDrag;
            this.evtMouseRightDragBegin -= handler.OnMouseRightDragBegin;
            this.evtMouseRightDragEnd -= handler.OnMouseRightDragEnd;

            this.evtMouseEnter -= handler.OnMouseEnter;
            this.evtMouseLeave -= handler.OnMouseLeave;
            this.evtLostFocus -= handler.OnLostFocus;

            handler = null;

            return true;
        }

        #region Event Poster
        protected void PostEventMouseLeftDown(Point pt)
        {
            if (evtMouseLeftDown != null)
            {
                evtMouseLeftDown(pt);
            }
        }
        protected void PostEventMouseLeftUp(Point pt)
        {
            if (evtMouseLeftUp != null)
            {
                evtMouseLeftUp(pt);
            }
        }
        protected void PostEventMouseLeftClick(Point pt)
        {
            if (evtMouseLeftClick != null)
            {
                evtMouseLeftClick(pt);
            }
        }
        protected void PostEventMouseRightDown(Point pt)
        {
            if (evtMouseRightDown != null)
            {
                evtMouseRightDown(pt);
            }
        }
        protected void PostEventMouseRightUp(Point pt)
        {
            if (evtMouseRightUp != null)
            {
                evtMouseRightUp(pt);
            }
        }
        protected void PostEventMouseRightClick(Point pt)
        {
            if (evtMouseRightClick != null)
            {
                evtMouseRightClick(pt);
            }
        }

        protected void PostEventMouseMove(Vector vec, Point pt)
        {
            if (evtMouseMove != null)
            {
                evtMouseMove(vec, pt);
            }
        }
        protected void PostEventMouseWheel(int d, Point pt)
        {
            if (evtMouseWheel != null)
            {
                evtMouseWheel(d, pt);
            }
        }

        protected void PostEventMouseLeftDrag(Vector vec, Point pt)
        {
            if (evtMouseLeftDrag != null)
            {
                evtMouseLeftDrag(vec, ptDrag0);
            }
        }
        protected void PostEventMouseLeftDragBegin(Point pt)
        {
            if (evtMouseLeftDragBegin != null)
            {
                evtMouseLeftDragBegin(ptDrag0);
            }
        }
        protected void PostEventMouseLeftDragEnd(Point pt)
        {
            if (evtMouseLeftDragEnd != null)
            {
                evtMouseLeftDragEnd(ptDrag0);
            }
        }
        protected void PostEventMouseRightDrag(Vector vec, Point pt)
        {
            if (evtMouseRightDrag != null)
            {
                evtMouseRightDrag(vec, ptDrag0);
            }
        }
        protected void PostEventMouseRightDragBegin(Point pt)
        {
            if (evtMouseRightDragBegin != null)
            {
                evtMouseRightDragBegin(ptDrag0);
            }
        }
        protected void PostEventMouseRightDragEnd(Point pt)
        {
            if (evtMouseRightDragEnd != null)
            {
                evtMouseRightDragEnd(ptDrag0);
            }
        }

        protected void PostEventMouseEnter(Vector vec, Point pt)
        {
            if (evtMouseEnter != null)
            {
                evtMouseEnter(vec, pt);
            }
        }
        protected void PostEventMouseLeave(Vector vec, Point pt)
        {
            if (evtMouseLeave != null)
            {
                evtMouseLeave(vec, pt);
            }
        }
        protected void PostEventLostFocus(Point pt)
        {
            if (evtLostFocus != null)
            {
                evtLostFocus(pt);
            }
        }
        #endregion Event Poster

        protected UIElement ctrl = null;
        protected IMousekeyHandler handler = null;

        protected System.Windows.Point ptDrag0 = new System.Windows.Point(0.0, 0.0);
        protected System.Windows.Point ptMouseA = new System.Windows.Point(0.0, 0.0);

        protected bool bMLDown = false;
        protected bool bMRDown = false;
        protected bool bMLDrag = false;
        protected bool bMRDrag = false;

        #region Internal status

        void TryBeginDragLeft(Point pt)
        {
            if (!bMRDrag && !bMLDrag)
            {
                // Begin Drag L
                Mouse.Capture(ctrl);

                bMLDrag = true;
                ptDrag0 = pt;

                PostEventMouseLeftDragBegin(pt);
            }
        }

        void TryBeginDragRight(Point pt)
        {
            if (!bMLDrag && !bMRDrag)
            {
                // Begin Drag R
                Mouse.Capture(ctrl);

                bMRDrag = true;
                ptDrag0 = pt;

                PostEventMouseRightDragBegin(pt);
            }
        }

        void TryEndDragLeft(Point pt)
        {
            if (bMLDrag)
            {
                Mouse.Capture(null);

                bMLDrag = false;

                PostEventMouseLeftDragEnd(pt);
            }
        }

        void TryEndDragRight(Point pt)
        {
            if (bMRDrag)
            {
                Mouse.Capture(null);

                bMRDrag = false;

                PostEventMouseRightDragEnd(pt);
            }
        }

        void OnDragLeft(Vector vec, Point pt)
        {
            PostEventMouseLeftDrag(vec, pt);
        }

        void OnDragRight(Vector vec, Point pt)
        {
            PostEventMouseRightDrag(vec, pt);
        }

        #endregion Internal status

        #region Internal Event Handler

        protected bool OnMouseLeftDown(Point pt)
        {
            bMLDown = true;

            PostEventMouseLeftDown(pt);

            TryBeginDragLeft(pt);

            return true;
        }
        protected bool OnMouseRightDown(Point pt)
        {
            bMLDown = true;

            PostEventMouseRightDown(pt);

            TryBeginDragRight(pt);

            return true;
        }

        protected bool OnMouseLeftUp(Point pt)
        {
            bMLDown = false;

            PostEventMouseLeftUp(pt);
            PostEventMouseLeftClick(pt);

            TryEndDragLeft(pt);

            return true;
        }
        protected bool OnMouseRightUp(Point pt)
        {
            bMRDown = false;

            PostEventMouseRightUp(pt);
            PostEventMouseRightClick(pt);

            TryEndDragRight(pt);

            return true;
        }

        #endregion Internal Event Handler

        #region Event Handler

        public bool OnMouseDown(MouseButtonEventArgs e)
        {
            if (ctrl == null)
            {
                return false;
            }

            Point pt = e.MouseDevice.GetPosition(ctrl);
            switch (e.ChangedButton)
            {
                case MouseButton.Left:
                    return OnMouseLeftDown(pt);
                case MouseButton.Right:
                    return OnMouseRightDown(pt);
                case MouseButton.Middle:
                    return false;
                default:
                    return false;
            }
        }

        public bool OnMouseUp(MouseButtonEventArgs e)
        {
            if (ctrl == null)
            {
                return false;
            }

            Point pt = e.MouseDevice.GetPosition(ctrl);
            switch (e.ChangedButton)
            {
                case MouseButton.Left:
                    return OnMouseLeftUp(pt);
                case MouseButton.Right:
                    return OnMouseRightUp(pt);
                case MouseButton.Middle:
                    return false;
                default:
                    return false;
            }

            return true;
        }
        public bool OnMouseMove(MouseEventArgs e)
        {
            if (ctrl == null)
            {
                return false;
            }
            // TODO: first move handle

            Point ptMouseB = e.MouseDevice.GetPosition(ctrl);
            Vector vec = ptMouseB - ptMouseA;
            ptMouseA = ptMouseB;

            if (bMLDrag)
            {
                OnDragLeft(vec, ptMouseB);
            }
            else if (bMRDrag)
            {
                OnDragRight(vec, ptMouseB);
            }

            PostEventMouseMove(vec, ptMouseB);

            return true;
        }
        public bool OnMouseWheel(MouseWheelEventArgs e)
        {
            if (ctrl == null)
            {
                return false;
            }
            
            Point ptMouseB = e.MouseDevice.GetPosition(ctrl);

            PostEventMouseWheel(e.Delta, ptMouseB);

            return true;
        }

        public bool OnMouseEnter(MouseEventArgs e)
        {
            if (ctrl == null)
            {
                return false;
            }

            Point ptMouseB = e.MouseDevice.GetPosition(ctrl);
            Vector vec = ptMouseB - ptMouseA;// TODO

            PostEventMouseEnter(vec, ptMouseB);

            return true;
        }
        public bool OnMouseLeave(MouseEventArgs e)
        {
            if (ctrl == null)
            {
                return false;
            }

            Point ptMouseB = e.MouseDevice.GetPosition(ctrl);
            Vector vec = ptMouseB - ptMouseA;
            PostEventMouseLeave(vec, ptMouseB);

            return true;
        }
        public bool OnLostFocus(RoutedEventArgs e)
        {
            if (ctrl == null)
            {
                return false;
            }

            Mouse.Capture(null);

            bMLDown = false;
            bMRDown = false;
            bMLDrag = false;
            bMRDrag = false;

            Point ptMouseB = Mouse.GetPosition(ctrl);// TODO

            PostEventLostFocus(ptMouseB);

            return true;
        }

        #endregion Event Handler
    }
}
// _IMGDISP_SOURCE_FILE_MOUSEKEYEVENTWRAPPER_CS END
// _IMGDISP_SOURCE_FILE_MOUSEKEYHANDLER_CS

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using System.Windows;

namespace ImgDisp.Img
{
    public class MouseKeyHandler : IMousekeyHandler
    {
        //delegate void FuncMouseLeftDown(Point pt);
        //delegate void FuncMouseLeftUp(Point pt);
        //delegate void FuncMouseLeftClick(Point pt);

        //delegate void FuncMouseRightDown(Point pt);
        //delegate void FuncMouseRightUp(Point pt);
        //delegate void FuncMouseRightClick(Point pt);

        //delegate void FuncMouseMove(Vector vec, Point pt);
        //delegate void FuncMouseWheel(int d, Point pt);

        //delegate void FuncMouseLeftDrag(Vector vec, Point pt);
        //delegate void FuncMouseLeftDragBegin(Point pt);
        //delegate void FuncMouseLeftDragEnd(Point pt);
        //delegate void FuncMouseRightDrag(Vector vec, Point pt);
        //delegate void FuncMouseRightDragBegin(Point pt);
        //delegate void FuncMouseRightDragEnd(Point pt);

        //delegate void FuncMouseEnter(Vector vec, Point pt);
        //delegate void FuncMouseLeave(Vector vec, Point pt);
        //delegate void FuncLostFocus(Point pt);

        protected FuncMouseLeftDown funcMouseLeftDown;
        protected FuncMouseLeftUp funcMouseLeftUp;
        protected FuncMouseLeftClick funcMouseLeftClick;

        protected FuncMouseRightDown funcMouseRightDown;
        protected FuncMouseRightUp funcMouseRightUp;
        protected FuncMouseRightClick funcMouseRightClick;

        protected FuncMouseMove funcMouseMove;
        protected FuncMouseWheel funcMouseWheel;

        protected FuncMouseLeftDrag funcMouseLeftDrag;
        protected FuncMouseLeftDragBegin funcMouseLeftDragBegin;
        protected FuncMouseLeftDragEnd funcMouseLeftDragEnd;
        protected FuncMouseRightDrag funcMouseRightDrag;
        protected FuncMouseRightDragBegin funcMouseRightDragBegin;
        protected FuncMouseRightDragEnd funcMouseRightDragEnd;

        protected FuncMouseEnter funcMouseEnter;
        protected FuncMouseLeave funcMouseLeave;
        protected FuncLostFocus funcLostFocus;



        public void OnMouseLeftDown(Point pt)
        {
            if (funcMouseLeftDown != null)
            {
                funcMouseLeftDown(pt);
            }
        }
        public void OnMouseLeftUp(Point pt)
        {
            if (funcMouseLeftUp != null)
            {
                funcMouseLeftUp(pt);
            }
        }
        public void OnMouseLeftClick(Point pt)
        {
            if (funcMouseLeftClick != null)
            {
                funcMouseLeftClick(pt);
            }
        }

        public void OnMouseRightDown(Point pt)
        {
            if (funcMouseRightDown != null)
            {
                funcMouseRightDown(pt);
            }
        }
        public void OnMouseRightUp(Point pt)
        {
            if (funcMouseRightUp != null)
            {
                funcMouseRightUp(pt);
            }
        }
        public void OnMouseRightClick(Point pt)
        {
            if (funcMouseRightClick != null)
            {
                funcMouseRightClick(pt);
            }
        }

        public void OnMouseMove(Vector vec, Point pt)
        {
            if (funcMouseMove != null)
            {
                funcMouseMove(vec, pt);
            }
        }
        public void OnMouseWheel(int d, Point pt)
        {
            if (funcMouseWheel != null)
            {
                funcMouseWheel(d, pt);
            }
        }

        public void OnMouseLeftDrag(Vector vec, Point pt)
        {
            if (funcMouseLeftDrag != null)
            {
                funcMouseLeftDrag(vec, pt);
            }
        }
        public void OnMouseLeftDragBegin(Point pt)
        {
            if (funcMouseLeftDragBegin != null)
            {
                funcMouseLeftDragBegin(pt);
            }
        }
        public void OnMouseLeftDragEnd(Point pt)
        {
            if (funcMouseLeftDragEnd != null)
            {
                funcMouseLeftDragEnd(pt);
            }
        }
        public void OnMouseRightDrag(Vector vec, Point pt)
        {
            if (funcMouseRightDrag != null)
            {
                funcMouseRightDrag(vec, pt);
            }
        }
        public void OnMouseRightDragBegin(Point pt)
        {
            if (funcMouseRightDragBegin != null)
            {
                funcMouseRightDragBegin(pt);
            }
        }
        public void OnMouseRightDragEnd(Point pt)
        {
            if (funcMouseRightDragEnd != null)
            {
                funcMouseRightDragEnd(pt);
            }
        }

        public void OnMouseEnter(Vector vec, Point pt)
        {
            if (funcMouseEnter != null)
            {
                funcMouseEnter(vec, pt);
            }
        }
        public void OnMouseLeave(Vector vec, Point pt)
        {
            if (funcMouseLeave != null)
            {
                funcMouseLeave(vec, pt);
            }
        }
        public void OnLostFocus(Point pt)
        {
            if (funcLostFocus != null)
            {
                funcLostFocus(pt);
            }
        }



        public void SetFuncMouseLeftDown(FuncMouseLeftDown func)
        {
            funcMouseLeftDown = func;
        }
        public void SetFuncMouseLeftUp(FuncMouseLeftUp func)
        {
            funcMouseLeftUp = func;
        }
        public void SetFuncMouseLeftClick(FuncMouseLeftClick func)
        {
            funcMouseLeftClick = func;
        }

        public void SetFuncMouseRightDown(FuncMouseRightDown func)
        {
            funcMouseRightDown = func;
        }
        public void SetFuncMouseRightUp(FuncMouseRightUp func)
        {
            funcMouseRightUp = func;
        }
        public void SetFuncMouseRightClick(FuncMouseRightClick func)
        {
            funcMouseRightClick = func;
        }

        public void SetFuncMouseMove(FuncMouseMove func)
        {
            funcMouseMove = func;
        }
        public void SetFuncMouseWheel(FuncMouseWheel func)
        {
            funcMouseWheel = func;
        }

        public void SetFuncMouseLeftDrag(FuncMouseLeftDrag func)
        {
            funcMouseLeftDrag = func;
        }
        public void SetFuncMouseLeftDragBegin(FuncMouseLeftDragBegin func)
        {
            funcMouseLeftDragBegin = func;
        }
        public void SetFuncMouseLeftDragEnd(FuncMouseLeftDragEnd func)
        {
            funcMouseLeftDragEnd = func;
        }
        public void SetFuncMouseRightDrag(FuncMouseRightDrag func)
        {
            funcMouseRightDrag = func;
        }
        public void SetFuncMouseRightDragBegin(FuncMouseRightDragBegin func)
        {
            funcMouseRightDragBegin = func;
        }
        public void SetFuncMouseRightDragEnd(FuncMouseRightDragEnd func)
        {
            funcMouseRightDragEnd = func;
        }

        public void SetFuncMouseEnter(FuncMouseEnter func)
        {
            funcMouseEnter = func;
        }
        public void SetFuncMouseLeave(FuncMouseLeave func)
        {
            funcMouseLeave = func;
        }
        public void SetFuncLostFocus(FuncLostFocus func)
        {
            funcLostFocus = func;
        }
    }
}
// _IMGDISP_SOURCE_FILE_MOUSEKEYHANDLER_CS END
// _IMGDISP_SOURCE_FILE_IMGDISPMOUSEKEYHANDLER_CS

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using System.Windows;

namespace ImgDisp.Img
{
    public class ImgDispMouseKeyHandler : MouseKeyHandler
    {
        void OnMouseLeftDown(Point pt)
        {
        }
        void OnMouseLeftUp(Point pt)
        {
        }
        void OnMouseLeftClick(Point pt)
        {
        }

        void OnMouseRightDown(Point pt)
        {
        }
        void OnMouseRightUp(Point pt)
        {
        }
        void OnMouseRightClick(Point pt)
        {
        }

        void OnMouseMove(Vector vec, Point pt)
        {
        }
        void OnMouseWheel(int d, Point pt)
        {
        }

        void OnMouseLeftDrag(Vector vec, Point pt)
        {
        }
        void OnMouseLeftDragBegin(Point pt)
        {
        }
        void OnMouseLeftDragEnd(Point pt)
        {
        }
        void OnMouseRightDrag(Vector vec, Point pt)
        {
        }
        void OnMouseRightDragBegin(Point pt)
        {
        }
        void OnMouseRightDragEnd(Point pt)
        {
        }

        void OnMouseEnter(Vector vec, Point pt)
        {
        }
        void OnMouseLeave(Vector vec, Point pt)
        {
        }
        void OnLostFocus(Point pt)
        {
        }
    }
}
// _IMGDISP_SOURCE_FILE_IMGDISPMOUSEKEYHANDLER_CS END

#pragma once
#define _IMGDISP_SOURCE_FILE_WRAPPER_H

#define DLL_IMPORT_MODE

#include <msclr\marshal.h>
#include <msclr\marshal_cppstd.h>

#include "ImgDisp.h"


/************************
 Using
*************************/
using msclr::interop::marshal_as;
using System::String;
using System::Exception;

using Logging::Logger;

using ImgDisplay::iDimB;
using ImgDisplay::iDimZ;
using ImgDisplay::COLOR4B;
using ImgDisplay::RECTXB;

using ImgDisplay::IMGDISP_PIXELFORMAT;
using ImgDisplay::IMGSYS_RET;
using ImgDisplay::ImgProcess;
using ImgDisplay::ImgDisp;


/************************
 Define
*************************/
#define CATCH_ALL_ERRORS 						\
catch (const std::exception& stde)  			\
{												\
	Exception ^exstd = gcnew Exception(			\
		String::Format("WrapperException: {0}",	\
		marshal_as<String^>(stde.what())));		\
	throw exstd;								\
}  												\
catch (...)										\
{												\
	Exception ^ex = gcnew Exception(			\
		"UnKnown Wrapper Exception");			\
	throw ex;									\
}

#define CATCH_ALL_ERRORS_NOTHROW				\
catch (const std::exception& stde)  			\
{												\
}												\
catch (...)										\
{												\
}

namespace Wrapper
{

	public ref class ImgProcessWrapper
	{
	public:
		static int Log0(String^ msg);
		static String^ GetLog0File();

		// Scale
		static int Scale(
			void *pImg, int wImg, int hImg, int strideImg,
			void *pImg2, int wImg2, int hImg2, int strideImg2,
			int format,
			int interpolation);

		// RenderClip
		static int RenderClip_XRGB(
			void *pImg, int wImg, int hImg, int strideImg,
			void *pBuf, int wBuf, int hBuf, int strideBuf,
			int xDest, int yDest, int x2Dest, int y2Dest,
			int interpolation);
	};

	public ref class ImgDispWrapper
	{
	private:
		ImgDisp *pImgDisp;
	protected:
		!ImgDispWrapper();
	public:
		ImgDispWrapper();
		~ImgDispWrapper();
		inline int GetWidth()
		{
			if(pImgDisp != NULL)
			{
				return pImgDisp->GetWidth();
			}
			return -1;
		}
		inline int GetHeight()
		{
			if(pImgDisp != NULL)
			{
				return pImgDisp->GetHeight();
			}
			return -1;
		}
		inline int GetBytesPerPixel()
		{
			if(pImgDisp != NULL)
			{
				return pImgDisp->GetBytesPerPixel();
			}
			return -1;
		}
		inline void SetColorBkg(COLOR4B color)
		{
			if(pImgDisp != NULL)
			{
				pImgDisp->SetColorBkg(color);
			}
		}
		inline void SetColorIllus(COLOR4B color)
		{
			if(pImgDisp != NULL)
			{
				pImgDisp->SetColorIllus(color);
			}
		}
		inline int GetBlockSize()
		{
			if(pImgDisp != NULL)
			{
				return pImgDisp->GetBlockSize();
			}
			return -1;
		}
		inline bool HasImage()
		{
			if(pImgDisp != NULL)
			{
				return pImgDisp->HasImage();
			}
			return false;
		}
		int SetBlockSize(int szBlk);

		int Clear();

		int OpenImage(
			String^ file);

		int OpenImage(
			String^ file,
			iDimB x, iDimB y, iDimB w, iDimB h);

		int OpenImage(
			String^ file,
			RECTXB rc);

		int Render(
			void *pImg, iDimB wImg, iDimB hImg, int stride,
			iDimB xTran, iDimB yTran,
			iDimB wTargetImg, iDimB hTargetImg);
		int Render0(
			void *pImg, iDimB wImg, iDimB hImg, int stride,
			iDimZ xTarget, iDimZ yTarget,
			iDimB wTarget, iDimB hTarget, double zoom);

		int RenderIllustration(
			void *pImg, iDimB wImg, iDimB hImg, int strideImg,
			bool bBlock, bool bClipRegion);
	};
}

#undef DLL_IMPORT_MODE

#undef _IMGDISP_SOURCE_FILE_WRAPPER_H
#define _IMGDISP_SOURCE_FILE_WRAPPER_CPP

#include "stdafx.h"

#include "Wrapper.h"

namespace Wrapper
{

int Wrapper::ImgProcessWrapper::Log0(String^ msg)
{
	std::string strMsg = marshal_as<std::string>(msg); 
	return Logging::Logger::Log0(strMsg);
}

String^ Wrapper::ImgProcessWrapper::GetLog0File()
{
	std::string strFile = Logging::Logger::GetFile0();
	return gcnew String(strFile.c_str());
}

int Wrapper::ImgProcessWrapper::Scale(
	void *pImg, int wImg, int hImg, int strideImg,
	void *pImg2, int wImg2, int hImg2, int strideImg2,
	int format,
	int interpolation)
{
	return ImgProcess::Scale(
		pImg, wImg, hImg, strideImg,
		pImg2, wImg2, hImg2, strideImg2,
		format,
		interpolation);
}

int Wrapper::ImgProcessWrapper::RenderClip_XRGB(
	void *pImg, int wImg, int hImg, int strideImg,
	void *pBuf, int wBuf, int hBuf, int strideBuf,
	int xDest, int yDest, int x2Dest, int y2Dest,
	int interpolation)
{
	return ImgProcess::RenderClip_XRGB(
		pImg, wImg, hImg, strideImg,
		pBuf, wBuf, hBuf, strideBuf,
		xDest, yDest, x2Dest, y2Dest,
		interpolation);
}



Wrapper::ImgDispWrapper::ImgDispWrapper(void)
{
	using ImgDisplay::ImgDisp;
	pImgDisp = new ImgDisp();
}

// Destructor (deterministic)
Wrapper::ImgDispWrapper::~ImgDispWrapper(void)
{
	this->!ImgDispWrapper();
}

// Finalizer (non-deterministic)
Wrapper::ImgDispWrapper::!ImgDispWrapper(void)
{
	SAFE_DELETE(pImgDisp);
}

int Wrapper::ImgDispWrapper::SetBlockSize(int szBlk)
{
	if(pImgDisp != NULL)
	{
		return pImgDisp->SetBlockSize(szBlk);
	}
	return false;
}

int Wrapper::ImgDispWrapper::Clear()
{
	if(pImgDisp != NULL)
	{
		return pImgDisp->Clear();
	}

	return IMGSYS_RET::ISR_NULLMEMPTR;
}

int Wrapper::ImgDispWrapper::OpenImage(
	String^ file)
{
	try
	{
	if(pImgDisp != NULL)
	{
		std::string filePath = marshal_as<std::string>(file); 

		int ret = pImgDisp->OpenImage(filePath);

		return ret;
	}
	return IMGSYS_RET::ISR_NULLMEMPTR;
	}
	CATCH_ALL_ERRORS
}

int Wrapper::ImgDispWrapper::OpenImage(
	String^ file,
	iDimB x, iDimB y, iDimB w, iDimB h)
{
	try
	{
	if(pImgDisp != NULL)
	{
		std::string filePath = marshal_as<std::string>(file); 

		int ret = pImgDisp->OpenImage(filePath, RECTXB::FromXYWH(x, y, w, h));

		return ret;
	}
	return IMGSYS_RET::ISR_NULLMEMPTR;
	}
	CATCH_ALL_ERRORS
}

int Wrapper::ImgDispWrapper::OpenImage(
	String^ file,
	RECTXB rc)
{
	try
	{
	if(pImgDisp != NULL)
	{
		std::string filePath = marshal_as<std::string>(file); 

		int ret = pImgDisp->OpenImage(filePath, rc);

		return ret;
	}
	return IMGSYS_RET::ISR_NULLMEMPTR;
	}
	CATCH_ALL_ERRORS
}

int Wrapper::ImgDispWrapper::Render(
	void *pImg, iDimB wImg, iDimB hImg, int stride,
	iDimB xTran, iDimB yTran,
	iDimB wTargetImg, iDimB hTargetImg
	)
{
	//try
	//{
	if(pImgDisp != NULL)
	{
		return pImgDisp->Render(
			pImg, wImg, hImg, stride,
			xTran, yTran,
			wTargetImg, hTargetImg);
	}
	return IMGSYS_RET::ISR_NULLMEMPTR;
	//}
	//CATCH_ALL_ERRORS_NOTHROW
}

int Wrapper::ImgDispWrapper::Render0(
	void *pImg, iDimB wImg, iDimB hImg, int stride,
	iDimZ xTarget, iDimZ yTarget,
	iDimB wTarget, iDimB hTarget, double zoom
	)
{
	//try
	//{
	if(pImgDisp != NULL)
	{
		return pImgDisp->Render0(
			pImg, wImg, hImg, stride,
			xTarget, yTarget,
			wTarget, hTarget, zoom);
	}
	return IMGSYS_RET::ISR_NULLMEMPTR;
	//}
	//CATCH_ALL_ERRORS_NOTHROW
}

int Wrapper::ImgDispWrapper::RenderIllustration(
	void* pImg, iDimB wImg, iDimB hImg, int strideImg,
	bool bBlock, bool bClipRegion)
{
	//try
	//{
	if(pImgDisp != NULL)
	{
		return pImgDisp->RenderIllustration(
			pImg, wImg, hImg, strideImg,
			bBlock, bClipRegion);
	}
	return IMGSYS_RET::ISR_NULLMEMPTR;
	//}
	//CATCH_ALL_ERRORS_NOTHROW
}

}

#undef _IMGDISP_SOURCE_FILE_WRAPPER_CPP
#define _IMGDISP_SOURCE_FILE_LOGGER_H
#pragma once

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#include <string>
#include <fstream>


/************************
 Using
*************************/
using std::endl;
using std::string;
using std::ofstream;



/************************
 DLL Export/Import define
*************************/
#ifdef DLL_IMPORT_MODE
#define DLLEXPORT			__declspec(dllimport)
#else
#define DLLEXPORT			__declspec(dllexport)
#endif


namespace Logging
{

//class DLLEXPORT Logger;
//extern DLLEXPORT Logger g_logger;

inline string GetSystemTimeStr(char td = ':')
{
	FILETIME ft;
	GetSystemTimeAsFileTime(&ft);
	SYSTEMTIME st;
	FileTimeToSystemTime(&ft, &st);

	char buf[32] = {0};
	string fmt = (string)"%u-%02u-%02u-%u" + td + "%02u" + td + "%02u.%03u";
	StringCchPrintfA(buf, 32, fmt.c_str(),
		st.wYear, st.wMonth, st.wDay,
		st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);

	return string(buf);
}

inline string GetSystemTimeStr2()
{
	FILETIME ft;
	GetSystemTimeAsFileTime(&ft);
	SYSTEMTIME st;
	FileTimeToSystemTime(&ft, &st);

	char buf[32] = {0};
	string fmt = (string)"%u%02u%02u%02u%02u%02u%03u";
	StringCchPrintfA(buf, 32, fmt.c_str(),
		st.wYear, st.wMonth, st.wDay,
		st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);

	return string(buf);
}

class DLLEXPORT Logger
{
public:
	static bool		__bPrepared;
	static bool		Prepare();

	static int		OpenLogger(const string &file);
	static int		CloseLogger();
	static bool		IsLoggerOpen();
	static int		Log0(const string &msg);
	static int		Log0(const string &h, const string &msg);
	static string	GetFile0();

protected:
	string			_file;
	ofstream		_out;

private:
	Logger(Logger &log);
	Logger& operator = (Logger &log);
public:
	Logger();
	Logger(Logger &&log);
	Logger& operator = (Logger &&log);
	~Logger();

	int Open(const string &file);
	int Close();
	inline bool IsOpen() const
	{
		return _out.is_open();
	}
	int Log(const string &msg)
	{
		if(IsOpen())
		{
			_out << GetSystemTimeStr() << "\t[T#" << GetCurrentThreadId() << "]\t" << msg << endl;

			return 1;
		}

		return 0;
	}
	string GetFile() const
	{
		if(__bPrepared)
		{
			return _file;
		}

		return "";
	}
};


}

#undef _IMGDISP_SOURCE_FILE_LOGGER_H
#define _IMGDISP_SOURCE_FILE_LOGGER_CPP

#include "pch.h"

#include "logger.h"


namespace Logging
{

// Global logger
Logger g_logger = Logger();

bool Logger::__bPrepared = Logger::Prepare();// TODO

bool Logger::IsLoggerOpen()
{
	return g_logger.IsOpen();
}

bool Logger::Prepare()
{
	// open logger
	string file = ".\\ImgDisp_Log_" + Logging::GetSystemTimeStr('-') + ".txt";
	int ret = Logger::OpenLogger(file);
	
	if(ret == 1)
	{
		__bPrepared = true;
	}
	else
	{
		__bPrepared = false;

		/*ofstream ooo;
		ooo.open(".\\error_log.txt");
		ooo << "open file ret: " + std::to_string(ret)
			<< ", " << g_logger.IsOpen() << endl;
		ooo << "open file " + file + " failed!" << endl;
		ooo.close();*/
	}

	return __bPrepared;
}

int Logger::OpenLogger(const string &file)
{
	int ret = g_logger.Open(file);
	g_logger.Log("Logger Opened!\n");

	return ret;
}

int Logger::CloseLogger()
{
	if(!g_logger.IsOpen())
	{
		return -1;
	}
	
	g_logger.Log("Logger Closed!\n");
	return g_logger.Close();
}

int Logger::Log0(const string &msg)
{
	if(!g_logger.IsOpen())
	{
		return -1;
	}
	
	int ret = g_logger.Log(msg);

	return ret;
}

int Logger::Log0(const string &h, const string &msg)
{
	if(!g_logger.IsOpen())
	{
		return -1;
	}
	
	int ret = g_logger.Log(h + msg);

	return ret;
}

string Logger::GetFile0()
{
	return g_logger.GetFile();
}


Logger::Logger()
{
}

Logger::Logger(Logger &&log)
{
	_out.move(std::forward<ofstream>(log._out));
}

Logger& Logger::operator = (Logger &&log)
{
	_out.move(std::forward<ofstream>(log._out));

	return *this;
}

Logger::~Logger()
{
	Close();
}

int Logger::Open(const string &file)
{
	if(IsOpen())
	{
		Close();
	}

	_out.open(file);
	if(!IsOpen())
	{
		return -1;
	}
	_file = file;

	return 1;
}

int Logger::Close()
{
	if(IsOpen())
	{
		Log("Logger Closed!");
		_out.close();
		_file.clear();
		return 1;
	}

	return 0;
}

}

#undef _IMGDISP_SOURCE_FILE_LOGGER_CPP
#define _IMGDISP_SOURCE_FILE_LANGBASE_H
#pragma once

#include <string>
#include <functional>
#include <stdarg.h>

#include "logger.h"


/************************
 Using
*************************/
using Logging::Logger;

using std::function;
using std::string;
using std::to_string;


/************************
 Define
*************************/
// Language
#ifndef DLLEXPORT
	#ifdef DLL_IMPORT_MODE
	#define DLLEXPORT			__declspec(dllimport)
	#else
	#define DLLEXPORT			__declspec(dllexport)
	#endif
#endif

// Do Something
#define DO_SOMETHING(stts)		do{	\
	stts	\
	} while(0);

// Mem
#define SAFE_DELETE(P)		{if(nullptr != (P)){ delete (P); (P) = nullptr;}}
#define SAFE_DELETE_LIST(P)	{if(nullptr != (P)){ delete[] (P); (P) = nullptr;}}

// return
#define RETVAL_ON_FAILED(hr, val)		{ if(FAILED(hr)) { return (val); }}
#define RETVAL_ON_TRUE(b, val)			{ if((b)) { return (val); }}
#define RETVAL_ON_TRUE_AND(b, val, stts)	{ if((b)) { DO_SOMETHING(stts); return (val); }}
#define RET_ON_TRUE(b)					{ if(b) { return true; }}
#define RET_ON_TRUE_AND(b, stts)		{ if(b) { DO_SOMETHING(stts); return true; }}
#define RET_ON_FALSE(b)					{ if(!(b)) { return false; }}
#define RET_ON_FALSE_AND(b, stts)		{ if(!(b)) { DO_SOMETHING(stts); return false; }}
#define RET_ON_ZERO(v)					{ if(0 == (v)) { return (0); }}
#define RET_ON_ZERO_AND(v, stts)		{ if(0 == (v)) { DO_SOMETHING(stts); return (0); }}
#define RETVAL_ON_NULLPTR(p, val)		{ if(nullptr == (p)) { return (val); }}
#define RETVAL_ON_ZERO(v, val)			{ if(0 == (v)) { return (val); }}
#define RETVAL_ON_FALSE(b, val)			{ if(!(b)) { return (val); }}
#define RETVAL_ON_FALSE_AND(b, val, stts)	{ if(!(b)) { DO_SOMETHING(stts); return (val); }}
#define RET_ON_NEG(val)					{ if((val) < 0) { return (val); }}
#define RET_ON_NEG_AND(val, stts)		{ if((val) < 0) { DO_SOMETHING(stts); return (val); }}
#define RETVAL_ON_NEG(v, val)			{ if((v) < 0) { return (val); }}
#define RETVAL_ON_NEG_AND(v, val, stts)	{ if((v) < 0) { DO_SOMETHING(stts); return (val); }}
#define RET_ON_NP(val)					{ if((val) <= 0) { return (val); }}
#define RETVAL_ON_POS(v, val)			{ if((v) > 0) { return (val); }}
#define RETVAL_ON_NP(v, val)			{ if((v) <= 0) { return (val); }}
#define RETVAL_ON_NP_AND(v, val, stts)	{ if((v) <= 0) { DO_SOMETHING(stts); return (val); }}
#define RET_ON_NP_AND(val, stts)		{ if((val) <= 0) { DO_SOMETHING(stts); return (val); }}
#define RETVAL_ON_NULLPTR_AND(p, val, stts)	{ if(nullptr == (p)) { DO_SOMETHING(stts); return (val); }}
#define BREAK_ON_FALSE_AND(exp, stts)	{ if(!(exp)) { DO_SOMETHING(stts); break; }}
#define BREAK_ON_POS(val)				{ if((val) > 0) { break; }}
#define BREAK_ON_NEG_AND(val, stts)		{ if((val) < 0) { DO_SOMETHING(stts); break; }}
#define BREAK_ON_NULLPTR_AND(p, stts)	{ if(nullptr == (p)) { DO_SOMETHING(stts); break; }}
#define CONTINUE_ON_FALSE(b)			{ if(!(b)) { continue; }}
#define CONTINUE_ON_FALSE_AND(b, stts)	{ if(!(b)) { DO_SOMETHING(stts); continue; }}
#define CONTINUE_ON_NEG(val)			{ if((val) < 0) { continue; }}
#define CONTINUE_ON_NEG_AND(val, stts)	{ if((val) < 0) { DO_SOMETHING(stts); continue;}}
#define CONTINUE_ON_NP(val)				{ if((val) <= 0) { continue; }}
#define CONTINUE_ON_NP_AND(val, stts)	{ if((val) <= 0) { DO_SOMETHING(stts); continue; }}
#define CONTINUE_ON_NULLPTR(p)			{ if(nullptr == (p)) { DO_SOMETHING(stts); continue; }}
#define CONTINUE_IF(exp)				{ if(exp) { continue; }}
#define CONTINUE_IF_AND(exp, stts)		{ if(exp) { DO_SOMETHING(stts); continue; }}

// Spec
#define SIZET_MAX				(size_t)(-1)
#define MIN_OF_SIGNEDTYPE(T)	((T)((T)1 << (sizeof(T)*8 - 1)))
#define MIN_OF_UNSIGNEDTYPE(T)	(0)
#define MAX_OF_SIGNEDTYPE(T)	((T)((0xFFFFFFFFFFFFFFFFui64) >> (64 - sizeof(T)*8 + 1)))
#define MAX_OF_UNSIGNEDTYPE(T)	((T)(-1))

// Limit
#define OVERFLOW_MUL(a, b, x)		((x)/(a) < (b))
#define OVERFLOW_DIV(a, b, x)		((a)/(b) > (x))

// Class
#define OVERRIDE		override
#define PURE			= 0

//#define VIRTUALINTERNALLIFECYCLE
#ifndef VIRTUALINTERNALLIFECYCLE
#define LFCTYPE
#define LFCOVERRIDE
#else
#define LFCTYPE			virtual
#define LFCOVERRIDE		override
#endif



// Namespace bse
namespace bse
{

#pragma region Template

//template<typename T>
//bool IsSignedInt()
//{
//	return std::is_same<__int8, T>::value ||
//			std::is_same<__int16, T>::value ||
//			std::is_same<__int32, T>::value ||
//			std::is_same<__int64, T>::value;
//}
//
//template<bool... B>
//struct LogicOr
//{
//	static const bool value = false;
//};
//template<bool BB, bool... B>
//struct LogicOr<BB, B...>
//{
//	static const bool value = BB || LogicOr<B...>::value;
//};
//
//template<typename T>
//struct is_signedint
//{
//	static const bool value =
//		LogicOr<
//			std::is_same<__int8, T>::value,
//			std::is_same<__int16, T>::value,
//			std::is_same<__int32, T>::value,
//			std::is_same<__int64, T>::value>::value;
//};

// Is signed int
template<typename T>
struct _Is_SignedInt : std::false_type{};
template<>
struct _Is_SignedInt<__int8> : std::true_type{};
template<>
struct _Is_SignedInt<__int16> : std::true_type{};
template<>
struct _Is_SignedInt<__int32> : std::true_type{};
template<>
struct _Is_SignedInt<__int64> : std::true_type{};


template<typename T>
struct is_signedint : _Is_SignedInt<typename std::remove_cv<T>::type>{};

// Is unsigned int
template<typename T>
struct _Is_UnsignedInt : std::false_type{};
template<>
struct _Is_UnsignedInt<unsigned __int8> : std::true_type{};
template<>
struct _Is_UnsignedInt<unsigned __int16> : std::true_type{};
template<>
struct _Is_UnsignedInt<unsigned __int32> : std::true_type{};
template<>
struct _Is_UnsignedInt<unsigned __int64> : std::true_type{};
template<typename T>
struct is_unsignedint : _Is_UnsignedInt<typename std::remove_cv<T>::type>{};

template<typename T, typename O = void>
struct enable_if_signedint : std::enable_if<is_signedint<T>::value, O>{};

template<typename T, typename O = void>
struct enable_if_unsignedint : std::enable_if<is_unsignedint<T>::value, O>{};

template<typename T, typename O = void>
struct enable_if_int
	: std::enable_if<is_signedint<T>::value || is_unsignedint<T>::value, O>{};
	//: std::enable_if<std::numeric_limits<T>::is_interger, O>

template<typename T, typename O = void>
struct enable_if_int3264
	: std::enable_if<std::is_same<__int32, T>::value || std::is_same<__int64, T>::value, O>
{
};

template<typename T, typename O = void>
struct enable_if_pod8
	: std::enable_if<(sizeof(T) <= 8 && std::is_pod<T>::value), O>
{
};

#pragma endregion Template

#pragma region Limit
/************************
 Limit
*************************/

#pragma region Limit-Add

#pragma endregion Limit-Add

#pragma region Limit-Mul

#pragma endregion Limit-Mul


template<typename T>
const typename
enable_if_signedint<T, T>::type
MaxValue()
{
	//return std::numeric_limits<T>::min();
	return MAX_OF_SIGNEDTYPE(T);
}
template<typename T>
const typename
enable_if_unsignedint<T, T>::type
MaxValue()
{
	return MAX_OF_UNSIGNEDTYPE(T);
}

template<typename T>
const typename
enable_if_signedint<T, T>::type
MinValue()
{
	return MIN_OF_SIGNEDTYPE(T);
}
template<typename T>
const typename 
enable_if_unsignedint<T, T>::type
MinValue()
{
	return MIN_OF_UNSIGNEDTYPE(T);
}


// mathematically add greater than
template<typename T>
static typename
enable_if_signedint<T, bool>::type
AddGT(T a, T b, T x)
{
	const bool bAP = a >= 0;
	const bool bBP = b >= 0;
	if(bAP ^ bBP)
	{
		return a + b > x;
	}
	else
	{
		const bool bXP = x >= 0;
		if(bXP ^ bAP)
		{
			return bAP;
		}
		else
		{
			return (x - a < b);
		}
	}
}
// mathematically add greater than
template<typename T>
static typename
enable_if_unsignedint<T, bool>::type
AddGT(T a, T b, T x)
{
	return (a > x || b > x - a);
}
// mathematically add greater than/equal
template<typename T>
static typename
enable_if_signedint<T, bool>::type
AddGE(T a, T b, T x)
{
	const bool bAP = a >= 0;
	const bool bBP = b >= 0;
	if(bAP ^ bBP)
	{
		return a + b >= x;
	}
	else
	{
		const bool bXP = x >= 0;
		if(bXP ^ bAP)
		{
			return bAP;
		}
		else
		{
			return (x - a <= b);
		}
	}
}
// mathematically add greater than/equal
template<typename T>
static typename
enable_if_unsignedint<T, bool>::type
AddGE(T a, T b, T x)
{
	return (a >= x || b >= x - a);
}
// mathematically add less than
template<typename T>
static typename
enable_if_signedint<T, bool>::type
AddLT(T a, T b, T x)
{
	const bool bAP = a >= 0;
	const bool bBP = b >= 0;
	if(bAP ^ bBP)
	{
		return a + b < x;
	}
	else
	{
		const bool bXP = x >= 0;
		if(bXP ^ bAP)
		{
			return !bAP;
		}
		else
		{
			return (x - a > b);
		}
	}
}
// mathematically add less than
template<typename T>
static typename
enable_if_unsignedint<T, bool>::type
AddLT(T a, T b, T x)
{
	return (a < x && b < x - a);
}
// mathematically add less than/equal
template<typename T>
static typename
enable_if_signedint<T, bool>::type
AddLE(T a, T b, T x)
{
	const bool bAP = a >= 0;
	const bool bBP = b >= 0;
	if(bAP ^ bBP)
	{
		return a + b <= x;
	}
	else
	{
		const bool bXP = x >= 0;
		if(bXP ^ bAP)
		{
			return false;
		}
		else
		{
			return (x - a >= b);
		}
	}
}
// mathematically add less than/equal
template<typename T>
static typename
enable_if_unsignedint<T, bool>::type
AddLE(T a, T b, T x)
{
	return (a <= x && b <= x - a);
}

template<typename T, typename = typename enable_if_int<T>::type>
class XOverflow
{
public:
	typedef T	Type;
public:
	// overflow type B
	template<typename B>
	static bool
	Overflow(T a)
	{
		const B minValue = MinValue<B>();
		const B maxValue = MaxValue<B>();
		return a > maxValue || a < minValue;
	}
	// overflow type B upper
	template<typename B>
	static bool
	OverflowUpper(T a)
	{
		const B maxValue = MaxValue<B>();
		return a > maxValue; 
	}
	// overflow type B lower
	template<typename B>
	static bool
	OverflowLower(T a)
	{
		const B minValue = MinValue<B>();
		return a < minValue; 
	}

	// multiply overflow type T
	static bool
	MulOF(T a, T b)
	{
		if(a == 0 || b == 0)
		{
			return false;
		}
		const T limit = ((a > 0)^(b > 0)) ? MinValue<T>() : MaxValue<T>();
		return a > 0 ? (limit / b < a) : (limit / b > a);
	}
	// multiply overflow type B
	template<typename B>
	static bool
	MulOFB(T a, T b)
	{
		if(a == 0 || b == 0)
		{
			return false;
		}
		const B limit = ((a > 0)^(b > 0)) ? MinValue<B>() : MaxValue<B>();
		return a > 0 ? (limit / b < a) : (limit / b > a);
	}
	// mathematically multiply greater than
	static bool
	MulGT(T a, T b, T x)
	{
		if(a == 0 || b == 0)
		{
			return false;
		}
		return b > 0 ? (x / b < a) : (x / b > a);
	}
	// mathematically multiply greater than B
	template<typename B>
	static bool
	MulGTB(T a, T b, B x)
	{
		if(a == 0 || b == 0)
		{
			return false;
		}
		return b > 0 ? (x / b < a) : (x / b > a);
	}
	// mathematically multiply less than
	static bool
	MulLT(T a, T b, T x)
	{
		if(a == 0 || b == 0)
		{
			return false;
		}
		return b > 0 ? (x / b > a) : (x / b < a);
	}
	// mathematically multiply less than B
	template<typename B>
	static bool
	MulLTB(T a, T b, B x)
	{
		if(a == 0 || b == 0)
		{
			return false;
		}
		return b > 0 ? (x / b > a) : (x / b < a);
	}
	// TODO
	//MulGTBOF where a*b>x || a*b<minLimit
	
	// mathematically add greater than
	static bool
	AddGT(T a, T b, T x)
	{
		return bse::AddGT(a, b, x);
	}
	// mathematically add greater than
	static bool
	AddGE(T a, T b, T x)
	{
		return bse::AddGE(a, b, x);
	}
	// mathematically add less than
	static bool
	AddLT(T a, T b, T x)
	{
		return bse::AddLT(a, b, x);
	}
	// mathematically add less than/equal
	static bool
	AddLE(T a, T b, T x)
	{
		return bse::AddLE(a, b, x);
	}
	
	// add overflow type T
	static bool
	AddOF(T a, T b)
	{
		const T minValue = MinValue<T>();
		const T maxValue = MaxValue<T>();
		return AddGT(a, b, maxValue) || AddLT(a, b, minValue); 
	}
};


#pragma endregion Limit


#pragma region TypeOf
/************************
 Type
*************************/
#ifdef CUSTOMIZED_TYPEOF

#define EXPAND(...) __VA_ARGS__

// type_info& as [type]
template <const std::type_info& type_id>
struct TypeID {
};
#define type_id(...) TypeID<typeid(__VA_ARGS__)>

// Decode type
template <typename T>struct Decode;
template <typename T>struct Decode<T*> { typedef T type_t; };

#ifdef SEMIAUTO_TYPEOF

// Extract type
template<typename ID>
struct Extract{};
#define type_extract(...) \
	Extract<type_id(__VA_ARGS__) >::type_t

// Encode type
template <typename T>
struct Encode
{ typedef T* type_t; };

// Register type
#define REGISTER_TYPE(type) \
	template<> \
	struct Extract<type_id(type*) > { typedef type* type_t; };

REGISTER_TYPE(int)

#else

struct empty_t {};

// Extract type
template<typename ID, typename T = empty_t>
struct Extract;
template<typename ID>
struct Extract<ID, empty_t>
{
	template <bool>
	struct id2type;
};

template<typename ID, typename T>
struct Extract : Extract<ID, empty_t>
{
	template <>
	struct id2type<true>
	{
		typedef T type_t;
	};
};

#define type_extract(...) \
	Extract<type_id(__VA_ARGS__) >::id2type<true>::type_t

// Register type
template<typename T, typename ID>
struct Register : Extract<ID, T>
{
	typedef typename id2type<true>::type_t type_t;
};

// Encode type
template <typename T>
struct Encode
{
	typedef T* enc_type_t;
	typedef Register<enc_type_t, type_id(enc_type_t)> reg_type;
	typedef typename reg_type::type_t	type_t;
};

#endif

template <typename T>
typename Encode<T>::type_t encode(const T&);
template <typename T>
typename Encode<T>::type_t encode(T&);

#ifndef __GNUC__
// type_of function
#define type_of(...) \
	Decode<type_extract(encode(__VA_ARGS__))>::type_t
#endif

//int j = 3;
//type_of(j) a = 4;
//Logger::Log0(to_string(a) + "," + string(typeid(a).name()));

#endif
#pragma endregion TypeOf


#pragma region ILifeCycle
/************************
 LifeCycle
*************************/
class ILifeCycle
{
protected:
	LFCTYPE void	ClearPreAssign();
	LFCTYPE void	ClearMove();
	void			Release();
};


/************************
 Follow LifeCycle
*************************/
template <class F>
class IFollowMember
{
protected:
	F *_res;
	
	LFCTYPE void	ClearPreAssign()
	{
		SAFE_DELETE(_res);
	}
	LFCTYPE void	ClearMove()
	{
		_res = nullptr;
		_res = new F();
	}
	void			Release()
	{
		IFollowMember::ClearPreAssign();
	}
private:
	// Disable copy-ctor, = operator
	IFollowMember(const IFollowMember&);
	IFollowMember&	operator = (const IFollowMember&);
public:
	IFollowMember():
		_res			(nullptr)
	{
		_res = new F();
	}
	IFollowMember(const F &f):
		_res			(nullptr)
	{
		_res = new F(f);
	}
	~IFollowMember()
	{
		Release();
	}
	
	IFollowMember(IFollowMember&& other):
		_res		(other._res)
	{
		other.IFollowMember::ClearMove();
	}
	int			AssignMove(IFollowMember &other)
	{
		// Clear before assignment
		IFollowMember::ClearPreAssign();

		_res		= other._res;
	
		// Clear after move
		other.IFollowMember::ClearMove();

		return 1;
	}
	IFollowMember&	operator = (IFollowMember&& other)
	{
		AssignMove(other);

		return *this;
	}
	F*				operator -> ()
	{
		return _res;
	}
	const F*		operator -> () const
	{
		return (const F*)_res;
	}
	F&				operator*()
	{
		return *_res;
	}
	const F&		operator*() const
	{
		return *_res;
	}
	inline bool		HasRes() const
	{
		return _res != nullptr;
	}

	inline F*		GetRes()
	{
		return _res;
	}

	inline const F*	GetResC() const
	{
		return _res;
	}
	inline void		Reset()
	{
		_res = nullptr;
		//try
		//{
			_res = new F();
		//}
		//catch(std::exception stde)
		//{
		//	// Alloc resource failed
		//}
	}
};
#pragma endregion ILifeCycle


#pragma region Ticker
/************************
 Ticker
*************************/
class DLLEXPORT Ticker{
public:
	typedef LONGLONG		tick_t;
	typedef LONGLONG		freq_t;
protected:
	static bool		__bPrepared;
	static freq_t	f;// frequency

	tick_t			s;// starttime
	bool			bRun;

	double			c;// cycle
	double			ca;// accumulation of cycle
public:
	static bool Prepare();

	static inline void		GetSystemTime(SYSTEMTIME &st)
	{
		FILETIME ft;
		GetSystemTimeAsFileTime(&ft);
		FileTimeToSystemTime(&ft, &st);
	}
	static inline string	GetSystemTime()
	{
		SYSTEMTIME st;
		Ticker::GetSystemTime(st);

		char buf[32] = {0};
		StringCchPrintfA(buf, 32, "%u-%02u-%02u %u:%02u:%02u.%03u",
			st.wYear, st.wMonth, st.wDay,
			st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);

		return string(buf);
	}
	static inline tick_t	GetTick()
	{
		LARGE_INTEGER t = {0};
		QueryPerformanceCounter(&t);

		return t.QuadPart;
	}
	static inline double	GetPeriod(tick_t t)
	{
		LARGE_INTEGER e = {0};
		QueryPerformanceCounter(&e);
		return (double)(e.QuadPart - t)/f;
	}
	static freq_t GetFreq()
	{
		return f;
	}

	Ticker()
	{
		bRun = false;
	}
	~Ticker()
	{
	}

	inline void Ticker::Start()
	{
		LARGE_INTEGER t = {0};
		QueryPerformanceCounter(&t);

		s = t.QuadPart;

		ca = c;

		bRun = true;
	}
	inline void Ticker::ReStart()
	{
		Start();
	}
	inline double Ticker::Tick() const
	{
		if(!bRun)
		{
			return -1;
		}

		LARGE_INTEGER t = {0};
		QueryPerformanceCounter(&t);
		
		double sec = (double)(t.QuadPart - s)/f;

		return sec;
	}
	inline double Ticker::Cycle()
	{
		if(!bRun)
		{
			return -1;
		}

		LARGE_INTEGER t = {0};
		QueryPerformanceCounter(&t);
		
		double sec = (double)(t.QuadPart - s)/f;

		// restart
		s = t.QuadPart;

		return sec;
	}
	inline double Ticker::Stop()
	{
		if(!bRun)
		{
			return -1;
		}

		bRun = false;

		LARGE_INTEGER t = {0};
		QueryPerformanceCounter(&t);

		double sec = (double)(t.QuadPart - s)/f;

		return sec;
	}

	inline void SetCycle(double cycle)
	{
		c = cycle;
	}
	inline bool IfCycleAndDoAutoAccum(double *pSec = NULL)
	{
		if(!bRun)
		{
			if(NULL != pSec)
			{
				*pSec = -1;
			}

			return false;
		}

		double sec = Tick();

		bool bCycle = sec >= ca;
		if(bCycle)
		{
			ca += c;
		}

		if(NULL != pSec)
		{
			*pSec = sec;
		}

		return bCycle;
	}
};
#pragma endregion Ticker


#pragma region ScopeGuard
/************************
 ScopeGuard
*************************/
//template class DLLEXPORT std::function<void()>;

template <class F>
class ScopeGuard;

template <class F>
struct DLLEXPORT ScopeGuardComp
{
public:
	typedef std::function<F>	func_t;

	func_t	_func;
	bool	_enabled;

public:
	ScopeGuardComp()							:_func(), _enabled(false){}
	ScopeGuardComp(const ScopeGuardComp& scg)	:_func(scg._func), _enabled(scg._enabled){}
	ScopeGuardComp(ScopeGuard<F>&& scg)			:_func(scg.GetFunc()), _enabled(scg.IsEnabled())
	{
		scg.Abandon();
	}
	ScopeGuardComp& operator= (ScopeGuard<F>&& scg)
	{
		_func = scg.GetFunc();
		_enabled = scg.IsEnabled();

		scg.Abandon();

		return *this;
	}

	void	Clear()
	{
		_enabled = false;
		_func = func_t();
	}
};

typedef ScopeGuardComp<void()>	scope_guard_comp;

template <class F>
class DLLEXPORT ScopeGuard
{
public:
	typedef std::function<F>	func_t;
	
protected:
	func_t	_func;
	bool	_enabled;
protected:
	LFCTYPE void ClearPreAssign()
	{
		Release();
	}
	LFCTYPE void ClearMove()
	{
		_enabled	= false;
		_func.swap(func_t());
	}
private:
	// Disable copy-ctor, = operator
	ScopeGuard(ScopeGuard &s);
	ScopeGuard& operator = (ScopeGuard &s);
public:
	ScopeGuard()							:_func(), _enabled(false){}
	explicit ScopeGuard(const func_t &f)	:_func(f), _enabled(true){}
	explicit ScopeGuard(const func_t &&f)	:_func(f), _enabled(true){}
	ScopeGuard(ScopeGuardComp<F> &&scgc):_func(scgc._func), _enabled(scgc._enabled)
	{
		scgc.Clear();
	}

	ScopeGuard(ScopeGuard &&s):
		_func		(std::forward<func_t>(s._func)),
		_enabled	(s._enabled)
	{
		//Logger::g_logger.Log("ScopeGuard::Move ctor");
		s.ScopeGuard::ClearMove();
	}
	ScopeGuard& operator = (ScopeGuard &&s)
	{
		ScopeGuard::ClearPreAssign();

		_func		= std::forward<func_t>(s._func);
		_enabled	= s._enabled;

		s.ScopeGuard::ClearMove();

		return *this;
	}

	bool NotWork() const
	{
		return Empty() || !IsEnabled();
	}
	bool Empty() const
	{
		return _func._Empty();
	}
	bool SetFunc(const func_t &f)
	{
		// do not handle old guard

		_func = f;
		return true;
	}
	bool Disable()
	{
		_enabled = false;
		return true;
	}
	bool Enable()
	{
		_enabled = true;
		return true;
	}
	bool SetAndEnable(const func_t &f)
	{
		// do not handle old guard

		_func = f;
		_enabled = true;

		return true;
	}
	bool SetFrom(ScopeGuardComp<F> &&scgc)
	{
		_func		= scgc._func;
		_enabled	= scgc._enabled;

		scgc.Clear();

		return true;
	}
	void Release()
	{
		if(_enabled)
		{
			if(!_func._Empty())
			{
				_func();
			}
			_enabled	= false;
		}

		_func.swap(func_t());
	}
	bool Abandon()
	{
		_enabled	= false;
		_func.swap(func_t());

		return true;
	}
	func_t	GetFunc() const
	{
		return _func;
	}
	func_t	ExtractFunc()
	{
		_enabled	= false;
		return _func;
	}
	bool	IsEnabled() const
	{
		return _enabled;
	}
	~ScopeGuard()
	{
		//Logger::g_logger.Log("ScopeGuard::dtor");
		Release();
	}
};

//template class DLLEXPORT ScopeGuard<void()>;

typedef ScopeGuard<void()>	scope_guard;

inline void funcScopeGuardNew(void *ptr)
{
	SAFE_DELETE(ptr);
}

inline void funcScopeGuardNewList(void *ptr)
{
	//Logger::Log0("funcScopeGuardNewList: release - " + to_string((_ULonglong)ptr));
	SAFE_DELETE_LIST(ptr);
}

inline void funcScopeGuardCTS(CRITICAL_SECTION *pCTS)
{
	//Logger::Log0("funcScopeGuardCTS: leave critical section - " + to_string((_ULonglong)pCTS));
	if(nullptr != pCTS)
	{
		LeaveCriticalSection(pCTS);
	}
}

#pragma endregion ScopeGuard

}

#undef _IMGDISP_SOURCE_FILE_LANGBASE_H
#define _IMGDISP_SOURCE_FILE_LANGBASE_CPP

#include "pch.h"

#include "langBase.h"


namespace bse
{

/************************
 Ticker
*************************/
Ticker::freq_t Ticker::f = 0;
bool Ticker::__bPrepared = Ticker::Prepare();

bool Ticker::Prepare()
{
	LARGE_INTEGER freq = {0};
	QueryPerformanceFrequency(&freq);
	f = freq.QuadPart;

	Logger::Log0("Ticker: Prepared, freq:" + to_string(freq.QuadPart));
	__bPrepared = true;

	return __bPrepared;
}

}

#undef _IMGDISP_SOURCE_FILE_LANGBASE_CPP
#define _IMGDISP_SOURCE_FILE_LOCK_H
#pragma once

#include <unordered_map>

#include "langBase.h"


/************************
 Using
*************************/
using std::unordered_map;

using bse::scope_guard;
using bse::Ticker;
using bse::enable_if_pod8;
using bse::funcScopeGuardCTS;


/************************
 Time
*************************/
typedef unsigned __int32		ms_t;
typedef unsigned __int32		s_t;
typedef __int64					ms_t1;
typedef double					sec_t;

#define MS_PER_SEC				1000
#define MS_TO_SEC(MS)			((sec_t)((MS)/(double)MS_PER_SEC))
#define SEC_TO_MS(SEC)			((ms_t)((SEC)*MS_PER_SEC))


/************************
 Thread ID
*************************/
#define INVALID_TID				(-1)
#define	GET_TID					(GetCurrentThreadId())


#pragma region ThreadSafe
/************************
 IThreadSafe
*************************/
#define	LOCKCONTROLED
#define	LOCKCONTROLED_READ
#define	LOCKCONTROLED_WRITE
#define	LOCKCONTROLED_BLOCK

#define LOCK_SLEEPCYCLE				(1)
#define LOCK_TIME_INFINITE			(-1)
#define LOCK_TIME_ISINFINITE(t)		(t < 0)
#define LOCK_TIMEOUT_MS				(SEC_TO_MS(60))
#define LOCK_TIMEOUT_SEC			(LOCK_TIMEOUT_MS/MS_PER_SEC)

typedef scope_guard					lock_guard;

#define ITSSINGLE_SLEEPCYCLE				(1)
#define ITSSINGLE_INIT_INTERNAL(_lck)		InitializeCriticalSection(&_lck)
#define ITSSINGLE_TRYLOCK_INTERNAL(_lck)	TryEnterCriticalSection(&_lck)
#define ITSSINGLE_LOCK_INTERNAL(_lck)		EnterCriticalSection(&_lck)
#define ITSSINGLE_UNLOCK_INTERNAL(_lck)		LeaveCriticalSection(&_lck)
#define ITSSINGLE_DELETE_INTERNAL(_lck)		DeleteCriticalSection(&_lck)

class ITSSingle
{
private:
	CRITICAL_SECTION	_section0;// static LifeCycle member(unmove, destroy in dtor)
	ms_t				_msCycle;

private:
	ITSSingle(ITSSingle &);
	ITSSingle&		operator = (ITSSingle &);
	ITSSingle&		operator = (ITSSingle &&);
public:
	ITSSingle() : _msCycle(ITSSINGLE_SLEEPCYCLE)
	{
		ITSSINGLE_INIT_INTERNAL(_section0);
	}
	ITSSingle(ITSSingle &&its) : _msCycle(ITSSINGLE_SLEEPCYCLE)
	{
		ITSSINGLE_INIT_INTERNAL(_section0);
	}
	virtual			~ITSSingle()
	{
		// Lock
		ITSSINGLE_LOCK_INTERNAL(_section0);
		ITSSINGLE_DELETE_INTERNAL(_section0);
		memset(&_section0, 0, sizeof(CRITICAL_SECTION));
	}

	inline bool		TryLock()
	{
		return ITSSINGLE_TRYLOCK_INTERNAL(_section0) != 0;
	}
	inline void		Lock()
	{
		// Lock
		ITSSINGLE_LOCK_INTERNAL(_section0);
	}
	inline bool		Lock(ms_t msTimeout)
	{
		const sec_t sTimeout = MS_TO_SEC(msTimeout);
		
		Ticker::freq_t f = Ticker::GetFreq();
		LARGE_INTEGER s, e;
		QueryPerformanceCounter(&s);
		while(ITSSINGLE_TRYLOCK_INTERNAL(_section0) != 0)
		{
			QueryPerformanceCounter(&e);
			RETVAL_ON_TRUE(
				(sec_t)(e.QuadPart - s.QuadPart)/f > sTimeout,
				false);

			Sleep(_msCycle);
		}
	}
	inline bool		TryLockGuard(lock_guard &scg)
	{
		 RETVAL_ON_ZERO(
			 ITSSINGLE_TRYLOCK_INTERNAL(_section0),
			 false);
		scg.SetAndEnable(std::bind(funcScopeGuardCTS, &_section0));
		return true;
	}
	inline bool		LockGuard(lock_guard &scg)
	{
		ITSSINGLE_LOCK_INTERNAL(_section0);
		scg.SetAndEnable(std::bind(funcScopeGuardCTS, &_section0));
		return true;
	}
	inline void		Unlock()
	{
		ITSSINGLE_UNLOCK_INTERNAL(_section0);
	}
};

#undef ITSSINGLE_INIT_INTERNAL
#undef ITSSINGLE_TRYLOCK_INTERNAL
#undef ITSSINGLE_LOCK_INTERNAL
#undef ITSSINGLE_UNLOCK_INTERNAL
#undef ITSSINGLE_DELETE_INTERNAL

//#define ITSSINGLE_LOCK			ITSSingle::Lock();
//#define ITSSINGLE_TRYLOCK		ITSSingle::TryLock();
//#define ITSSINGLE_UNLOCK		ITSSingle::Unlock();



template<class T>
class IRefCntObj
{
public:
	typedef unsigned __int64	nref_t;

private:
	nref_t						_nRef;
	T							_obj;

public:
	IRefCntObj();
	IRefCntObj(IRefCntObj &&);
	~IRefCntObj();

	void	AddRef();
	nref_t	GetRef();
};


#define CAS(v, e, u)							_InterlockedCompareExchange(v, u, e)
#define CASSUCCEED(v, e, u)						(CAS(v, e, u) == e)
#define CASFAIL(v, e, u)						(CAS(v, e, u) != e)
#define EQU(v, e)								(CAS(v, e, e) == e)
#define UEQU(v, e)								(CAS(v, e, e) != e)
#define EXC(v, u)								_InterlockedExchange(v, u)

#define ITSCAS_SLEEPCYCLE						(1)
#define ITSCAS_INIT_INTERNAL(v)					DO_SOMETHING(\
													(v) = new cas_t();\
													*(v) = ITSCAS::ITSCAS_FREE;\
													)

#define ITSCAS_TRYLOCK_INTERNAL(v)				CAS(v, ITSCAS::ITSCAS_FREE, ITSCAS::ITSCAS_LOCKED)
#define ITSCAS_TRYLOCKED_INTERNAL(v)			CASSUCCEED(v, ITSCAS::ITSCAS_FREE, ITSCAS::ITSCAS_LOCKED)
#define ITSCAS_TRYLOCKEDNOT_INTERNAL(v)			CASFAIL(v, ITSCAS::ITSCAS_FREE, ITSCAS::ITSCAS_LOCKED)
#define ITSCAS_UNLOCK_INTERNAL(v)				EXC(v, ITSCAS::ITSCAS_FREE)
#define ITSCAS_TRYLOCKDYING_INTERNAL(v)			CAS(v, ITSCAS::ITSCAS_FREE, ITSCAS::ITSCAS_DYING)
#define ITSCAS_TRYLOCKEDNOTDYING_INTERNAL(v)	CASFAIL(v, ITSCAS::ITSCAS_FREE, ITSCAS::ITSCAS_DYING)

#pragma intrinsic(_InterlockedCompareExchange, _InterlockedExchange)

class ITSCAS
{
public:
	typedef unsigned __int64	cas_t;

	enum {ITSCAS_FREE = 0, ITSCAS_LOCKED = 1, ITSCAS_DYING = -1};
private:
	volatile cas_t	*_v;
	ms_t			_msCycle;

private:
	ITSCAS(ITSCAS &) : _msCycle(ITSCAS_SLEEPCYCLE){}
	ITSCAS&			operator = (ITSCAS &);
	ITSCAS&			operator = (ITSCAS &&);
public:
	ITSCAS() : _msCycle(ITSCAS_SLEEPCYCLE)
	{
		ITSCAS_INIT_INTERNAL(_v);
	}
	explicit ITSCAS(cas_t *v):
		_v			(v)
	{
		if(nullptr == _v)
		{
			ITSCAS_INIT_INTERNAL(_v);
		}
	}
	ITSCAS(ITSCAS &&its)
	{
		ITSCAS_INIT_INTERNAL(_v);
	}
	virtual			~ITSCAS()
	{
		// Lock
		while(true)
		{
			cas_t s = ITSCAS_TRYLOCKDYING_INTERNAL(_v);
			if(s == ITSCAS::ITSCAS_FREE || s == ITSCAS::ITSCAS_DYING)
				break;
			Sleep(_msCycle);
		}
		SAFE_DELETE(_v);
	}
	
	inline void		SetMSCycle(ms_t ms)
	{
		_msCycle = ms;
	}
	inline bool		IsLocked()
	{
		return ITSCAS::ITSCAS_FREE != *_v;
	}
	inline bool		TryLock()
	{
		return ITSCAS_TRYLOCKED_INTERNAL(_v);
	}
	inline void		Lock()
	{
		// Lock
		while(ITSCAS_TRYLOCKEDNOT_INTERNAL(_v))
		{
			Sleep(_msCycle);
		}
	}
	inline bool		Lock(ms_t msTimeout)
	{
		const sec_t sTimeout = MS_TO_SEC(msTimeout);

		Ticker::freq_t f = Ticker::GetFreq();
		LARGE_INTEGER s, e;
		QueryPerformanceCounter(&s);
		while(ITSCAS_TRYLOCKEDNOT_INTERNAL(_v))
		{
			QueryPerformanceCounter(&e);
			RETVAL_ON_TRUE(
				(sec_t)(e.QuadPart - s.QuadPart)/f > sTimeout,
				false);

			Sleep(_msCycle);
		}

		return true;
	}
	inline bool		TryLockGuard(lock_guard &scg)
	{
		RETVAL_ON_TRUE(
			 ITSCAS_TRYLOCKEDNOT_INTERNAL(_v),
			 false);

		scg.SetAndEnable(std::bind(&ITSCAS::Unlock, this));
		return true;
	}
	inline bool		LockGuard(lock_guard &scg)
	{
		while(ITSCAS_TRYLOCKEDNOT_INTERNAL(_v))
		{
			Sleep(_msCycle);
		}

		scg.SetAndEnable(std::bind(&ITSCAS::Unlock, this));
		return true;
	}
	inline bool		LockGuard(lock_guard &scg, ms_t msTimeout)
	{
		const sec_t sTimeout = MS_TO_SEC(msTimeout);

		Ticker::freq_t f = Ticker::GetFreq();
		LARGE_INTEGER s, e;
		QueryPerformanceCounter(&s);
		while(ITSCAS_TRYLOCKEDNOT_INTERNAL(_v))
		{
			QueryPerformanceCounter(&e);
			RETVAL_ON_TRUE(
				(sec_t)(e.QuadPart - s.QuadPart)/f > sTimeout,
				false);

			Sleep(_msCycle);
		}

		scg.SetAndEnable(std::bind(&ITSCAS::Unlock, this));
		return true;
	}
	inline void		Unlock()
	{
		ITSCAS_UNLOCK_INTERNAL(_v);
	}
	inline void		LockDying()
	{
		// Lock
		while(ITSCAS_TRYLOCKEDNOTDYING_INTERNAL(_v))
		{
			Sleep(_msCycle);
		}
	}
};


#undef ITSCAS_SLEEPCYCLE
#undef ITSCAS_INIT_INTERNAL

#undef ITSCAS_TRYLOCK_INTERNAL
#undef ITSCAS_TRYLOCKED_INTERNAL
#undef ITSCAS_TRYLOCKEDNOT_INTERNAL
#undef ITSCAS_UNLOCK_INTERNAL
#undef ITSCAS_TRYLOCKDYING_INTERNAL
#undef ITSCAS_TRYLOCKEDNOTDYING_INTERNAL

#pragma endregion ThreadSafe


#pragma region Lock
/************************
 Lock
*************************/
// cas_lock
// base_lock
// its_lock
// naive_lock
// count_lock
// single_lock
// icrwb_lock

enum LOCK_RET
{
	LOCK_ABORT			= -5,
	LOCK_MISMATCH		= -4,
	LOCK_INVSTATUS		= -3,// Not locked
	LOCK_TIMEOUT		= -2,
	LOCK_INTERNALERR	= -1,
	LOCK_OCCUPIED		= 0,
	LOCK_SUCCEED		= 1
};


#define LOCK_INFINITE_RES			(-1)
#define LOCK_INFINITE_RES_ACTUAL	(INT_MAX)

#define LOCK_TRYLOCK_INTERNAL			its_t::TryLock()
#define LOCK_UNLOCK_INTERNAL			its_t::Unlock();

#define LOCK_LOCKSCG_INTERNAL			scope_guard scgLock;\
										its_t::LockGuard(scgLock);
#define LOCK_LOCKTIMESCG_INTERNAL(TO, RET)	scope_guard scgLock;\
											bool bInfiniteTimeout = LOCK_TIME_ISINFINITE(TO);\
											RET = (bInfiniteTimeout ? its_t::LockGuard(scgLock) : its_t::LockGuard(scgLock, TO));
#define LOCK_LOCKOTHERSCG_INTERNAL(O)	scope_guard scgLockOther;\
										(O).its_t::LockGuard(scgLockOther);
#define LOCK_UNLOCKSCG_INTERNAL			scgLock.Release();
#define LOCK_UNLOCKOTHERSCG_INTERNAL	scgLockOther.Release();

#define LOCK_LOCKDYING_INTERNAL			its_t::LockDying();

#define LOCK_CHECK_TRYLOCK_INTERNAL		RETVAL_ON_FALSE(\
											its_t::TryLock(),\
											LOCK_RET::LOCK_INTERNALERR);
#define LOCK_CHECK_LOCKED(S)		RETVAL_ON_TRUE_AND(\
										(S),\
										LOCK_RET::LOCK_INVSTATUS,\
										LOCK_UNLOCK_INTERNAL);
#define LOCK_CHECK_LOCKEDSCG(S)		RETVAL_ON_TRUE(\
										(S),\
										LOCK_RET::LOCK_INVSTATUS);
#define LOCK_CHECK_FREE(S)			RETVAL_ON_TRUE_AND(\
										(S),\
										LOCK_RET::LOCK_OCCUPIED,\
										LOCK_UNLOCK_INTERNAL);
#define LOCK_CHECK_MISMATCH(S)		RETVAL_ON_TRUE_AND(\
										(S),\
										LOCK_RET::LOCK_MISMATCH,\
										LOCK_UNLOCK_INTERNAL);
#define LOCK_CHECK_MISMATCHSCG(S)	RETVAL_ON_TRUE(\
										(S),\
										LOCK_RET::LOCK_MISMATCH);
#define LOCK_CHECK_TIMEOUTSCG(T, L)	RETVAL_ON_TRUE(\
										(T) >= (L),\
										LOCK_RET::LOCK_TIMEOUT);

typedef ITSCAS		lock_its_t;// ITSSingle, ITSCAS


/*
 Cas lock
*/

typedef ITSCAS	cas_lock;

//#define CASLOCK_TRYLOCK_INTERNAL		ITSCAS::TryLock()
//#define CASLOCK_LOCK_INTERNAL			ITSCAS::Lock();
//#define CASLOCK_UNLOCK_INTERNAL			ITSCAS::Unlock();
//#define CASLOCK_CLEAR_INTERNAL			CASLOCK_UNLOCK_INTERNAL
//#define CASLOCK_ASSIGN_INTERNAL(lck)	DO_SOMETHING();
//
//class cas_lock : public ITSCAS
//{
//protected:
//protected:
//	LFCTYPE void	ClearPreAssign()
//	{
//	}
//	LFCTYPE void	ClearMove()
//	{
//		CASLOCK_CLEAR_INTERNAL;
//	}
//	void			Release()
//	{
//	}
//private:
//	cas_lock(cas_lock &);
//	cas_lock&	operator = (cas_lock &);
//public:
//	cas_lock():
//		ITSCAS		()
//	{
//	}
//	cas_lock(cas_lock &&lock):
//		ITSCAS		()
//	{
//	}
//	virtual			~cas_lock() OVERRIDE
//	{
//	}
//
//	//int				AssignMove(its_lock &);
//	cas_lock&		operator = (cas_lock &&lock)
//	{
//		return *this;
//	}
//
//#pragma region Interface
//
//	virtual inline bool	IsLocked()
//	{
//		return ITSCAS::IsLocked();
//	}
//	virtual inline bool	TryLock()
//	{
//		//Ticker t;
//		//t.Start();
//		bool rs = CASLOCK_TRYLOCK_INTERNAL;
//		
//		//double tc = t.Tick();
//		//Logger::Log0("CAS Trylock ms: " + to_string(tc*1000));
//		return rs;
//	}
//	int	TryLockGuard(scope_guard &scg)
//	{
//		Ticker ticker;
//		ticker.Start();
//		bool rs = CASLOCK_TRYLOCK_INTERNAL;
//		double tc = ticker.Tick();
//		RET_ON_FALSE_AND(
//			rs,
//			Logger::Log0("Trylock CAS failed, ms: " + to_string(tc*1000)););
//		
//		Logger::Log0("Trylock CAS ms: " + to_string(tc*1000));
//
//		scg.SetAndEnable(
//			[this](){
//				UnLock();
//			});
//
//		return rs;
//	}
//	int	LockGuard(scope_guard &scg)
//	{
//		int ret = Lock();
//		RET_ON_NP_AND(
//			ret,
//			Logger::Log0("Lock failed CAS, ret:" + to_string(ret)););
//	
//		//Logger::Log0("Lock CAS");
//
//		scg.SetAndEnable(
//			[this]()
//			{
//				UnLock();
//			});
//
//		return ret;
//	}
//	virtual int	LockCycleGuard(
//		scope_guard &scg, ms_t1 msTimeout,
//		const function<bool()> &funcAbort = function<bool()>())
//	{
//		const sec_t sTimeout = MS_TO_SEC(msTimeout);
//		bool bInfiniteTimeout = LOCK_TIME_ISINFINITE(msTimeout);
//		Ticker ticker;
//		ticker.Start();
//
//		int ret = LOCK_RET::LOCK_INTERNALERR;
//		while(true)
//		{
//			int ret = TryLock();
//
//			// Check lock succeed
//			BREAK_ON_POS(
//				ret);
//
//			// Check internal lock failure
//			RET_ON_NP(
//				ret);
//
//			// Check abort
//			if(!funcAbort._Empty())
//			{
//				RETVAL_ON_TRUE(
//					funcAbort(),
//					LOCK_RET::LOCK_ABORT);
//			}
//			
//			// Timeout
//			if(!bInfiniteTimeout)
//			{
//				LOCK_CHECK_TIMEOUTSCG(ticker.Tick(), (double)msTimeout/1000);
//			}
//
//			Sleep(LOCK_SLEEPCYCLE);
//		}
//
//		scg.SetAndEnable(
//			[this]()
//			{
//				UnLock();
//			});
//
//		return ret;
//	}
//	virtual inline int	Lock()
//	{
//		CASLOCK_LOCK_INTERNAL;
//		return LOCK_RET::LOCK_SUCCEED;
//	}
//	virtual inline int	TryUnLock()
//	{
//		CASLOCK_UNLOCK_INTERNAL;
//		return LOCK_RET::LOCK_SUCCEED;
//	}
//	virtual inline int	UnLock()
//	{
//		CASLOCK_UNLOCK_INTERNAL;
//		return LOCK_RET::LOCK_SUCCEED;
//	}
//
//#pragma endregion Interface
//};
//
//#undef CASLOCK_TRYLOCK_INTERNAL
//#undef CASLOCK_LOCK_INTERNAL
//#undef CASLOCK_UNLOCK_INTERNAL
//#undef CASLOCK_CLEAR_INTERNAL
//#undef CASLOCK_ASSIGN_INTERNAL


enum LOCK_MODE
{
	LKM_LOCK	= 1,
	LKM_BLOCK	= 2,
	LKM_WRITE	= 3,
	LKM_READ	= 4,
	LKM_IREAD	= 5
};

/*
 Base lock
*/
class base_lock : public lock_its_t
{
protected:
	typedef lock_its_t	its_t;
public:
	typedef __int64		tid_t;
protected:
	LFCTYPE void	ClearPreAssign(){}
	LFCTYPE void	ClearMove(){}
	void			Release(){}
private:
	base_lock(base_lock &);
	base_lock&	operator = (base_lock &);
public:
	base_lock():
		its_t			(){}
	base_lock(base_lock &&lock):
		its_t			(){}
	virtual			~base_lock(){}

	int				AssignMove(base_lock &);
	base_lock&		operator = (base_lock &&lock);
	
#pragma region Interface
	
	virtual inline bool	IsLocked() PURE;

	virtual inline int	TryLock() PURE;
	virtual inline int	Lock(ms_t1 msTimeout = LOCK_TIME_INFINITE) PURE;
	virtual inline int	TryUnLock() PURE;
	virtual inline int	UnLock() PURE;
	virtual int	LockGuard(scope_guard &scg, ms_t1 msTimeout = LOCK_TIME_INFINITE);
	int	TryLockGuard(scope_guard &scg)
	{
		//Ticker ticker;
		//ticker.Start();
		int ret = TryLock();
		//double tc = ticker.Tick();
		RET_ON_NP_AND(
			ret,
			Logger::Log0("Trylock Base failed, ret:" + to_string(ret)););
		//Logger::Log0("Trylock Base ms: " + to_string(tc*1000));

		scg.SetAndEnable(
			[this](){
				UnLock();
			});

		return LOCK_RET::LOCK_SUCCEED;
	}

	virtual int	LockCycleGuard(
		scope_guard &scg, ms_t1 msTimeout,
		const function<bool()> &funcAbort = function<bool()>())
	{
		const sec_t sTimeout = MS_TO_SEC(msTimeout);
		bool bInfiniteTimeout = LOCK_TIME_ISINFINITE(msTimeout);

		Ticker ticker;
		ticker.Start();

		int ret = LOCK_RET::LOCK_INTERNALERR;
		while(true)
		{
			int ret = TryLock();

			// Check internal lock failure
			RET_ON_NP(
				ret);

			// Check lock succeed
			BREAK_ON_POS(
				ret);

			// Check abort
			if(!funcAbort._Empty())
			{
				RETVAL_ON_TRUE(
					funcAbort(),
					LOCK_RET::LOCK_ABORT);
			}
			
			// Timeout
			if(!bInfiniteTimeout)
			{
				LOCK_CHECK_TIMEOUTSCG(ticker.Tick(), sTimeout);
			}

			Sleep(LOCK_SLEEPCYCLE);
		}
		double tc = ticker.Tick();
		Logger::Log0("Lock Base ms: " + to_string(tc*1000));

		scg.SetAndEnable(
			[this]()
			{
				UnLock();
			});

		return LOCK_RET::LOCK_SUCCEED;
	}

#pragma endregion Interface
};

/*
 ITS lock
*/

//#define ITS_LOCK
#ifdef ITS_LOCK

#define ITSLOCK_TRYLOCK_INTERNAL		its_t::TryLock()
#define ITSLOCK_LOCK_INTERNAL(TO, RET)	bool bInfiniteTimeout = LOCK_TIME_ISINFINITE(TO);\
										RET = (bInfiniteTimeout ? its_t::Lock() : its_t::Lock(TO));
#define ITSLOCK_UNLOCK_INTERNAL			its_t::Unlock();
#define ITSLOCK_CLEAR_INTERNAL			LOCK_UNLOCK_INTERNAL
#define ITSLOCK_ASSIGN_INTERNAL(lck)	DO_SOMETHING(\
											_tid		= lck._tid;\
											_bLocked	= lck._bLocked;\
										);
class its_lock : public base_lock
{
protected:
protected:
	LFCTYPE void	ClearPreAssign()
	{
	}
	LFCTYPE void	ClearMove()
	{
		ITSLOCK_CLEAR_INTERNAL;
	}
	void			Release();
private:
	its_lock(its_lock &);
	its_lock&	operator = (its_lock &);
public:
	its_lock():
		base_lock		()
	{
	}
	its_lock(its_lock &&lock):
		base_lock		()
	{
	}
	virtual			~its_lock() OVERRIDE
	{
		LOCK_LOCKDYING_INTERNAL;
	}

	//int				AssignMove(its_lock &);
	its_lock&		operator = (its_lock &&lock)
	{
		return *this;
	}

#pragma region Interface

	virtual inline bool	IsLocked() OVERRIDE
	{
		return true;
	}
	virtual inline int	TryLock() OVERRIDE
	{
		//Ticker t;
		//t.Start();
		int ret = ITSLOCK_TRYLOCK_INTERNAL ? LOCK_RET::LOCK_SUCCEED : LOCK_RET::LOCK_OCCUPIED;
		
		//double tc = t.Tick();
		//Logger::Log0("ITS Trylock ms: " + to_string(tc*1000));
		return ret;
	}
	int	TryLockGuard(scope_guard &scg)
	{
		Ticker ticker;
		ticker.Start();
		int ret = ITSLOCK_TRYLOCK_INTERNAL ? LOCK_RET::LOCK_SUCCEED : LOCK_RET::LOCK_OCCUPIED;
		double tc = ticker.Tick();
		RET_ON_NP_AND(
			ret,
			Logger::Log0("Trylock failed, ret:" + to_string(ret) + ", ms: " + to_string(tc*1000)););
		
		//Logger::Log0("Trylock ITS ms: " + to_string(tc*1000));

		scg.SetAndEnable(
			[this](){
				UnLock();
			});

		return ret;
	}
	virtual inline int	Lock(ms_t1 msTimeout = LOCK_TIME_INFINITE) OVERRIDE
	{
		bool ret = false;
		ITSLOCK_LOCK_INTERNAL(msTimeout, ret);
		RETVAL_ON_FALSE(
			ret,
			LOCK_RET::LOCK_TIMEOUT);

		return LOCK_RET::LOCK_SUCCEED;
	}
	virtual inline int	TryUnLock() OVERRIDE
	{
		ITSLOCK_UNLOCK_INTERNAL;
		return LOCK_RET::LOCK_SUCCEED;
	}
	virtual inline int	UnLock() OVERRIDE
	{
		ITSLOCK_UNLOCK_INTERNAL;
		return LOCK_RET::LOCK_SUCCEED;
	}

#pragma endregion Interface
};

#undef ITSLOCK_TRYLOCK_INTERNAL
#undef ITSLOCK_LOCK_INTERNAL
#undef ITSLOCK_UNLOCK_INTERNAL
#undef ITSLOCK_CLEAR_INTERNAL
#undef ITSLOCK_ASSIGN_INTERNAL

#endif

/*
 Naive lock
*/
#define NAIVELOCK_LOCK_INTERNAL		DO_SOMETHING(\
										_tid = (tid_t)GET_TID;\
										_bLocked = true;\
									);
#define NAIVELOCK_UNLOCK_INTERNAL	DO_SOMETHING(\
										_bLocked = false;\
										_tid = INVALID_TID;\
									);
#define NAIVELOCK_CLEAR_INTERNAL	NAIVELOCK_UNLOCK_INTERNAL
#define NAIVELOCK_ASSIGN_INTERNAL(lck)	DO_SOMETHING(\
										_tid		= lck._tid;\
										_bLocked	= lck._bLocked;\
									);
class naive_lock : public base_lock
{
protected:
	volatile tid_t		_tid;
	volatile bool		_bLocked;

protected:
	LFCTYPE void	ClearPreAssign()
	{
	}
	LFCTYPE void	ClearMove()
	{
		NAIVELOCK_CLEAR_INTERNAL;
	}
	void			Release()
	{
	}
private:
	naive_lock(naive_lock &);
	naive_lock&	operator = (naive_lock &);
public:
	naive_lock();
	naive_lock(naive_lock &&lock);
	virtual			~naive_lock() OVERRIDE;

	int				AssignMove(naive_lock &);
	naive_lock&		operator = (naive_lock &&lock);

#pragma region Interface

	virtual inline bool	IsLocked() OVERRIDE
	{
		return _bLocked;
	}
	virtual inline int	TryLock() OVERRIDE
	{
		// Try lock internal
		LOCK_CHECK_TRYLOCK_INTERNAL;

		// If already locked
		LOCK_CHECK_FREE(_bLocked);

		// Lock
		NAIVELOCK_LOCK_INTERNAL;

		// Unlock internal
		LOCK_UNLOCK_INTERNAL;

		return LOCK_RET::LOCK_SUCCEED;
	}
	virtual inline int	Lock(ms_t1 msTimeout = LOCK_TIME_INFINITE) OVERRIDE;
	virtual inline int	TryUnLock() OVERRIDE
	{
		// Try lock internal
		LOCK_CHECK_TRYLOCK_INTERNAL;

		// If not locked
		LOCK_CHECK_LOCKED(!_bLocked);

		// Check thread ID
		LOCK_CHECK_MISMATCH((tid_t)GET_TID != _tid);

		// Unlock
		NAIVELOCK_UNLOCK_INTERNAL;
		
		// Unlock internal
		LOCK_UNLOCK_INTERNAL;

		return LOCK_RET::LOCK_SUCCEED;
	}
	virtual inline int	UnLock() OVERRIDE;

#pragma endregion Interface
};

/*
 Count lock
*/
#define COUNTLOCK_DEFAULT_RES			(10)

#define COUNTLOCK_FULL_INTERNAL			(_nLock >= _nRes)
#define COUNTLOCK_AVAILABLE_INTERNAL(tid)	(_nLock < _nRes &&\
											((_nLock > 0 && tid == _tid) ||\
											(_nLock == 0)))
#define COUNTLOCK_EMPTY_INTERNAL		(_nLock <= 0)
#define COUNTLOCK_LOCK_INTERNAL(tid)	DO_SOMETHING(\
											if(_nLock == 0){\
												_tid = tid;\
											}\
											++_nLock;)
#define COUNTLOCK_UNLOCK_INTERNAL		DO_SOMETHING(\
											--_nLock;\
											if(_nLock == 0){\
												_tid = INVALID_TID;\
											})
#define COUNTLOCK_CLEAR_INTERNAL		DO_SOMETHING(\
											_nLock = 0;\
											_tid = INVALID_TID;)
#define COUNTLOCK_ASSIGN_INTERNAL(lck)	DO_SOMETHING(\
											_nRes		= lck._nRes;\
											_tid		= lck._tid;\
											_nLock		= lck._nLock;)
class count_lock : public base_lock
{
protected:
	int					_nRes;

	volatile tid_t		_tid;
	volatile int		_nLock;

protected:
	LFCTYPE void	ClearPreAssign()
	{
	}
	LFCTYPE void	ClearMove()
	{
		COUNTLOCK_CLEAR_INTERNAL;
	}
	void			Release()
	{
	}
private:
	count_lock(count_lock &);
	count_lock&	operator = (count_lock &);
public:
	count_lock();
	count_lock(count_lock &&lock);
	virtual			~count_lock() OVERRIDE;

	int				AssignMove(count_lock &);
	count_lock&		operator = (count_lock &&lock);

#pragma region Interface

	virtual inline bool	IsLocked() OVERRIDE
	{
		return _nLock > 0;
	}
	inline bool		SetResource(int nRes)
	{
		if(LOCK_INFINITE_RES == nRes)
		{
			_nRes = LOCK_INFINITE_RES_ACTUAL;
			return true;
		}
		else if(nRes < 0)
		{
			return false;
		}

		_nRes = nRes;

		return true;
	}
	virtual inline int	TryLock() OVERRIDE
	{
		// Try lock internal
		LOCK_CHECK_TRYLOCK_INTERNAL;

		// If full locked
		LOCK_CHECK_FREE(COUNTLOCK_FULL_INTERNAL);

		// Check thread ID
		tid_t tid = (tid_t)GET_TID;
		if(_nLock > 0)
		{
			// Check thread ID
			LOCK_CHECK_MISMATCH(tid != _tid);
		}

		// Lock
		COUNTLOCK_LOCK_INTERNAL(tid);

		// Unlock internal
		LOCK_UNLOCK_INTERNAL;

		return LOCK_RET::LOCK_SUCCEED;
	}
	virtual inline int	Lock(ms_t1 msTimeout = LOCK_TIME_INFINITE) OVERRIDE;
	virtual inline int	TryUnLock() OVERRIDE
	{
		// Try lock internal
		LOCK_CHECK_TRYLOCK_INTERNAL;

		// If not locked
		LOCK_CHECK_LOCKED(COUNTLOCK_EMPTY_INTERNAL);

		// Check thread ID
		LOCK_CHECK_MISMATCH((tid_t)GET_TID != _tid);

		// Unlock
		COUNTLOCK_UNLOCK_INTERNAL;
		
		// Unlock internal
		LOCK_UNLOCK_INTERNAL;

		return LOCK_RET::LOCK_SUCCEED;
	}
	virtual inline int	UnLock() OVERRIDE;

#pragma endregion Interface
};

/*
 Single lock
*/
#ifdef SINGLE_LOCK

class single_lock : public base_lock
{
protected:
	// Main lock
	CRITICAL_SECTION	_section;// follow LifeCycle member(move & create new, destroy in dtor)
	bool				_bLocked;

protected:
	LFCTYPE void	ClearPreAssign()
	{
		DeleteCriticalSection(&_section);
		SecureZeroMemory(&_section, sizeof(CRITICAL_SECTION));
	}
	LFCTYPE void	ClearMove()
	{
		_bLocked = false;
		SecureZeroMemory(&_section, sizeof(CRITICAL_SECTION));

		// Recreate Lifecycle member
		InitializeCriticalSection(&_section);
	}
	void			Release()
	{
		// Lock dying
		LOCK_LOCKDYING_INTERNAL;

		single_lock::ClearPreAssign();
	}
private:
	single_lock(single_lock &);
	single_lock&	operator = (single_lock &);
public:
	single_lock();
	single_lock(single_lock &&);
	virtual			~single_lock() OVERRIDE;

	int				AssignMove(single_lock &);
	single_lock&	operator = (single_lock &&);

#pragma region Interface

	inline bool		IsLocked()
	{
		return _bLocked;
	}
	virtual inline int	TryLock() OVERRIDE
	{
		// Try lock internal
		LOCK_CHECK_TRYLOCK_INTERNAL;

		// Try lock
		RET_ON_ZERO_AND(
			TryEnterCriticalSection(&_section),
			LOCK_UNLOCK_INTERNAL);
		
		_bLocked = true;
		
		// Unlock internal
		LOCK_UNLOCK_INTERNAL;

		return LOCK_RET::LOCK_SUCCEED;
	}
	virtual inline int	Lock(ms_t1 msTimeout = LOCK_TIME_INFINITE) OVERRIDE;
	virtual inline int	TryUnLock() OVERRIDE
	{
		// Try lock internal
		LOCK_CHECK_TRYLOCK_INTERNAL;

		// If not locked
		LOCK_CHECK_LOCKED(!_bLocked);

		// Unlock
		LeaveCriticalSection(&_section);
		_bLocked = false;
		
		// Unlock internal
		LOCK_UNLOCK_INTERNAL;

		return LOCK_RET::LOCK_SUCCEED;
	}
	virtual inline int	UnLock() OVERRIDE;

#pragma endregion Interface
};

#endif


/*
 Read-Write-Block lock
*/
#define RWBLOCK_STATUS_LOCK		0x01
#define RWBLOCK_STATUS_IREAD	0x02
#define RWBLOCK_STATUS_READ		0x04
#define RWBLOCK_STATUS_WRITE	0x08
#define RWBLOCK_STATUS_BLOCK	0x10
#define RWBLOCK_STATUS_ISLOCKED(status)		(((status) & RWBLOCK_STATUS_LOCK) != 0)
#define RWBLOCK_STATUS_NOTLOCKED(status)	(((status) & RWBLOCK_STATUS_LOCK) == 0)
#define RWBLOCK_STATUS_IREADLOCKED(status)	(((status) & RWBLOCK_STATUS_IREAD) != 0)
#define RWBLOCK_STATUS_NOTIREADLOCKED(status)	(((status) & RWBLOCK_STATUS_IREAD) == 0)
#define RWBLOCK_STATUS_READLOCKED(status)	(((status) & RWBLOCK_STATUS_READ) != 0)
#define RWBLOCK_STATUS_NOTREADLOCKED(status)	(((status) & RWBLOCK_STATUS_READ) == 0)
#define RWBLOCK_STATUS_WRITELOCKED(status)	(((status) & RWBLOCK_STATUS_WRITE) != 0)
#define RWBLOCK_STATUS_NOTWRITELOCKED(status)	(((status) & RWBLOCK_STATUS_WRITE) == 0)
#define RWBLOCK_STATUS_BLOCKLOCKED(status)	(((status) & RWBLOCK_STATUS_BLOCK) != 0)
#define RWBLOCK_STATUS_NOTBLOCKLOCKED(status)	(((status) & RWBLOCK_STATUS_BLOCK) == 0)
enum RWBLOCK_STATUS
{
	RWB_UNLOCK		= 0,
	RWB_IREAD		= RWBLOCK_STATUS_LOCK | RWBLOCK_STATUS_IREAD,
	RWB_READ		= RWBLOCK_STATUS_LOCK | RWBLOCK_STATUS_READ,
	RWB_WRITE		= RWBLOCK_STATUS_LOCK | RWBLOCK_STATUS_WRITE,
	RWB_BLOCK		= RWBLOCK_STATUS_LOCK | RWBLOCK_STATUS_BLOCK,
	RWB_IREADWRITE	= RWBLOCK_STATUS_LOCK | RWBLOCK_STATUS_IREAD | RWBLOCK_STATUS_WRITE,
	RWB_IREADREAD	= RWBLOCK_STATUS_LOCK | RWBLOCK_STATUS_IREAD | RWBLOCK_STATUS_READ
};


#define RWBLOCK_DEFAULT_RES				(10)

// Locked status
#define RWBLOCK_LOCKCOUNTIREAD				(_nLockIR)
#define RWBLOCK_LOCKCOUNTREAD				(_nLockR)
#define RWBLOCK_LOCKED_INTERNAL				(RWBLOCK_STATUS_ISLOCKED(_status))
#define RWBLOCK_NOTLOCKED_INTERNAL			(RWBLOCK_STATUS_NOTLOCKED(_status))
#define RWBLOCK_LOCKEDIREAD_INTERNAL		(RWBLOCK_STATUS_IREADLOCKED(_status))
#define RWBLOCK_NOTLOCKEDIREAD_INTERNAL		(RWBLOCK_STATUS_NOTIREADLOCKED(_status))
#define RWBLOCK_LOCKEDREAD_INTERNAL			(RWBLOCK_STATUS_READLOCKED(_status))
#define RWBLOCK_NOTLOCKEDREAD_INTERNAL		(RWBLOCK_STATUS_NOTREADLOCKED(_status))
#define RWBLOCK_LOCKEDWRITE_INTERNAL		(RWBLOCK_STATUS_WRITELOCKED(_status))
#define RWBLOCK_NOTLOCKEDWRITE_INTERNAL		(RWBLOCK_STATUS_NOTWRITELOCKED(_status))
#define RWBLOCK_LOCKEDBLOCK_INTERNAL		(RWBLOCK_STATUS_BLOCKLOCKED(_status))
#define RWBLOCK_NOTLOCKEDBLOCK_INTERNAL		(RWBLOCK_STATUS_NOTBLOCKLOCKED(_status))

// Full locked
#define RWBLOCK_FULLLOCKEDIREAD_INTERNAL	( RWBLOCK_LOCKEDBLOCK_INTERNAL ||\
											((RWBLOCK_LOCKEDIREAD_INTERNAL) &&\
											(RWBLOCK_LOCKCOUNTIREAD >= _nRes)) )
#define RWBLOCK_FULLLOCKEDREAD_INTERNAL		( RWBLOCK_LOCKEDBLOCK_INTERNAL ||\
											RWBLOCK_LOCKEDWRITE_INTERNAL ||\
											(RWBLOCK_LOCKEDREAD_INTERNAL &&\
											(RWBLOCK_LOCKCOUNTREAD >= _nRes)) )
#define RWBLOCK_FULLLOCKEDWRITE_INTERNAL	( RWBLOCK_LOCKEDBLOCK_INTERNAL ||\
											RWBLOCK_LOCKEDWRITE_INTERNAL ||\
											RWBLOCK_LOCKEDREAD_INTERNAL)
#define RWBLOCK_FULLLOCKEDBLOCK_INTERNAL	( RWBLOCK_LOCKED_INTERNAL)

// Set
#define RWBLOCK_SETTID_INTERNAL			_tid = (tid_t)GET_TID;
#define RWBLOCK_RESETTID_INTERNAL		_tid = INVALID_TID;
// status TODO
#define RWBLOCK_SETSTATUS_INTERNAL(S)		_status = (S);
#define RWBLOCK_SETSTATUS_IREAD_INTERNAL	_status = (RWBLOCK_STATUS)(_status | RWBLOCK_STATUS::RWB_IREAD);
#define RWBLOCK_SETSTATUS_READ_INTERNAL		_status = (RWBLOCK_STATUS)(_status | RWBLOCK_STATUS::RWB_READ);
#define RWBLOCK_SETSTATUS_WRITE_INTERNAL	_status = (RWBLOCK_STATUS)(_status | RWBLOCK_STATUS::RWB_WRITE);
#define RWBLOCK_SETSTATUS_UNIREAD_INTERNAL	if(_nLockIR <= 0){\
												if(RWBLOCK_LOCKEDWRITE_INTERNAL){\
													_status = RWBLOCK_STATUS::RWB_WRITE;}\
												else if(RWBLOCK_LOCKEDREAD_INTERNAL){\
													_status = RWBLOCK_STATUS::RWB_READ;}\
												else{\
													_status = RWBLOCK_STATUS::RWB_UNLOCK;}\
											}
#define RWBLOCK_SETSTATUS_UNREAD_INTERNAL	if(_nLockR <= 0){\
												if(RWBLOCK_LOCKEDIREAD_INTERNAL){\
													_status = RWBLOCK_STATUS::RWB_IREAD;}\
												else{\
													_status = RWBLOCK_STATUS::RWB_UNLOCK;}\
											}
#define RWBLOCK_SETSTATUS_UNWRITE_INTERNAL	if(RWBLOCK_LOCKEDIREAD_INTERNAL){\
												_status = RWBLOCK_STATUS::RWB_IREAD;}\
											else{\
												_status = RWBLOCK_STATUS::RWB_UNLOCK;}
#define RWBLOCK_SETSTATUS_UNBLOCK_INTERNAL	_status = RWBLOCK_STATUS::RWB_UNLOCK;

// Lock Internal
#define RWBLOCK_LOCKIREAD_INTERNAL		DO_SOMETHING(\
											++_nLockIR;\
											tid_t tid = (tid_t)GET_TID;\
											++_mapLockIR[tid];\
											RWBLOCK_SETSTATUS_IREAD_INTERNAL;)
#define RWBLOCK_LOCKREAD_INTERNAL		DO_SOMETHING(\
											++_nLockR;\
											tid_t tid = (tid_t)GET_TID;\
											++_mapLockR[tid];\
											RWBLOCK_SETSTATUS_READ_INTERNAL;)
#define RWBLOCK_LOCKWRITE_INTERNAL		DO_SOMETHING(\
											RWBLOCK_SETTID_INTERNAL;\
											RWBLOCK_SETSTATUS_WRITE_INTERNAL;)
#define RWBLOCK_LOCKBLOCK_INTERNAL		DO_SOMETHING(\
											RWBLOCK_SETTID_INTERNAL;\
											RWBLOCK_SETSTATUS_INTERNAL(RWBLOCK_STATUS::RWB_BLOCK);)
// Unlock Internal
#define RWBLOCK_UNLOCKIREAD_INTERNAL(IR)	DO_SOMETHING(\
											--_nLockIR;\
											--((IR)->second);\
											RWBLOCK_SETSTATUS_UNIREAD_INTERNAL;)
#define RWBLOCK_UNLOCKREAD_INTERNAL(R)		DO_SOMETHING(\
											--_nLockR;\
											--((R)->second);\
											RWBLOCK_SETSTATUS_UNREAD_INTERNAL;)
#define RWBLOCK_UNLOCKWRITE_INTERNAL	DO_SOMETHING(\
											RWBLOCK_RESETTID_INTERNAL;\
											RWBLOCK_SETSTATUS_UNWRITE_INTERNAL;)
#define RWBLOCK_UNLOCKBLOCK_INTERNAL	DO_SOMETHING(\
											RWBLOCK_RESETTID_INTERNAL;\
											RWBLOCK_SETSTATUS_UNBLOCK_INTERNAL;)

class icrwb_lock : public base_lock
{
public:
	typedef unordered_map<tid_t, int>	rmap;
	typedef __int64						nlock;
protected:
	RWBLOCK_STATUS		_status;
	nlock				_nRes;


	tid_t				_tid;

	nlock				_nLockR;
	rmap				_mapLockR;

	nlock				_nLockIR;
	rmap				_mapLockIR;

protected:
	LFCTYPE void	ClearPreAssign()
	{
	}
	LFCTYPE void	ClearMove()
	{
		_status = RWBLOCK_STATUS::RWB_UNLOCK;
		//_nRes;
		_tid	= INVALID_TID;
		_nLockIR = 0;
	}
	void			Release()
	{
	}
private:
	icrwb_lock(icrwb_lock &);
	icrwb_lock&		operator = (icrwb_lock &);
public:
	icrwb_lock();
	icrwb_lock(icrwb_lock &&lock);
	virtual			~icrwb_lock() OVERRIDE;

	int				AssignMove(icrwb_lock &);
	icrwb_lock&		operator = (icrwb_lock &&lock);

#pragma region Interface

	// Is r/w locked
	virtual inline bool	IsLocked() OVERRIDE
	{
		return RWBLOCK_LOCKED_INTERNAL;
	}
	inline bool		SetResource(int nRes)
	{
		if(LOCK_INFINITE_RES == nRes)
		{
			_nRes = LOCK_INFINITE_RES_ACTUAL;
			return true;
		}
		else if(nRes < 0)
		{
			return false;
		}

		_nRes = nRes;

		return true;
	}
	virtual inline int	TryLock() OVERRIDE
	{
		// Try lock internal
		LOCK_CHECK_TRYLOCK_INTERNAL;
		
		tid_t tid = (tid_t)GET_TID;
		
		// Check lock free
		LOCK_CHECK_FREE(RWBLOCK_FULLLOCKEDBLOCK_INTERNAL);
		
		// Lock
		RWBLOCK_LOCKBLOCK_INTERNAL;

		// Unlock internal
		LOCK_UNLOCK_INTERNAL;

		return LOCK_RET::LOCK_SUCCEED;
	}
	virtual inline int	TryLockIRead()
	{
		// Try lock internal
		LOCK_CHECK_TRYLOCK_INTERNAL;

		// Check lock free
		LOCK_CHECK_FREE(RWBLOCK_FULLLOCKEDIREAD_INTERNAL);
		
		// Lock
		RWBLOCK_LOCKIREAD_INTERNAL;
		
		// Unlock internal
		LOCK_UNLOCK_INTERNAL;

		return LOCK_RET::LOCK_SUCCEED;
	}
	virtual inline int	TryLockRead()
	{
		// Try lock internal
		LOCK_CHECK_TRYLOCK_INTERNAL;

		// Check lock free
		LOCK_CHECK_FREE(RWBLOCK_FULLLOCKEDREAD_INTERNAL);
		
		// Lock
		RWBLOCK_LOCKREAD_INTERNAL;
		
		// Unlock internal
		LOCK_UNLOCK_INTERNAL;

		return LOCK_RET::LOCK_SUCCEED;
	}
	virtual inline int	TryLockWrite()
	{
		// Try lock internal
		LOCK_CHECK_TRYLOCK_INTERNAL;
		
		// Check lock free
		LOCK_CHECK_FREE(RWBLOCK_FULLLOCKEDWRITE_INTERNAL);

		// Lock
		RWBLOCK_LOCKWRITE_INTERNAL;

		// Unlock internal
		LOCK_UNLOCK_INTERNAL;

		return LOCK_RET::LOCK_SUCCEED;
	}
	int	TryLockIReadGuard(scope_guard &scg)
	{
		int ret = TryLockIRead();
		RET_ON_NP(
			ret);

		scg.SetAndEnable(
			[this](){
				UnLockIRead();
			});

		return ret;
	}
	int	TryLockReadGuard(scope_guard &scg)
	{
		int ret = TryLockRead();
		RET_ON_NP(
			ret);

		scg.SetAndEnable(
			[this](){
				UnLockRead();
			});

		return ret;
	}
	int	TryLockWriteGuard(scope_guard &scg)
	{
		int ret = TryLockWrite();
		RET_ON_NP(
			ret);

		scg.SetAndEnable(
			[this](){
				UnLockWrite();
			});

		return ret;
	}
	virtual int	Lock(ms_t1 msTimeout = LOCK_TIME_INFINITE) OVERRIDE;
	virtual int	LockIRead(ms_t1 msTimeout = LOCK_TIME_INFINITE);
	virtual int	LockRead(ms_t1 msTimeout = LOCK_TIME_INFINITE);
	virtual int	LockWrite(ms_t1 msTimeout = LOCK_TIME_INFINITE);

	int icrwb_lock::LockIReadGuard(
		scope_guard &scg, ms_t1 msTimeout = LOCK_TIME_INFINITE);
	int icrwb_lock::LockReadGuard(
		scope_guard &scg, ms_t1 msTimeout = LOCK_TIME_INFINITE);
	int icrwb_lock::LockWriteGuard(
		scope_guard &scg, ms_t1 msTimeout = LOCK_TIME_INFINITE);

	virtual inline int	TryUnLock() OVERRIDE
	{
		// Try lock internal
		LOCK_CHECK_TRYLOCK_INTERNAL;

		// Check locked
		LOCK_CHECK_LOCKED(RWBLOCK_NOTLOCKEDBLOCK_INTERNAL);

		// Check thread ID
		LOCK_CHECK_MISMATCH((tid_t)GET_TID != _tid);

		// Unlock
		RWBLOCK_UNLOCKBLOCK_INTERNAL;
		
		// Unlock internal
		LOCK_UNLOCK_INTERNAL;

		return LOCK_RET::LOCK_SUCCEED;
	}
	virtual inline int	TryUnLockIRead()
	{
		// Try lock internal
		LOCK_CHECK_TRYLOCK_INTERNAL;
		
		// Check locked
		LOCK_CHECK_LOCKED(RWBLOCK_NOTLOCKEDIREAD_INTERNAL);

		tid_t tid = (tid_t)GET_TID;
		rmap::iterator itr = _mapLockIR.find(tid);
		// Check thread ID
		LOCK_CHECK_MISMATCH(_mapLockIR.end() == itr);
		LOCK_CHECK_MISMATCH(itr->second <= 0);

		// Unlock
		RWBLOCK_UNLOCKIREAD_INTERNAL(itr);
		
		// Unlock internal
		LOCK_UNLOCK_INTERNAL;

		return LOCK_RET::LOCK_SUCCEED;
	}
	virtual inline int	TryUnLockWrite()
	{
		// Try lock internal
		LOCK_CHECK_TRYLOCK_INTERNAL;
		
		// Check locked
		LOCK_CHECK_LOCKED(RWBLOCK_NOTLOCKEDWRITE_INTERNAL);

		// Check thread ID
		LOCK_CHECK_MISMATCH((tid_t)GET_TID != _tid);

		// Unlock
		RWBLOCK_UNLOCKWRITE_INTERNAL;
		
		// Unlock internal
		LOCK_UNLOCK_INTERNAL;

		return LOCK_RET::LOCK_SUCCEED;
	}
	virtual int	UnLock() OVERRIDE;
	virtual int	UnLockIRead();
	virtual int	UnLockRead();
	virtual int	UnLockWrite();

#pragma endregion Interface
};

#pragma region Lock


#pragma region Atomic
/************************
 Atomic
*************************/
#define ATOM_INIT_INTERNAL(v, T)			v = new T();

#define ATOM_CAS_INTERNAL(v, e, u)			CAS(v, e, u)
#define ATOM_CASF_INTERNAL(v, e, u)			CASFAIL(v, e, u)
#define ATOM_CASS_INTERNAL(v, e, u)			CASSUCCEED(v, e, u)
#define ATOM_SET_INTERNAL(v, u)				EXC((v), (u))
#define ATOM_EQU_INTERNAL(v, e)				EQU((v), (e))

#define PURE_ATOM_GET
#ifdef PURE_ATOM_GET
#define ATOM_GET_INTERNAL(v, val)			val		= *(v);
#else
#define ATOM_GET_INTERNAL(v, val)			val		= *(v);\
											while(!ATOM_EQU_INTERNAL(v, val)){\
												val		= *(v);}
#endif

#define ATOM_TYPEAT_INTERNAL(vv, T)				*((T*)(&vv))
#define ATOM_SETVAL_INTERNAL(vv, val, T)		ATOM_TYPEAT_INTERNAL(vv, T) = val;
#define ATOM_GETVAL_INTERNAL(vv, val, T)		val = ATOM_TYPEAT_INTERNAL(vv, T);

template<class T, typename = typename enable_if_pod8<T>::type>
class atom8
{
protected:
	typedef unsigned __int64	cas_t;

protected:
	volatile cas_t*		_obj;

protected:
	LFCTYPE void	ClearPreAssign();
	LFCTYPE void	ClearMove();
	void			Release()
	{
		SAFE_DELETE(_obj);
	}
public:
	atom8():
		_obj		(nullptr)
	{
		ATOM_INIT_INTERNAL(_obj, cas_t);
	}
	atom8(T vT):
		_obj		(nullptr)
	{
		ATOM_INIT_INTERNAL(_obj, cas_t);

		cas_t vO = cas_t();
		ATOM_SETVAL_INTERNAL(vO, vT, T);

		ATOM_SET_INTERNAL(_obj, vO);
	}
	atom8(const atom8 &atm):
		_obj		(nullptr)
	{
		ATOM_INIT_INTERNAL(_obj, cas_t);

		Assign(atm);
	}
	~atom8()
	{
		SAFE_DELETE(_obj);
	}

	int				Assign(const atom8 &atm)
	{
		// Get Other obj value
		cas_t vO;
		ATOM_GET_INTERNAL(atm._obj, vO);

		ATOM_SET_INTERNAL(_obj, vO);

		return 1;
	}
	atom8&	operator = (const atom8 &atm)
	{
		Assign(atm);

		return *this;
	}

	int		clear()
	{
		ATOM_SET_INTERNAL(_obj, T());

		return 1;
	}
	
	void	inc()
	{
		// Get obj value
		cas_t vO;
		ATOM_GET_INTERNAL(_obj, vO);

		// Get T value
		T vT;
		ATOM_GETVAL_INTERNAL(vO, vT, T);
		// Increment
		T vTU = vT;
		++vTU;

		// Get obj value of inced
		cas_t vOU	= cas_t();
		ATOM_SETVAL_INTERNAL(vOU, vTU, T);

		while(ATOM_CASF_INTERNAL(_obj, vO, vOU))
		{
			// Get obj value
			ATOM_GET_INTERNAL(_obj, vO);
			
			// Get T value
			ATOM_GETVAL_INTERNAL(vO, vT, T);
			// Increment
			vTU = vT;
			++vTU;

			// Get obj value of inced
			ATOM_SETVAL_INTERNAL(vOU, vTU, T);
		}
	}

	void	dec()
	{
		// Get obj value
		cas_t vO;
		ATOM_GET_INTERNAL(_obj, vO);

		// Get T value
		T vT;
		ATOM_GETVAL_INTERNAL(vO, vT, T);
		// Decrement
		T vTU = vT;
		--vTU;

		// Get obj value of inced
		cas_t vOU	= cas_t();
		ATOM_SETVAL_INTERNAL(vOU, vTU, T);

		while(ATOM_CASF_INTERNAL(_obj, vO, vOU))
		{
			// Get obj value
			ATOM_GET_INTERNAL(_obj, vO);
			
			// Get T value
			ATOM_GETVAL_INTERNAL(vO, vT, T);
			// Decrement
			vTU = vT;
			--vTU;

			// Get obj value of inced
			ATOM_SETVAL_INTERNAL(vOU, vTU, T);
		}
	}
	//T*				operator -> ()
	//{
	//	return &_obj;
	//}
	//T&				operator*()
	//{
	//	return _obj;
	//}
	//const T&		operator*() const
	//{
	//	return _obj;
	//}
	T		get() const
	{
		// Get obj value
		cas_t vO;
		ATOM_GET_INTERNAL(_obj, vO);
		
		// Get T value
		T vT;
		ATOM_GETVAL_INTERNAL(vO, vT, T);

		return vT;
	}
	bool	set(const T &vT)
	{
		cas_t vO = cas_t();
		ATOM_SETVAL_INTERNAL(vO, vT, T);

		// Set and get old value
		cas_t vOOld = ATOM_SET_INTERNAL(_obj, vO);

		// Get old T value
		T vTOld;
		ATOM_GETVAL_INTERNAL(vOOld, vTOld, T);

		return (vTOld != vT);
	}
};

template<>
class atom8<bool>
{
protected:
	typedef unsigned __int64	cas_t;

protected:
	volatile cas_t*		_obj;

protected:
	LFCTYPE void	ClearPreAssign();
	LFCTYPE void	ClearMove();
	void			Release();
public:
	atom8();
	atom8(bool vT);
	atom8(const atom8 &atm);
	~atom8();
	
	int				Assign(atom8 &atm);
	atom8&	operator = (atom8 &atm);

	int Clear();

	void	flip();
	//T*				operator -> ()
	//{
	//	return &_obj;
	//}
	//T&				operator*()
	//{
	//	return _obj;
	//}
	//const T&		operator*() const
	//{
	//	return _obj;
	//}
	bool	get() const;
	bool	set(bool vT);
};



#define ATOM_TRYLOCK_INTERNAL				its_t::TryLock()
#define ATOM_UNLOCK_INTERNAL				its_t::Unlock();

#define ATOM_LOCKSCG_INTERNAL				scope_guard scgLock;\
											its_t::LockGuard(scgLock);
#define ATOM_LOCKTIMESCG_INTERNAL(TO, RET)	scope_guard scgLock;\
											bool bInfiniteTimeout = LOCK_TIME_ISINFINITE(msTimeout);\
											RET = (bInfiniteTimeout ? its_t::LockGuard(scgLock) : its_t::LockGuard(scgLock, TO));
#define ATOM_LOCKOTHERSCG_INTERNAL(O)		scope_guard scgLockOther;\
											(O).its_t::LockGuard(scgLockOther);
#define ATOM_UNLOCKSCG_INTERNAL				scgLock.Release();
#define ATOM_UNLOCKOTHERSCG_INTERNAL		scgLockOther.Release();

#define ATOM_LOCKDYING_INTERNAL				its_t::LockDying();

template<class T>
class atom : protected ITSCAS
{
protected:
	typedef ITSCAS	its_t;
protected:
	volatile T		_obj;

protected:
	LFCTYPE void	ClearPreAssign();
	LFCTYPE void	ClearMove();
	void			Release()
	{
	}
private:
	// Disable copy-ctor, = operator
	atom(atom &atm);
	atom&	operator = (atom &atm);
public:
	atom():
		_obj		()
	{
	}
	atom(const T &vT):
		_obj		()
	{
		// ======>> LOCK <<=======
		ATOM_LOCKSCG_INTERNAL;

		_obj = vT;
	}
	atom(atom &&atm):
		_obj		()
	{
		// Assign
		AssignMove(atm);
	}
	~atom()
	{
	// ======>> LOCK DYING <<=======
		ATOM_LOCKDYING_INTERNAL;
	}

	int				AssignMove(atom &atm)
	{
		// ======>> LOCK OTHER <<=======
		ATOM_LOCKOTHERSCG_INTERNAL(atm);
		// ======>> LOCK <<=======
		ATOM_LOCKSCG_INTERNAL;
		
		// Assign
		_obj = std::forward<atom>(atm._obj);

		return 1;
	}
	atom&	operator = (atom &&atm)
	{
		AssignMove(atm);

		return *this;
	}

	int		clear()
	{
		// ======>> LOCK <<=======
		ATOM_LOCKSCG_INTERNAL;

		_obj = T();

		return 1;
	}

	//T*				operator -> ()
	//{
	//	return &_obj;
	//}
	//T&				operator*()
	//{
	//	return _obj;
	//}
	//const T&		operator*() const
	//{
	//	return _obj;
	//}
	void	inc()
	{
		// ======>> LOCK <<=======
		ATOM_LOCKSCG_INTERNAL;

		_obj = _obj + 1;
	}
	void	dec()
	{
		// ======>> LOCK <<=======
		ATOM_LOCKSCG_INTERNAL;

		_obj = _obj - 1;
	}
	T		get()
	{
		// ======>> LOCK <<=======
		ATOM_LOCKSCG_INTERNAL;

		return _obj;
	}
	T		get(bool &bGot, ms_t1 msTimeout)
	{
		// Init flag
		bGot = false;
		
		// ======>> LOCK <<=======
		bool bInfiniteTimeout = LOCK_TIME_ISINFINITE(msTimeout);
		scope_guard scgLock;
		bool bLock = (bInfiniteTimeout ? its_t::LockGuard(scgLock) : its_t::LockGuard(scgLock, msTimeout));
		RETVAL_ON_FALSE(
			bLock,
			-1);
		
		// Update flag
		bGot = true;

		return _obj;
	}
	int		set(const T &vT)
	{
		// ======>> LOCK <<=======
		ATOM_LOCKSCG_INTERNAL;

		T objOld = _obj;
		_obj = vT;

		return (objOld != vT) ? 1 : 0;
	}
	int		set(const T &vT, ms_t1 msTimeout)
	{
		// ======>> LOCK <<=======
		bool bInfiniteTimeout = LOCK_TIME_ISINFINITE(msTimeout);
		scope_guard scgLock;
		bool bLock = (bInfiniteTimeout ? its_t::LockGuard(scgLock) : its_t::LockGuard(scgLock, msTimeout));
		RETVAL_ON_FALSE(
			bLock,
			-1);

		T objOld = _obj;
		_obj = vT;

		return (objOld != vT) ? 1 : 0;
	}
	int		lock(scope_guard &scgLock, ms_t1 msTimeout)
	{
		// ======>> LOCK <<=======
		bool bInfiniteTimeout = LOCK_TIME_ISINFINITE(msTimeout);
		bool bLock = (bInfiniteTimeout ? its_t::LockGuard(scgLock) : its_t::LockGuard(scgLock, (ms_t)msTimeout));
		RETVAL_ON_FALSE(
			bLock,
			-1);

		return 1;
	}
	template<class T, class R>
	int		execute(const function<R(T*)> &func, R &ret, ms_t1 msTimeout)
	{
		// ======>> LOCK <<=======
		bool bInfiniteTimeout = LOCK_TIME_ISINFINITE(msTimeout);
		scope_guard scgLock;
		bool bLock = (bInfiniteTimeout ? its_t::LockGuard(scgLock) : its_t::LockGuard(scgLock, (ms_t)msTimeout));
		RETVAL_ON_FALSE(
			bLock,
			-1);

		ret = func((T*)&_obj);

		return 1;
	}
	template<class T, class R>
	int		execute(const function<R(const T*)> &func, R &ret, ms_t1 msTimeout) const
	{
		// ======>> LOCK <<=======
		bool bInfiniteTimeout = LOCK_TIME_ISINFINITE(msTimeout);
		scope_guard scgLock;
		bool bLock = (bInfiniteTimeout ? its_t::LockGuard(scgLock) : its_t::LockGuard(scgLock, (ms_t)msTimeout));
		RETVAL_ON_FALSE(
			bLock,
			-1);

		ret = func((const T*)&_obj);

		return 1;
	}
	template<class T>
	int		execute(const function<void(T*)> &func, ms_t1 msTimeout)
	{
		// ======>> LOCK <<=======
		bool bInfiniteTimeout = LOCK_TIME_ISINFINITE(msTimeout);
		scope_guard scgLock;
		bool bLock = (bInfiniteTimeout ? its_t::LockGuard(scgLock) : its_t::LockGuard(scgLock, (ms_t)msTimeout));
		RETVAL_ON_FALSE(
			bLock,
			-1);

		func((T*)&_obj);

		return 1;
	}
};


#define ATOMBOOL_XOR_MASK	0x01

template<>
class atom<bool>
{
public:
	typedef unsigned int	cas_t;

	enum {ATOM_BOOL_FALSE = 0, ATOM_BOOL_TRUE = 1};
private:
	volatile cas_t	*_v;

protected:
	LFCTYPE void	ClearPreAssign();
	LFCTYPE void	ClearMove();
	void			Release();
public:
	atom();
	atom(bool vT);
	atom(const atom &atm);
	~atom();

	int				Assign(const atom &atm);
	atom<bool>&	operator = (const atom &atm);

	int		clear();

	//T*				operator -> ()
	//{
	//	return &_obj;
	//}
	//T&				operator*()
	//{
	//	return _obj;
	//}
	//const T&		operator*() const
	//{
	//	return _obj;
	//}
	void	flip();
	bool	get() const;
	bool	set(bool vT);
	bool	checkandflip(bool chk);
};


//#undef ATOM_INIT_INTERNAL
//
//#undef ATOM_CAS_INTERNAL
//#undef ATOM_CASF_INTERNAL
//#undef ATOM_SET_INTERNAL
//#undef ATOM_EQU_INTERNAL
//#undef ATOM_GET_INTERNAL
//
//#undef ATOM_TYPEAT_INTERNAL
//#undef ATOM_SETVAL_INTERNAL
//#undef ATOM_GETVAL_INTERNAL

#pragma endregion Atomic

#undef _IMGDISP_SOURCE_FILE_LOCK_H
#define _IMGDISP_SOURCE_FILE_LOCK_CPP

#include "pch.h"

#include "lock.h"



/************************
 Lock
*************************/

#pragma region base_lock

int base_lock::AssignMove(base_lock &lck)
{
	return 1;
}

base_lock& base_lock::operator = (base_lock &&lock)
{
	return *this;
}

int base_lock::LockGuard(scope_guard &scg, ms_t1 msTimeout)
{
	int ret = Lock(msTimeout);
	RET_ON_NP_AND(
		ret,
		Logger::Log0("Lock failed In, ret:" + to_string(ret)););
	
	//Logger::Log0("Lock In");

	scg.SetAndEnable(
		[this]()
		{
			UnLock();
		});

	return ret;
}

#pragma endregion base_lock

#pragma region naive_lock

naive_lock::naive_lock():
	base_lock		(),
	_tid			(INVALID_TID),
	_bLocked		(false)
{
}

naive_lock::naive_lock(naive_lock &&lck):
	base_lock		(),
	_tid			(INVALID_TID),
	_bLocked		(false)
{
	// ======>> LOCK OTHER <<=======
	LOCK_LOCKOTHERSCG_INTERNAL(lck);
	// ======>> LOCK <<=======
	LOCK_LOCKSCG_INTERNAL;
	
	// Assign
	base_lock::AssignMove(std::forward<base_lock>(lck));
	NAIVELOCK_ASSIGN_INTERNAL(lck);
	
	// ======>> UNLOCK <<=======
	LOCK_UNLOCKSCG_INTERNAL;
	
	// Clear after move
	lck.naive_lock::ClearMove();
}

naive_lock::~naive_lock()
{
	// ======>> LOCK DYING <<=======
	LOCK_LOCKDYING_INTERNAL;

	_bLocked = false;
	_tid = INVALID_TID;
}

int naive_lock::AssignMove(naive_lock &lck)
{
	// ======>> LOCK OTHER <<=======
	LOCK_LOCKOTHERSCG_INTERNAL(lck);
	// ======>> LOCK <<=======
	LOCK_LOCKSCG_INTERNAL;

	// Clear before assignment
	naive_lock::ClearPreAssign();
	
	// Assign
	base_lock::AssignMove(std::forward<base_lock>(lck));
	NAIVELOCK_ASSIGN_INTERNAL(lck);
	
	// ======>> UNLOCK <<=======
	LOCK_UNLOCKSCG_INTERNAL;
	
	// Clear after move
	lck.naive_lock::ClearMove();

	return LOCK_RET::LOCK_SUCCEED;
}

naive_lock& naive_lock::operator = (naive_lock &&lock)
{
	AssignMove(lock);

	return *this;
}

int naive_lock::Lock(ms_t1 msTimeout)
{
	const sec_t sTimeout = MS_TO_SEC(msTimeout);
	bool bInfiniteTimeout = LOCK_TIME_ISINFINITE(msTimeout);

	Ticker ticker;
	ticker.Start();

	while(true)
	{
		// ======>> LOCK <<=======
		if(LOCK_TRYLOCK_INTERNAL)
		{
			if(!_bLocked)
			{
				// Lock
				NAIVELOCK_LOCK_INTERNAL;
				
				// ======>> UNLOCK <<=======
				LOCK_UNLOCK_INTERNAL;
				return LOCK_RET::LOCK_SUCCEED;
			}
			
			// ======>> UNLOCK <<=======
			LOCK_UNLOCK_INTERNAL;
		}

		// Timeout
		if(!bInfiniteTimeout)
		{
			LOCK_CHECK_TIMEOUTSCG(ticker.Tick(), sTimeout);
		}

		Sleep(LOCK_SLEEPCYCLE);
	}

	return LOCK_RET::LOCK_SUCCEED;
}

int naive_lock::UnLock()
{
	// ======>> LOCK <<=======
	LOCK_LOCKSCG_INTERNAL;

	// If not locked
	LOCK_CHECK_LOCKEDSCG(!_bLocked);

	// Check thread ID
	LOCK_CHECK_MISMATCHSCG((tid_t)GET_TID != _tid);

	// Unlock
	NAIVELOCK_UNLOCK_INTERNAL;

	return LOCK_RET::LOCK_SUCCEED;
}

#pragma endregion naive_lock

#pragma region count_lock

count_lock::count_lock():
	base_lock		(),
	_nRes			(COUNTLOCK_DEFAULT_RES),
	_tid			(INVALID_TID),
	_nLock			(0)
{
}

count_lock::count_lock(count_lock &&lck):
	base_lock		(),
	_nRes			(COUNTLOCK_DEFAULT_RES),
	_tid			(INVALID_TID),
	_nLock			(0)
{
	// ======>> LOCK OTHER <<=======
	LOCK_LOCKOTHERSCG_INTERNAL(lck);
	// ======>> LOCK <<=======
	LOCK_LOCKSCG_INTERNAL;
	
	// Assign
	base_lock::AssignMove(std::forward<base_lock>(lck));
	COUNTLOCK_ASSIGN_INTERNAL(lck);

	// ======>> UNLOCK <<=======
	LOCK_UNLOCKSCG_INTERNAL;

	// Clear after move
	lck.count_lock::ClearMove();
}

count_lock::~count_lock()
{
	// ======>> LOCK DYING <<=======
	LOCK_LOCKDYING_INTERNAL;

	_nLock = 0;
	_tid = INVALID_TID;
}

int count_lock::AssignMove(count_lock &lck)
{
	// ======>> LOCK OTHER <<=======
	LOCK_LOCKOTHERSCG_INTERNAL(lck);
	// ======>> LOCK <<=======
	LOCK_LOCKSCG_INTERNAL;

	// Clear before assignment
	count_lock::ClearPreAssign();
	
	// Assign
	base_lock::AssignMove(std::forward<base_lock>(lck));
	COUNTLOCK_ASSIGN_INTERNAL(lck);

	// ======>> UNLOCK <<=======
	LOCK_UNLOCKSCG_INTERNAL;
	
	// Clear after move
	lck.count_lock::ClearMove();

	return LOCK_RET::LOCK_SUCCEED;
}

count_lock& count_lock::operator = (count_lock &&lock)
{
	AssignMove(lock);

	return *this;
}

int count_lock::Lock(ms_t1 msTimeout)
{
	const sec_t sTimeout = MS_TO_SEC(msTimeout);
	bool bInfiniteTimeout = LOCK_TIME_ISINFINITE(msTimeout);
	
	Ticker ticker;
	ticker.Start();

	// Get thread ID
	tid_t tid = (tid_t)GET_TID;
	
	// ======>> LOCK <<=======
	if(LOCK_TRYLOCK_INTERNAL)
	{
		if(COUNTLOCK_AVAILABLE_INTERNAL(tid))
		{
			// Lock
			COUNTLOCK_LOCK_INTERNAL(tid);
			
			// ======>> UNLOCK <<=======
			LOCK_UNLOCK_INTERNAL;
			return LOCK_RET::LOCK_SUCCEED;
		}
		
		// ======>> UNLOCK <<=======
		LOCK_UNLOCK_INTERNAL;
	}

	while(true)
	{
		// ======>> LOCK <<=======
		if(LOCK_TRYLOCK_INTERNAL)
		{
			if(COUNTLOCK_AVAILABLE_INTERNAL(tid))
			{
				// Lock
				COUNTLOCK_LOCK_INTERNAL(tid);
				
				// ======>> UNLOCK <<=======
				LOCK_UNLOCK_INTERNAL;

				return LOCK_RET::LOCK_SUCCEED;
			}
			
			// ======>> UNLOCK <<=======
			LOCK_UNLOCK_INTERNAL;
		}

		// Timeout
		if(!bInfiniteTimeout)
		{
			LOCK_CHECK_TIMEOUTSCG(ticker.Tick(), msTimeout);
		}

		Sleep(LOCK_SLEEPCYCLE);
	}

	return LOCK_RET::LOCK_SUCCEED;
}

int count_lock::UnLock()
{
	// ======>> LOCK <<=======
	LOCK_LOCKSCG_INTERNAL;

	// If not locked
	LOCK_CHECK_LOCKEDSCG(COUNTLOCK_EMPTY_INTERNAL);

	// Check thread ID
	LOCK_CHECK_MISMATCHSCG((tid_t)GET_TID != _tid);
		
	// Unlock
	COUNTLOCK_UNLOCK_INTERNAL;

	return LOCK_RET::LOCK_SUCCEED;
}

#pragma endregion count_lock

#pragma region single_lock

#ifdef SINGLE_LOCK

single_lock::single_lock():
	base_lock		(),
	_section		(),
	_bLocked		(false)
{
	InitializeCriticalSection(&_section);
}

single_lock::single_lock(single_lock &&lck):
	base_lock		(),
	_section		(),
	_bLocked		(false)
{
	// ======>> LOCK OTHER <<=======
	LOCK_LOCKOTHERSCG_INTERNAL(lck);
	// ======>> LOCK <<=======
	LOCK_LOCKSCG_INTERNAL;

	memcpy_s(&_section, sizeof(CRITICAL_SECTION), &lck._section, sizeof(CRITICAL_SECTION));
	_bLocked		= lck._bLocked;

	// ======>> UNLOCK <<=======
	LOCK_UNLOCKSCG_INTERNAL;

	// Clear after move
	lck.single_lock::ClearMove();
}

single_lock::~single_lock()
{
	Release();
}

int single_lock::AssignMove(single_lock &lck)
{
	// ======>> LOCK OTHER <<=======
	LOCK_LOCKOTHERSCG_INTERNAL(lck);
	// ======>> LOCK <<=======
	LOCK_LOCKSCG_INTERNAL;

	// Clear before assignment
	single_lock::ClearPreAssign();

	// Assign
	base_lock::AssignMove(std::forward<base_lock>(lck));
	memcpy_s(&_section, sizeof(CRITICAL_SECTION), &lck._section, sizeof(CRITICAL_SECTION));
	_bLocked	= lck._bLocked;

	// ======>> UNLOCK <<=======
	LOCK_UNLOCKSCG_INTERNAL;

	// Clear after move
	lck.single_lock::ClearMove();

	return LOCK_RET::LOCK_SUCCEED;
}

single_lock& single_lock::operator = (single_lock &&lck)
{
	AssignMove(std::forward<single_lock>(lck));

	return *this;
}

int single_lock::Lock(ms_t1 msTimeout)
{
	// Lock internal
	bool bLock = false;
	LOCK_LOCKTIMESCG_INTERNAL(msTimeout, bLock);
	RETVAL_ON_FALSE(
		bLock,
		LOCK_RET::LOCK_TIMEOUT);

	// Lock
	// Unused(msTimeout)
	EnterCriticalSection(&_section);
	_bLocked = true;

	return LOCK_RET::LOCK_SUCCEED;
}

int single_lock::UnLock()
{
	// ======>> LOCK <<=======
	LOCK_LOCKSCG_INTERNAL;

	// If not locked
	LOCK_CHECK_LOCKEDSCG(!_bLocked);

	// Unlock
	LeaveCriticalSection(&_section);
	_bLocked = false;

	return LOCK_RET::LOCK_SUCCEED;
}

#endif

#pragma endregion single_lock

#pragma region icrwb_lock

icrwb_lock::icrwb_lock():
	base_lock		(),
	_status			(RWBLOCK_STATUS::RWB_UNLOCK),
	_nRes			(RWBLOCK_DEFAULT_RES),
	_tid			(INVALID_TID),
	_nLockR			(0),
	_mapLockR		(),
	_nLockIR		(0),
	_mapLockIR		()
{
}

icrwb_lock::icrwb_lock(icrwb_lock &&lock):
	base_lock		(),
	_status			(RWBLOCK_STATUS::RWB_UNLOCK),
	_nRes			(RWBLOCK_DEFAULT_RES),
	_tid			(INVALID_TID),
	_nLockR			(0),
	_mapLockR		(),
	_nLockIR		(0),
	_mapLockIR		()
{
	// ======>> LOCK OTHER <<=======
	LOCK_LOCKOTHERSCG_INTERNAL(lock);
	// ======>> LOCK <<=======
	LOCK_LOCKSCG_INTERNAL;
	
	// Assign
	base_lock::AssignMove(std::forward<base_lock>(lock));
	_nRes			= lock._nRes;
	_tid			= lock._tid;
	_nLockR			= lock._nLockR;
	_mapLockR		= std::forward<rmap>(lock._mapLockR);
	_nLockIR		= lock._nLockIR;
	_mapLockIR		= std::forward<rmap>(lock._mapLockIR);
	_status			= lock._status;

	// ======>> UNLOCK <<=======
	LOCK_UNLOCKSCG_INTERNAL;

	// Clear after move
	lock.icrwb_lock::ClearMove();
}

icrwb_lock::~icrwb_lock()
{
	// ======>> LOCK DYING <<=======
	LOCK_LOCKDYING_INTERNAL;

	// Force unlock all
	_nLockR = 0;
	_mapLockR.clear();
	_nLockIR = 0;
	_mapLockIR.clear();
	_tid = INVALID_TID;

	_status = RWBLOCK_STATUS::RWB_UNLOCK;
}

int icrwb_lock::AssignMove(icrwb_lock &lck)
{
	// ======>> LOCK OTHER <<=======
	LOCK_LOCKOTHERSCG_INTERNAL(lck);
	// ======>> LOCK <<=======
	LOCK_LOCKSCG_INTERNAL;

	// Clear before assignment
	icrwb_lock::ClearPreAssign();
	
	// Assign
	base_lock::AssignMove(std::forward<base_lock>(lck));
	_status		= lck._status;
	_nRes		= lck._nRes;
	_tid		= lck._tid;
	_nLockR		= lck._nLockR;
	_mapLockR	= std::forward<rmap>(lck._mapLockR);
	_nLockIR	= lck._nLockIR;
	_mapLockIR	= std::forward<rmap>(lck._mapLockIR);

	// ======>> UNLOCK <<=======
	LOCK_UNLOCKSCG_INTERNAL;

	// Clear after move
	lck.icrwb_lock::ClearMove();

	return LOCK_RET::LOCK_SUCCEED;
}

icrwb_lock& icrwb_lock::operator = (icrwb_lock &&lock)
{
	AssignMove(std::forward<icrwb_lock>(lock));

	return *this;
}

int icrwb_lock::Lock(ms_t1 msTimeout)
{
	const sec_t sTimeout = MS_TO_SEC(msTimeout);
	bool bInfiniteTimeout = LOCK_TIME_ISINFINITE(msTimeout);

	Ticker ticker;
	ticker.Start();
	while(true)
	{
		// ======>> LOCK <<=======
		if(LOCK_TRYLOCK_INTERNAL)
		{
			if(!RWBLOCK_FULLLOCKEDBLOCK_INTERNAL)
			{
				// Lock
				RWBLOCK_LOCKBLOCK_INTERNAL;

				// ======>> UNLOCK <<=======
				LOCK_UNLOCK_INTERNAL;

				return LOCK_RET::LOCK_SUCCEED;
			}

			// ======>> UNLOCK <<=======
			LOCK_UNLOCK_INTERNAL;
		}

		// Timeout
		if(!bInfiniteTimeout)
		{
			LOCK_CHECK_TIMEOUTSCG(ticker.Tick(), sTimeout);
		}

		Sleep(LOCK_SLEEPCYCLE);
	}

	return LOCK_RET::LOCK_SUCCEED;
}

int icrwb_lock::LockIRead(ms_t1 msTimeout)
{
	const sec_t sTimeout = MS_TO_SEC(msTimeout);
	bool bInfiniteTimeout = LOCK_TIME_ISINFINITE(msTimeout);

	Ticker ticker;
	ticker.Start();
	while(true)
	{
		// ======>> LOCK <<=======
		if(LOCK_TRYLOCK_INTERNAL)
		{
			// Check read available
			if(!RWBLOCK_FULLLOCKEDIREAD_INTERNAL)
			{
				// Lock
				RWBLOCK_LOCKIREAD_INTERNAL;
				
				// ======>> UNLOCK <<=======
				LOCK_UNLOCK_INTERNAL;

				return LOCK_RET::LOCK_SUCCEED;
			}
			
			// ======>> UNLOCK <<=======
			LOCK_UNLOCK_INTERNAL;
		}

		// Timeout
		if(!bInfiniteTimeout)
		{
			LOCK_CHECK_TIMEOUTSCG(ticker.Tick(), sTimeout);
		}

		Sleep(LOCK_SLEEPCYCLE);
	}

	return LOCK_RET::LOCK_SUCCEED;
}

int icrwb_lock::LockRead(ms_t1 msTimeout)
{
	const sec_t sTimeout = MS_TO_SEC(msTimeout);
	bool bInfiniteTimeout = LOCK_TIME_ISINFINITE(msTimeout);

	Ticker ticker;
	ticker.Start();
	while(true)
	{
		// ======>> LOCK <<=======
		if(LOCK_TRYLOCK_INTERNAL)
		{
			// Check read available
			if(!RWBLOCK_FULLLOCKEDREAD_INTERNAL)
			{
				// Lock
				RWBLOCK_LOCKREAD_INTERNAL;

				// ======>> UNLOCK <<=======
				LOCK_UNLOCK_INTERNAL;

				return LOCK_RET::LOCK_SUCCEED;
			}

			// ======>> UNLOCK <<=======
			LOCK_UNLOCK_INTERNAL;
		}

		// Timeout
		if(!bInfiniteTimeout)
		{
			LOCK_CHECK_TIMEOUTSCG(ticker.Tick(), sTimeout);
		}

		Sleep(LOCK_SLEEPCYCLE);
	}

	return LOCK_RET::LOCK_SUCCEED;
}

int icrwb_lock::LockWrite(ms_t1 msTimeout)
{
	const sec_t sTimeout = MS_TO_SEC(msTimeout);
	bool bInfiniteTimeout = LOCK_TIME_ISINFINITE(msTimeout);

	Ticker ticker;
	ticker.Start();
	while(true)
	{
		// ======>> LOCK <<=======
		if(LOCK_TRYLOCK_INTERNAL)
		{
			// Check write available
			if(!RWBLOCK_FULLLOCKEDWRITE_INTERNAL)
			{
				// Lock
				RWBLOCK_LOCKWRITE_INTERNAL;

				// ======>> UNLOCK <<=======
				LOCK_UNLOCK_INTERNAL;

				return LOCK_RET::LOCK_SUCCEED;
			}

			// ======>> UNLOCK <<=======
			LOCK_UNLOCK_INTERNAL;
		}

		// Timeout
		if(!bInfiniteTimeout)
		{
			LOCK_CHECK_TIMEOUTSCG(ticker.Tick(), sTimeout);
		}

		Sleep(LOCK_SLEEPCYCLE);
	}

	return LOCK_RET::LOCK_SUCCEED;
}

int icrwb_lock::LockIReadGuard(
	scope_guard &scg, ms_t1 msTimeout)
{
	int ret = LockIRead(msTimeout);
	RET_ON_NP_AND(
		ret,
		Logger::Log0("Lock Inconsistent Read failed, ret:" + to_string(ret)););
	
	//Logger::Log0("Lock read");

	scg.SetAndEnable(
		[this]()
		{
			UnLockIRead();
		});

	return ret;
}

int icrwb_lock::LockReadGuard(
	scope_guard &scg, ms_t1 msTimeout)
{
	int ret = LockRead(msTimeout);
	RET_ON_NP_AND(
		ret,
		Logger::Log0("Lock Read failed, ret:" + to_string(ret)););
	
	//Logger::Log0("Lock read");

	scg.SetAndEnable(
		[this]()
		{
			UnLockRead();
		});

	return ret;
}

int icrwb_lock::LockWriteGuard(
	scope_guard &scg, ms_t1 msTimeout)
{
	int ret = LockWrite(msTimeout);
	RET_ON_NP_AND(
		ret,
		Logger::Log0("Lock Write failed, ret:" + to_string(ret)););

	//Logger::Log0("Lock write");

	scg.SetAndEnable(
		[this]()
		{
			UnLockWrite();
		});

	return ret;
}

int icrwb_lock::UnLock()
{
	// ======>> LOCK <<=======
	LOCK_LOCKSCG_INTERNAL;

	// Check locked
	LOCK_CHECK_LOCKEDSCG(RWBLOCK_NOTLOCKEDBLOCK_INTERNAL);

	// Check thread ID
	LOCK_CHECK_MISMATCHSCG((tid_t)GET_TID != _tid);

	// Unlock
	RWBLOCK_UNLOCKBLOCK_INTERNAL;

	return LOCK_RET::LOCK_SUCCEED;
}

int icrwb_lock::UnLockIRead()
{
	// ======>> LOCK <<=======
	LOCK_LOCKSCG_INTERNAL;
	
	// Check locked
	LOCK_CHECK_LOCKEDSCG(RWBLOCK_NOTLOCKEDIREAD_INTERNAL);

	tid_t tid = (tid_t)GET_TID;
	rmap::iterator itr = _mapLockIR.find(tid);
	// Check thread ID
	LOCK_CHECK_MISMATCH(_mapLockIR.end() == itr);
	LOCK_CHECK_MISMATCH(itr->second <= 0);

	// Unlock
	RWBLOCK_UNLOCKIREAD_INTERNAL(itr);

	return LOCK_RET::LOCK_SUCCEED;
}

int icrwb_lock::UnLockRead()
{
	// ======>> LOCK <<=======
	LOCK_LOCKSCG_INTERNAL;
	
	// Check locked
	LOCK_CHECK_LOCKEDSCG(RWBLOCK_NOTLOCKEDREAD_INTERNAL);

	tid_t tid = (tid_t)GET_TID;
	rmap::iterator itr = _mapLockR.find(tid);
	// Check thread ID
	LOCK_CHECK_MISMATCH(_mapLockR.end() == itr);
	LOCK_CHECK_MISMATCH(itr->second <= 0);

	// Unlock
	RWBLOCK_UNLOCKREAD_INTERNAL(itr);

	return LOCK_RET::LOCK_SUCCEED;
}

int icrwb_lock::UnLockWrite()
{
	// ======>> LOCK <<=======
	LOCK_LOCKSCG_INTERNAL;
	
	// Check locked
	LOCK_CHECK_LOCKEDSCG(RWBLOCK_NOTLOCKEDWRITE_INTERNAL);

	// Check thread ID
	LOCK_CHECK_MISMATCHSCG((tid_t)GET_TID != _tid);

	// Unlock
	RWBLOCK_UNLOCKWRITE_INTERNAL;

	return LOCK_RET::LOCK_SUCCEED;
}

#pragma endregion icrwb_lock

#pragma region atom

atom8<bool>::atom8():
	_obj		(nullptr)
{
	ATOM_INIT_INTERNAL(_obj, cas_t);
}

atom8<bool>::atom8(bool vT):
	_obj		(nullptr)
{
	ATOM_INIT_INTERNAL(_obj, cas_t);

	cas_t vO = cas_t();
	ATOM_SETVAL_INTERNAL(vO, vT, bool);

	ATOM_SET_INTERNAL(_obj, vO);
}

atom8<bool>::atom8(const atom8<bool> &atm):
	_obj		(nullptr)
{
	ATOM_INIT_INTERNAL(_obj, cas_t);
		
	// Get Other obj value
	cas_t vO;
	ATOM_GET_INTERNAL(atm._obj, vO);

	ATOM_SET_INTERNAL(_obj, vO);
}

atom8<bool>::~atom8()
{
	SAFE_DELETE(_obj);
}

int atom8<bool>::Assign(atom8<bool> &atm)
{
	// Get Other obj value
	cas_t vO;
	ATOM_GET_INTERNAL(atm._obj, vO);

	ATOM_SET_INTERNAL(_obj, vO);

	return 1;
}

atom8<bool>& atom8<bool>::operator = (atom8<bool> &atm)
{
	Assign(atm);

	return *this;
}

int atom8<bool>::Clear()
{
	ATOM_SET_INTERNAL(_obj, bool());

	return 1;
}

void atom8<bool>::flip()
{
	// Get obj value
	cas_t vO;
	ATOM_GET_INTERNAL(_obj, vO);

	// Get T value
	bool vT;
	ATOM_GETVAL_INTERNAL(vO, vT, bool);
	// Decrement
	bool vTU = vT;
	vTU = !vTU;

	// Get obj value of inced
	cas_t vOU	= cas_t();
	ATOM_SETVAL_INTERNAL(vOU, vTU, bool);

	while(ATOM_CASF_INTERNAL(_obj, vO, vOU))
	{
		// Get obj value
		ATOM_GET_INTERNAL(_obj, vO);
			
		// Get T value
		ATOM_GETVAL_INTERNAL(vO, vT, bool);
		// Decrement
		vTU = vT;
		vTU = !vTU;

		// Get obj value of inced
		ATOM_SETVAL_INTERNAL(vOU, vTU, bool);
	}
}

bool atom8<bool>::get() const
{
	// Get obj value
	cas_t vO;
	ATOM_GET_INTERNAL(_obj, vO);
		
	// Get T value
	bool vT;
	ATOM_GETVAL_INTERNAL(vO, vT, bool);

	return vT;
}

bool atom8<bool>::set(bool vT)
{
	cas_t vO = cas_t();
	ATOM_SETVAL_INTERNAL(vO, vT, bool);

	// Set and get old value
	cas_t vOOld = ATOM_SET_INTERNAL(_obj, vO);

	// Get old T value
	bool vTOld;
	ATOM_GETVAL_INTERNAL(vOOld, vTOld, bool);

	return (vTOld != vT);
}

atom<bool>::atom():
	_v			(nullptr)
{
	_v = new cas_t(ATOM_BOOL_FALSE);
}

atom<bool>::atom(bool vT):
	_v			(nullptr)
{
	_v = new cas_t(ATOM_BOOL_FALSE);

	cas_t v = vT ? ATOM_BOOL_TRUE : ATOM_BOOL_FALSE;

	ATOM_SET_INTERNAL(_v, v);
}

atom<bool>::atom(const atom<bool> &atm):
	_v			(nullptr)
{
	_v = new cas_t(ATOM_BOOL_FALSE);

	cas_t v = *(atm._v);// pure atom read
		
	// Assign TODO
	ATOM_SET_INTERNAL(_v, v);
}

atom<bool>::~atom()
{
	SAFE_DELETE(_v);
}

int atom<bool>::Assign(const atom<bool> &atm)
{
	cas_t v = *(atm._v);// pure atom read

	// Assign TODO
	ATOM_SET_INTERNAL(_v, v);

	return 1;
}

atom<bool>& atom<bool>::operator = (const atom<bool> &atm)
{
	Assign(atm);

	return *this;
}

int atom<bool>::clear()
{
	ATOM_SET_INTERNAL(_v, ATOM_BOOL_FALSE);

	return 1;
}

void atom<bool>::flip()
{
	cas_t v = *_v;// pure atom read
	cas_t vNew = (v ^ ATOMBOOL_XOR_MASK);

	while(ATOM_CASF_INTERNAL(_v, v, vNew))
	{
		v = *_v;
		vNew = (v ^ ATOMBOOL_XOR_MASK);
	}
}

bool atom<bool>::get() const
{
	cas_t v = *_v;// pure atom read

	return v == ATOM_BOOL_TRUE;
}

bool atom<bool>::set(bool vT)
{
	cas_t v = vT ? ATOM_BOOL_TRUE : ATOM_BOOL_FALSE;
	cas_t vOld = *_v;// pure atom read
	ATOM_SET_INTERNAL(_v, v);

	return vOld == ATOM_BOOL_TRUE;
}

bool atom<bool>::checkandflip(bool chk)
{
	cas_t vChk = chk ? ATOM_BOOL_TRUE : ATOM_BOOL_FALSE;
	cas_t vNew = (vChk ^ ATOMBOOL_XOR_MASK);

	return ATOM_CASS_INTERNAL(_v, vChk, vNew);
}

#undef ATOM_INIT_INTERNAL

#undef ATOM_CAS_INTERNAL
#undef ATOM_CASF_INTERNAL
#undef ATOM_SET_INTERNAL
#undef ATOM_EQU_INTERNAL
#undef ATOM_GET_INTERNAL

#undef ATOM_TYPEAT_INTERNAL
#undef ATOM_SETVAL_INTERNAL
#undef ATOM_GETVAL_INTERNAL

#pragma endregion atom

#undef _IMGDISP_SOURCE_FILE_LOCK_CPP
#define _IMGDISP_SOURCE_FILE_UTILITY_H
#pragma once

#include <windows.h>
//#include <ShellAPI.h>

#include <unordered_map>
#include <functional>
//#include <atomic>
//#include <condition_variable>
//#include <thread>

#include "langBase.h"
#include "thread.h"


/************************
 Using
*************************/
using std::unordered_map;
using std::function;
using std::to_string;
//using std::mutex;
//using std::atomic;
//using std::condition_variable;
//using std::thread;
using bse::XOverflow;


/************************
 Define
*************************/
// customized HRESULT system
#define E_INVALID_ARG			_HRESULT_TYPEDEF_(0x80000001L)
#define E_NULL_FUNC				_HRESULT_TYPEDEF_(0x80000002L)
#define E_STATE_ERROR			_HRESULT_TYPEDEF_(0x80000003L)
#define E_STATUS_ERROR			_HRESULT_TYPEDEF_(0x80000004L)
#define E_INIT_FAIL				_HRESULT_TYPEDEF_(0x80000005L)
#define E_NOT_FOUND				_HRESULT_TYPEDEF_(0x80000006L)
#define E_TIMEOUT				_HRESULT_TYPEDEF_(0x80000007L)
#define E_UNKNOWN				_HRESULT_TYPEDEF_(0x80000008L)
#define E_OVERFLOW				_HRESULT_TYPEDEF_(0x80000009L)
#define E_NOT_INITIALIZED		_HRESULT_TYPEDEF_(0x80000010L)
//
#define E_DO_FAIL				_HRESULT_TYPEDEF_(0x80000011L)
#define E_TRANSITION_FAIL		_HRESULT_TYPEDEF_(0x80000012L)

#define E_WAITABORT				_HRESULT_TYPEDEF_(0x80000013L)

// S_OK = 1L
#define S_SAME					((HRESULT)2L)
#define S_RENEW					((HRESULT)3L)
#define S_ALREADY_DONE			((HRESULT)4L)

// return type
typedef int					iret;


/************************
 Helper
*************************/
// a customized function map
inline double GetScale_InvProp(
	double x, double dScaleMin = 0.0, double dScaleInf = 1.0, double dMolecule = 1.0, double xMin = 0.0)
{
	double dx = dMolecule / (dScaleInf - dScaleMin) - xMin;
	if (dx + x == 0)
	{
		return -1;
	}
	return dScaleInf - dMolecule / (dx + x);
}

#pragma region X_POINTRECT
/************************
 Point
*************************/
template<typename T>
struct POINTX
{
	T			x;
	T			y;

	POINTX():
		x		(-1),
		y		(-1)
	{
	}
	template<typename U>
	POINTX(const POINTX<U> &pt):
		x		((T)pt.x),
		y		((T)pt.y)
	{
	}
	explicit POINTX(int px, int py):
		x		(px),
		y		(py)
	{
	}

	bool Inside(int width, int height) const
	{
		return ((x >= 0 && x < width) && (y >= 0 && y < height));
	}
	bool IsNegative() const
	{
		return ((x < 0) || (y < 0));
	}
	bool IsZeroNegative() const
	{
		return ((x <= 0) || (y <= 0));
	}
	POINTX Inversed() const
	{
		return POINTX(-x, -y);
	}
	bool	Equals(const POINTX &pt) const
	{
		return x == pt.x && y == pt.y;
	}
	string ToString() const
	{
		return '(' + to_string(x) + ',' + to_string(y) + ')';
	}
};

/************************
 Rectangle
*************************/
template<typename T>
struct /*DLLEXPORT */RECTX
{
	T			left;
	T			top;
	T			right;
	T			bottom;

	static const RECTX	DefaultRect;

public:
	static RECTX FromXYWH(T x, T y, T w, T h)
	{
		return RECTX(x, y, x + w - 1, y + h - 1);
	}
	static RECTX FromPWH(const POINTX<T> &pt, T w, T h)
	{
		return RECTX(pt.x, pt.y, pt.x + w - 1, pt.y + h - 1);
	}
	static RECTX FromTLBR(const POINTX<T> &ptTL, const POINTX<T> &ptBR)
	{
		return RECTX(ptTL.x, ptTL.y, ptBR.x, ptBR.y);
	}

public:
	RECTX():
		left	(1),
		top		(1),
		right	(0),
		bottom	(0)
	{
	}
	explicit RECTX(T l, T t, T r, T b):
		left	(l),
		top		(t),
		right	(r),
		bottom	(b)
	{
	}

	inline T Width() const
	{
		return right - left + 1;
	}
	inline T Height() const
	{
		return bottom - top + 1;
	}
	inline void CorrectSize(T widthRC, T heightRC)
	{
		if(widthRC <= 0 || heightRC <= 0)
		{
			return;
		}

		// >> Overflow [left + widthRC - 1] <<
		if(!XOverflow<T>::AddGT(left, widthRC - 1, right))
		{
			right = left + widthRC - 1;
		}
		if(!XOverflow<T>::AddGT(top, heightRC - 1, bottom))
		{
			bottom = top + heightRC - 1;
		}
	}
	inline void Correct(T width, T height)
	{
		left	= max(left,		0);
		top		= max(top,		0);
		right	= min(right,	width - 1);
		bottom	= min(bottom,	height - 1);
	}
	inline bool IsInvalid_Size() const
	{
		return (right < left || bottom < top);
	}
	inline bool IsInvalid_Size(T w, T h) const
	{
		return (right < left || bottom < top ||
			right - left + 1 > w || bottom - top + 1 > h);
	}
	// is value negative or size < 0
	inline bool IsInvalid_Neg() const
	{
		return (left < 0 || top < 0 ||
			right < left || bottom < top);
	}
	// some part outside the 0-based rect region or size < 0
	inline bool IsInvalid_Out(T width, T height) const
	{
		return (left < 0 || top < 0 ||
			left >= width || top >= height ||//TODO
			right < 0 || bottom < 0 ||
			right >= width || bottom >= height ||
			right < left || bottom < top);
	}
	// fully outside the 0-based rect region or size < 0
	inline bool IsInvalid_OutFull(T width, T height) const
	{
		return (left > width - 1 || top > height - 1 ||
			right < 0 || bottom < 0 ||
			right < left || bottom < top);
	}

	bool	IsPointInside(const POINTX<T> &pt) const
	{
		return pt.x >= left && pt.x <= right &&
			pt.y >= top && pt.y <= bottom;
	}

	POINTX<T>	BasePoint() const
	{
		return POINTX<T>(left, top);
	}
	POINTX<T>	EndPoint() const
	{
		return POINTX<T>(right, bottom);
	}
	void		Set(T l, T t, T r, T b)
	{
		left	= l;
		top		= t;
		right	= r;
		bottom	= b;
	}
	void		SetFromTLBR(const POINTX<T> &ptTL, const POINTX<T> &ptBR)
	{
		left	= ptTL.x;
		top		= ptTL.y;
		right	= ptBR.x;
		bottom	= ptBR.y;
	}

	bool		Offset(const POINTX<T> &ptOff)
	{
		left	+= ptOff.x;
		right	+= ptOff.x;
		top		+= ptOff.y;
		bottom	+= ptOff.y;

		return true;
	}
	bool		Equals(const RECTX &rc) const
	{
		return left == rc.left && top == rc.top &&
			right == rc.right && bottom == rc.bottom;
	}
	string		ToString(char d = ',', char o = '[') const
	{
		return '[' +
			to_string(left) + d + to_string(top) + d +
			to_string(right) + d + to_string(bottom) + ']';
	}
};

template<typename T>
const RECTX<T> RECTX<T>::DefaultRect = RECTX<T>();

#pragma endregion X_POINTRECT


#pragma region FIXED_POINTRECT

#ifdef USE_FIXED_POINTRECT

struct basePOINT
{
	int			x;
	int			y;

	basePOINT():
		x		(-1),
		y		(-1)
	{
	}
	explicit basePOINT(int px, int py):
		x		(px),
		y		(py)
	{
	}

	bool Inside(int width, int height) const
	{
		return ((x >= 0 && x < width) && (y >= 0 && y < height));
	}
	bool IsNegative() const
	{
		return ((x < 0) || (y < 0));
	}
	bool IsZeroNegative() const
	{
		return ((x <= 0) || (y <= 0));
	}
	basePOINT Inversed() const
	{
		return basePOINT(-x, -y);
	}
	bool	Equals(const basePOINT &pt) const
	{
		return x == pt.x && y == pt.y;
	}
};
typedef basePOINT	POINT32;

struct int64POINT
{
	__int64		x;
	__int64		y;

	int64POINT():
		x		(-1),
		y		(-1)
	{
	}
	explicit int64POINT(__int64 px, __int64 py):
		x		(px),
		y		(py)
	{
	}
	explicit int64POINT(basePOINT pt):
		x		(pt.x),
		y		(pt.y)
	{
	}

	bool Inside(__int64 width, __int64 height) const
	{
		return ((x >= 0 && x < width) && (y >= 0 && y < height));
	}
	bool IsNegative() const
	{
		return ((x < 0) || (y < 0));
	}
	bool IsZeroNegative() const
	{
		return ((x <= 0) || (y <= 0));
	}
	int64POINT Inversed() const
	{
		return int64POINT(-x, -y);
	}
	bool	Equals(const int64POINT &pt) const
	{
		return x == pt.x && y == pt.y;
	}
};
typedef int64POINT	POINT64;

struct DLLEXPORT baseRECT
{
	int			left;
	int			top;
	int			right;
	int			bottom;

	static const baseRECT	DefaultRect;

public:
	static baseRECT FromXYWH(int x, int y, int w, int h);
	static baseRECT FromPWH(const basePOINT &pt, int w, int h);
	static baseRECT FromTLBR(const basePOINT &ptTL, const basePOINT &ptBR);

public:
	baseRECT();
	explicit baseRECT(int l, int t, int r, int b);

	inline int Width() const
	{
		return right - left + 1;
	}
	inline int Height() const
	{
		return bottom - top + 1;
	}
	inline void CorrectSize(int widthRC, int heightRC)
	{
		right	= min(right,	left + widthRC - 1);
		bottom	= min(bottom,	top + heightRC - 1);
	}
	inline void Correct(int width, int height)
	{
		left	= max(left,		0);
		top		= max(top,		0);
		right	= min(right,	width - 1);
		bottom	= min(bottom,	height - 1);
	}
	inline bool IsInvalid_Size() const
	{
		return (right < left || bottom < top);
	}
	inline bool IsInvalid_Size(int w, int h) const
	{
		return (right < left || bottom < top ||
			right - left + 1 > w || bottom - top + 1 > h);
	}
	// is value negative or size < 0
	inline bool IsInvalid_Neg() const
	{
		return (left < 0 || top < 0 ||
			right < left || bottom < top);
	}
	// some part outside the 0-based rect region or size < 0
	inline bool IsInvalid_Out(int width, int height) const
	{
		return (left < 0 || top < 0 ||
			left >= width || top >= height ||//TODO
			right < 0 || bottom < 0 ||
			right >= width || bottom >= height ||
			right < left || bottom < top);
	}
	// fully outside the 0-based rect region or size < 0
	inline bool IsInvalid_OutFull(int width, int height) const
	{
		return (left > width - 1 || top > height - 1 ||
			right < 0 || bottom < 0 ||
			right < left || bottom < top);
	}

	bool	IsPointInside(const basePOINT &pt) const;

	basePOINT	BasePoint() const;
	basePOINT	EndPoint() const;
	void		SetFromTLBR(const basePOINT &ptTL, const basePOINT &ptBR);
	bool		Offset(const basePOINT &ptOff);
	bool		Equals(const baseRECT &rc) const;
	string		ToString(char d = ',', char o = '[') const;
};
typedef baseRECT	RECT32;

struct DLLEXPORT int64RECT
{
	__int64		left;
	__int64		top;
	__int64		right;
	__int64		bottom;

	static const int64RECT	DefaultRect;
public:
	int64RECT();
	explicit int64RECT(const baseRECT& rc);
	explicit int64RECT(__int64 l, __int64 t, __int64 r, __int64 b);

	inline __int64 Width() const
	{
		return right - left + 1;
	}
	inline __int64 Height() const
	{
		return bottom - top + 1;
	}
	inline void CorrectSize(__int64 widthRC, __int64 heightRC)
	{
		right	= min(right,	left + widthRC - 1);
		bottom	= min(bottom,	top + heightRC - 1);
	}
	inline void Correct(__int64 width, __int64 height)
	{
		left	= max(left,		0);
		top		= max(top,		0);
		right	= min(right,	width - 1);
		bottom	= min(bottom,	height - 1);
	}
	inline bool IsInvalid_Size() const
	{
		return (right < left || bottom < top);
	}
	inline bool IsInvalid_Size(__int64 w, __int64 h) const
	{
		return (right < left || bottom < top ||
			right - left + 1 > w || bottom - top + 1 > h);
	}
	// is value negative or size < 0
	inline bool IsInvalid_Neg() const
	{
		return (left < 0 || top < 0 ||
			right < left || bottom < top);
	}
	// some part outside the 0-based rect region or size < 0
	inline bool IsInvalid_Out(__int64 width, __int64 height) const
	{
		return (left < 0 || top < 0 ||
			left >= width || top >= height ||
			right < 0 || bottom < 0 ||
			right >= width || bottom >= height ||
			right < left || bottom < top);
	}
	// fully outside the 0-based rect region or size < 0
	inline bool IsInvalid_OutFull(__int64 width, __int64 height) const
	{
		return (left > width - 1 || top > height - 1 ||
			right < 0 || bottom < 0 ||
			right < left || bottom < top);
	}

	int64POINT BasePoint() const;
	int64POINT EndPoint() const;
	void SetFromTLBR(const int64POINT &ptTL, const int64POINT &ptBR);

public:
	static int64RECT FromXYWH(__int64 x, __int64 y, __int64 w, __int64 h);
	static int64RECT FromPWH(const int64POINT &pt, __int64 w, __int64 h);
	static int64RECT FromTLBR(const int64POINT &ptTL, const int64POINT &ptBR);
	bool		Equals(const int64RECT &rc) const;
	string		ToString(char d = ',', char o = '[') const;
};
typedef int64RECT	RECT64;

#endif

#pragma endregion FIXED_POINTRECT


#pragma region MMap
/************************
 Memory Mapping
*************************/
class DLLEXPORT MMap
{
	enum MMAP_STATUS{
		MMAP_EMPTY,
		MMAP_LIVE,
		MMAP_SYNC,
		MMAP_OFFLINE
	};

private:
	MMAP_STATUS		_status;

	bool			_bFile;
	HANDLE			_hFile;
	string			_fileName;

	HANDLE			_hFileMap;
	volatile void*	_pData;
	char			_mapName[256];
	size_t			_size;

protected:
	int				CreateFileInternal(const string &fileName);
	int				DeleteFileInternal();
	int				CreateFileMappingInternal(const string &name, size_t size, bool bFile, const string &fileName);
	int				CloseFileMappingInternal();
	int				MapViewInternal();
	int				UnmapViewInternal();
protected:
	LFCTYPE void	ClearPreAssign();
	LFCTYPE void	ClearMove();
	void			Release();
private:
	// Disable copy-ctor, = operator
	MMap(MMap &mmap);
	MMap&			operator = (MMap &mmap);
public:
	MMap();
	MMap(MMap &&mmap);
	~MMap();
	
	int				AssignMove(MMap &mmap);
	MMap&			operator = (MMap &&mmap);

	inline volatile void*	GetPData() const
	{
		return _pData;
	}
	inline size_t	GetSize() const
	{
		return _size;
	}
	inline bool		IsCreated() const
	{
		return (_status != MMAP_STATUS::MMAP_EMPTY);
	}

	HRESULT		Create(const string &name, size_t size, bool bFile = false, const string &fileName = "");
	HRESULT		Close();
	HRESULT		Open();
	HRESULT		Clear();

	HRESULT		ZeroMem(size_t len, size_t pos = 0);
	HRESULT		Write(const void *buf, size_t len, size_t pos = 0);
	HRESULT		WriteBinary(DWORD num, size_t pos = 0);
	HRESULT		WriteBinary(char b, size_t pos = 0);
	HRESULT		ReadBinary(char &c, size_t pos = 0) const;
	HRESULT		ReadBinary(DWORD &n, size_t pos = 0) const;
	HRESULT		Read(void *buf, size_t len, size_t pos = 0) const;
};
#pragma endregion MMap


#pragma region Event
/************************
 Event
*************************/
class Event
{
protected:
	bool	bCreated;
	HANDLE	hEvent;
	string	name;

protected:
	LFCTYPE void	ClearPreAssign()
	{
		Close();
	}
	LFCTYPE void	ClearMove()
	{
		bCreated	= false;
		hEvent		= INVALID_HANDLE_VALUE;
		name		= "";
	}
	void			Release()
	{
		Close();
	}
private:
	// Disable copy-ctor, = operator
	Event(Event &evt);
	Event&	operator = (Event &evt);
public:
	Event();
	explicit Event(const string &name, bool bAutoReset = true, bool initVal = false);
	~Event();
	Event(Event &&evt);
	Event&	operator = (Event &&evt);

	bool	IsCreated() const
	{
		return bCreated;
	}
	int		Create(const string &name, bool bAutoReset = true, bool initVal = false);
	int		Close();
	bool	Signal();
	int		Wait(DWORD dw);
};

/************************
 Trigger
*************************/
class BaseTrigger
{
public:
	typedef function<void()>				func;

private:
	func		_func;
	bool		_bEnabled;

protected:
public:
	BaseTrigger();
	virtual ~BaseTrigger();

	virtual int		Set(const func &fun);
	virtual int		SetAndEnable(const func &fun);
	virtual int		Enable(const func &fun);
	virtual int		Disable(const func &fun);
	virtual int		Clear();
	virtual int		Trigger();
};
#pragma endregion Event

#pragma region BiSwap
/************************
 BiSwap
*************************/
template<class T>
class BiSwap
{
public:
	typedef icrwb_lock	lock_t;
protected:
	// false for _t1, true for _t2
	bool	_bx;

	int		_cnt1;
	int		_cnt2;
	T		_t1;
	T		_t2;
	mutable lock_t	_l1;
	mutable lock_t	_l2;
	
protected:
	LFCTYPE void	ClearPreAssign()
	{
	}
	LFCTYPE void	ClearMove()
	{
		Clear();// TODO
	}
	void			Release()
	{
		Clear();
	}
private:
	// Disable copy-ctor, = operator
	BiSwap(BiSwap &swp);
	BiSwap&	operator = (BiSwap &swp);
public:
	BiSwap():
		_bx		(false),
		_cnt1	(0),
		_cnt2	(0),
		_t1		(),
		_t2		(),
		_l1		(),
		_l2		()
	{
	}
	BiSwap(BiSwap &&swp)
	{
		// Lock & assign
		scope_guard scgLock;
		_l1.LockGuard(scgLock);
		scope_guard scgLock1;
		swp._l1.LockGuard(scgLock1);

		scope_guard scgLock2;
		_l2.LockGuard(scgLock2);
		scope_guard scgLock21;
		swp._l2.LockGuard(scgLock21);

		_t1 = swp._t1;
		_cnt1 = swp._cnt1;

		
		_t2 = swp._t2;
		_cnt2 = swp._cnt2;

		_bx = swp._bx;
	}
	~BiSwap()
	{
		Release();
	}
	
	int				AssignMove(BiSwap &swp)
	{
		// Clear before assignment
		BiSwap::ClearPreAssign();

		// Lock & assign
		scope_guard scgLock;
		_l1.LockGuard(scgLock);
		scope_guard scgLock1;
		swp._l1.LockGuard(scgLock1);

		scope_guard scgLock2;
		_l2.LockGuard(scgLock2);
		scope_guard scgLock21;
		swp._l2.LockGuard(scgLock21);

		_t1 = swp._t1;
		_cnt1 = swp._cnt1;

		
		_t2 = swp._t2;
		_cnt2 = swp._cnt2;

		_bx = swp._bx;

		// Clear after move
		swp.BiSwap::ClearMove();

		return 1;
	}
	BiSwap&	operator = (BiSwap &&swp)
	{
		AssignMove(swp);

		return *this;
	}

	void	Clear()
	{
		scope_guard scgLock;
		_l1.LockGuard(scgLock);
		scope_guard scgLock2;
		_l2.LockGuard(scgLock2);

		_cnt1 = 0;
		_t1 = T();

		_cnt2 = 0;
		_t2 = T();
	}
	int		TrySet(const T &t)
	{
		scope_guard scgLock;
		int ret = _l1.TryLockGuard(scgLock);

		if(ret > 0)
		{
			_cnt1++;
			_t1 = t;

			_bx = false;

			return _cnt1;
		}
		
		ret = _l2.TryLockGuard(scgLock);
		RETVAL_ON_NP(
			ret,
			-1);

		_cnt2++;
		_t2 = t;

		_bx = true;

		return _cnt2;
	}
	T	Get(bool &bGot, ms_t1 msWait = LOCK_TIME_INFINITE) const
	{
		// Init flag
		bGot = false;

		lock_t* lck = nullptr;
		const T* t = nullptr;
		if(_bx)
		{
			lck = &_l2;
			t = &_t2;
			if(_cnt2 <= 0)
			{
				return T();
			}
		}
		else
		{
			lck = &_l1;
			t = &_t1;
			if(_cnt1 <= 0)
			{
				return T();
			}
		}

		scope_guard scgLock;
		int ret = lck->LockWriteGuard(scgLock, msWait);
		RETVAL_ON_NP(
			ret,
			T());

		// Update flag
		bGot = true;

		return *t;
	}
	const T*	Get(scope_guard &scgLock, ms_t1 msWait = LOCK_TIME_INFINITE) const
	{
		lock_t* lck = nullptr;
		const T* t = nullptr;

		if(_bx)
		{
			lck = &_l2;
			t = &_t2;
			RETVAL_ON_TRUE(
				_cnt2 <= 0,
				nullptr);
		}
		else
		{
			lck = &_l1;
			t = &_t1;
			RETVAL_ON_TRUE(
				_cnt1 <= 0,
				nullptr);
		}

		int ret = lck->LockWriteGuard(scgLock, msWait);
		RETVAL_ON_NP(
			ret,
			nullptr);

		return t;
	}
	const T*	GetInconsistent(scope_guard &scgLock, ms_t1 msWait = LOCK_TIME_INFINITE) const
	{
		lock_t* lck = nullptr;
		const T* t = nullptr;

		if(_bx)
		{
			lck = &_l2;
			t = &_t2;
			RETVAL_ON_TRUE(
				_cnt2 <= 0,
				nullptr);
		}
		else
		{
			lck = &_l1;
			t = &_t1;
			RETVAL_ON_TRUE(
				_cnt1 <= 0,
				nullptr);
		}

		int ret = lck->LockReadGuard(scgLock, msWait);

		RETVAL_ON_NP(
			ret,
			nullptr);

		return t;
	}
	//T*		GetUnsafe()
	//{
	//	if(_bx)
	//	{
	//		RETVAL_ON_TRUE(
	//			_cnt2 <= 0,
	//			nullptr);
	//		return &_t2;
	//	}
	//	else
	//	{
	//		RETVAL_ON_TRUE(
	//			_cnt1 <= 0,
	//			nullptr);
	//		return &_t1;
	//	}
	//}
	int		Get(const T &tDst, ms_t1 msWait = LOCK_TIME_INFINITE) const
	{
		lock_t* lck = nullptr;
		const T* t = nullptr;

		if(_nx)
		{
			lck = &_l2;
			t = &_t2;
			RETVAL_ON_TRUE(
				_cnt2 <= 0,
				-2);
		}
		else
		{
			lck = &_l1;
			t = &_t1;
			RETVAL_ON_TRUE(
				_cnt1 <= 0,
				-2);
		}

		scope_guard scgLock;
		int ret = lck->LockGuard(scgLock, msWait);

		RETVAL_ON_NP(
			ret,
			-1);

		tDst = *t;

		return 1;
	}
};

#pragma endregion BiSwap


#pragma region LRUer
/************************
 LRUer
*************************/
template<class T>
struct LargerLRUer
	: public std::binary_function<T, T, bool>
{
bool operator()(const T& _Left, const T& _Right) const
	{
	return (_Left.second > _Right.second);
	}
};


template<class TKey, class TVal>
class LRUer
{
public:
	typedef __int64								LRUerCnt;
	//typedef std::tuple<TKey, TVal*, LRUerCnt>	LRUerVal;

	struct node_t
	{
		TKey		key;
		TVal		val;
		LRUerCnt	cnt;
		node_t():
			key		(0),
			val		(),
			cnt		(0){}
		node_t Copy()
		{
			node_t n;
			n.key = key;
			n.val = val;
			n.cnt = cnt;
			return n;
		}
	};
protected:
	typedef LRUerCnt						cnt_t;
	typedef TKey							key_t;

	typedef std::list<node_t>				lst_t;
	typedef typename lst_t::iterator		lst_i;
	typedef unordered_map<key_t, lst_i>		map_t;
	typedef typename map_t::iterator		map_i;

protected:
	naive_lock		_lock;

	map_t			_map;
	lst_t			_list;

	int				_capacity;
protected:
private:
	LRUer(const LRUer &);
	LRUer(const LRUer &&);
	LRUer& operator = (const LRUer &);
public:
	LRUer():
		_lock		(),
		_list		(),
		_map		(),
		_capacity	(8)
	{}
	~LRUer(){ clear();}

	// access the node with [key], adjust priority. fail if key not exists
	int			access(key_t key, node_t *out = nullptr)
	{
		// Lock
		scope_guard scgLock;
		_lock.LockGuard(scgLock);
		
		// Validate exist
		map_i itMap = _map.find(key);
		if(_map.end() == itMap)
		{
			return 0;
		}

		// access
		lst_i itLst = *itMap;
		_list.splice(_list.begin(), _list, itLst);
		// update map
		//_map[key] = _list.begin();
		// update count
		++(itLst->cnt);

		// out
		if(nullptr != out)
		{
			*out = *itLst;
		}

		return 1;
	}

	// push a new node, eliminate least priority node if full. fail if key already exists
	int			push(key_t key, TVal *val, node_t *out = nullptr)
	{
		// Validate val ptr
		if(nullptr == val)
		{
			return -1;
		}
		
		// Lock
		scope_guard scgLock;
		_lock.LockGuard(scgLock);

		// Validate not exist
		map_i itMap = _map.find(key);
		if(_map.end() != itMap)
		{
			return 0;
		}

		// push node
		_list.emplace_front(key, val, 0);
		// update map
		_map[key] = _list.begin();

		// eliminate
		if(_list.size() > _capacity)
		{
			int ret = eliminate(out);
			RET_ON_NEG(ret);

			return 2;
		}

		return 1;
	}

	// find the node with [key]. do no adjust priority
	int			find(key_t key, node_t *out = nullptr) const
	{
		// Lock
		scope_guard scgLock;
		_lock.LockGuard(scgLock);

		// find
		map_i itMap = _map.find(key);
		if(_map.end() == itMap)
		{
			return 0;
		}

		// out
		if(nullptr != out)
		{
			*out = **itMap;
		}

		return 1;
	}
	// remove the node with [key].
	int			remove(key_t key, node_t *out = nullptr)
	{
		// Lock
		scope_guard scgLock;
		_lock.LockGuard(scgLock);

		// Validate exist
		map_i itMap = _map.find(key);
		if(_map.end() == itMap)
		{
			return 0;
		}

		// out
		node_t valOut = **itMap;

		// remove
		_list.erase(*itMap);
		_map.erase(itMap);

		scgLock.Clear();
		
		// out
		if(nullptr != out)
		{
			*out = valOut;
		}

		return 1;
	}
	// clear all
	int			clear()
	{
		// Lock
		scope_guard scgLock;
		_lock.LockGuard(scgLock);

		_map.clear();
		_list.clear();

		return 1;
	}

	// eliminate the least priority node
	int			eliminate(node_t *out = nullptr)
	{
		// Validate size
		if(_list.size() == 0)
		{
			return -1;
		}
		
		// Lock
		scope_guard scgLock;
		_lock.LockGuard(scgLock);

		// out
		node_t valOut = _list.back();

		key_t key = (_list.back()).key;
		// remove
		_map.erase(key);
		_list.pop_back();
		
		// out
		if(nullptr != out)
		{
			*out = valOut;
		}

		return 1;
	}
	// change the node (of [key]) value to [val]
	int			change_val(key_t key, TVal *val, node_t *out = nullptr)
	{
		// Validate val ptr
		if(nullptr == val)
		{
			return -1;
		}
		
		// Lock
		scope_guard scgLock;
		_lock.LockGuard(scgLock);
		
		// Validate exist
		map_i itMap = _map.find(key);
		if(_map.end() == itMap)
		{
			return 0;
		}

		// out
		node_t valOut = **itMap;

		// change
		node_t &node = **itMap;
		node.val = val;
		node.cnt = 0;
		
		// out
		if(nullptr != out)
		{
			*out = valOut;
		}

		return 1;
	}

	size_t		size() const
	{
		// Lock TODO: needed?
		//scope_guard scgLock;
		//_lock.LockGuard(scgLock);

		return _list.size();
	}
	#pragma endregion LRUer

};

#undef _IMGDISP_SOURCE_FILE_UTILITY_H
#define _IMGDISP_SOURCE_FILE_UTILITY_CPP

#include "pch.h"

#include <shellapi.h> 

#include "utility.h"



/************************
 Rectangle
*************************/
#pragma region FIXED_POINTRECT
#ifdef USE_FIXED_POINTRECT

const baseRECT baseRECT::DefaultRect = baseRECT();

baseRECT baseRECT::FromXYWH(int x, int y, int w, int h)
{
	return baseRECT(x, y, x + w - 1, y + h - 1);
}

baseRECT baseRECT::FromPWH(const basePOINT &pt, int w, int h)
{
	return baseRECT(pt.x, pt.y, pt.x + w - 1, pt.y + h - 1);
}

baseRECT baseRECT::FromTLBR(const basePOINT &ptTL, const basePOINT &ptBR)
{
	return baseRECT(ptTL.x, ptTL.y, ptBR.x, ptBR.y);
}

baseRECT::baseRECT():
	left	(0),
	top		(0),
	right	(-1),
	bottom	(-1)
{
}

baseRECT::baseRECT(int l, int t, int r, int b):
	left	(l),
	top		(t),
	right	(r),
	bottom	(b)
{
}

bool baseRECT::IsPointInside(const basePOINT &pt) const
{
	return pt.x >= left && pt.x <= right &&
		pt.y >= top && pt.y <= bottom;
}

basePOINT baseRECT::BasePoint() const
{
	return basePOINT(left, top);
}

basePOINT baseRECT::EndPoint() const
{
	return basePOINT(right, bottom);
}

void baseRECT::SetFromTLBR(const basePOINT &ptTL, const basePOINT &ptBR)
{
	left	= ptTL.x;
	top		= ptTL.y;
	right	= ptBR.x;
	bottom	= ptBR.y;
}

bool baseRECT::Offset(const basePOINT &ptOff)
{
	left += ptOff.x;
	right += ptOff.x;
	top += ptOff.y;
	bottom += ptOff.y;

	return true;
}

bool baseRECT::Equals(const baseRECT &rc) const
{
	return left == rc.left && top == rc.top &&
		right == rc.right && bottom == rc.bottom;
}

string baseRECT::ToString(char d, char o) const
{
	return '[' +
		to_string(left) + d + to_string(top) + d +
		to_string(right) + d + to_string(bottom) + ']';
}


const int64RECT int64RECT::DefaultRect = int64RECT();

int64RECT int64RECT::FromXYWH(__int64 x, __int64 y, __int64 w, __int64 h)
{
	return int64RECT(x, y, x + w - 1, y + h - 1);
}

int64RECT int64RECT::FromPWH(const int64POINT &pt, __int64 w, __int64 h)
{
	return int64RECT(pt.x, pt.y, pt.x + w - 1, pt.y + h - 1);
}

int64RECT int64RECT::FromTLBR(const int64POINT &ptTL, const int64POINT &ptBR)
{
	return int64RECT(ptTL.x, ptTL.y, ptBR.x, ptBR.y);
}

int64RECT::int64RECT():
	left	(-1),
	top		(-1),
	right	(-1),
	bottom	(-1)
{
}

int64RECT::int64RECT(const baseRECT& rc):
	left	(rc.left),
	top		(rc.top),
	right	(rc.right),
	bottom	(rc.bottom)
{
}

int64RECT::int64RECT(__int64 l, __int64 t, __int64 r, __int64 b):
	left	(l),
	top		(t),
	right	(r),
	bottom	(b)
{
}

int64POINT int64RECT::BasePoint() const
{
	return int64POINT(left, top);
}

int64POINT int64RECT::EndPoint() const
{
	return int64POINT(right, bottom);
}

void int64RECT::SetFromTLBR(const int64POINT &ptTL, const int64POINT &ptBR)
{
	left	= ptTL.x;
	top		= ptTL.y;
	right	= ptBR.x;
	bottom	= ptBR.y;
}

bool int64RECT::Equals(const int64RECT &rc) const
{
	return left == rc.left && top == rc.top &&
		right == rc.right && bottom == rc.bottom;
}

string int64RECT::ToString(char d, char o) const
{
	return '[' +
		to_string(left) + d + to_string(top) + d +
		to_string(right) + d + to_string(bottom) + ']';
}

#endif
#pragma endregion FIXED_POINTRECT


/************************
 Memory Mapping
*************************/
#pragma region MMap
MMap::MMap():
	_status		(MMAP_STATUS::MMAP_EMPTY),
	_bFile		(false),
	_hFile		(INVALID_HANDLE_VALUE),
	_fileName	(),
	_hFileMap	(INVALID_HANDLE_VALUE),
	_pData		(nullptr),
	_mapName	(),
	_size		(-1)
{
	// Init
	SecureZeroMemory(_mapName, 256);
}

MMap::MMap(MMap &&mmap):
	_status		(MMAP_STATUS::MMAP_EMPTY),
	_bFile		(false),
	_hFile		(INVALID_HANDLE_VALUE),
	_fileName	(),
	_hFileMap	(INVALID_HANDLE_VALUE),
	_pData		(nullptr),
	_mapName	(),
	_size		(-1)
{
	// Init
	SecureZeroMemory(_mapName, 256);

	// Assign
	AssignMove(mmap);
}

MMap::~MMap()
{
	Release();
}

int MMap::AssignMove(MMap &mmap)
{
	// Clear before assignment
	MMap::ClearPreAssign();

	// Assign
	_bFile		= mmap._bFile;
	_hFile		= mmap._hFile;
	_fileName	= std::forward<string>(mmap._fileName);

	_hFileMap	= mmap._hFileMap;
	_pData		= mmap._pData;
	_size		= mmap._size;
	memcpy_s(_mapName, 256, mmap._mapName, 256);
	// Assign status last
	_status		= mmap._status;

	// Clear after move
	mmap.MMap::ClearMove();

	return 1;
}

MMap& MMap::operator = (MMap &&mmap)
{
	// Assign
	AssignMove(mmap);

	return *this;
}

void MMap::ClearPreAssign()
{
	Clear();
}

void MMap::ClearMove()
{
	_status		= MMAP_STATUS::MMAP_EMPTY;

	_bFile		= false;
	_hFile		= INVALID_HANDLE_VALUE;
	_fileName.clear();

	_hFileMap	= INVALID_HANDLE_VALUE;
	_pData		= nullptr;
	SecureZeroMemory(_mapName, 256);
	_size		= -1;
}

void MMap::Release()
{
	MMap::ClearPreAssign();
}

int MMap::CreateFileInternal(const string &fileName)
{
	// Params
	LPSECURITY_ATTRIBUTES lpSecurity = nullptr;
	DWORD dwFileAccess = (GENERIC_READ | GENERIC_WRITE);
	DWORD dwFileShareMode = (FILE_SHARE_READ|FILE_SHARE_WRITE);
	DWORD dwFileCreateMode = CREATE_NEW;//CREATE_ALWAYS
	DWORD dwFileFlags = FILE_ATTRIBUTE_NORMAL;

	// Create file
	_hFile = CreateFileA(
		fileName.c_str(),
		dwFileAccess,
		dwFileShareMode,
		lpSecurity,
		dwFileCreateMode,
		dwFileFlags,
		INVALID_HANDLE_VALUE);

	if(INVALID_HANDLE_VALUE == _hFile)
	{
		return -1;
	}

	_fileName = fileName;

	return 1;
}

int MMap::DeleteFileInternal()
{
	if(INVALID_HANDLE_VALUE == _hFile)
	{
		return 0;
	}

	// Clear member
	string oldFileName = _fileName;
	CloseHandle(_hFile);
	_hFile = INVALID_HANDLE_VALUE;
	_fileName.clear();

	// Delete file
	if(_bFile)
	{
		int ret = remove(oldFileName.c_str());
		//ret = DeleteFileA(oldFileName.c_str());
		if(0 != ret)
		{
			// Delete failed
			Logger::Log0("MMap::DeleteFileInternal: File '" + oldFileName + "' delete Failed");
			return 0;
		}
		Logger::Log0("MMap::DeleteFileInternal: File '" + oldFileName + "' deleted");
	}
	_bFile = false;
	Logger::Log0("MMap::DeleteFileInternal: No file to be deleted!?");

	return 1;
}

int MMap::CreateFileMappingInternal(const string &name, size_t size, bool bFile, const string &fileName)
{
	// Param set
	StringCchPrintfA(_mapName, 256, name.c_str());
	_size = size;
	_bFile = bFile;

	// Params
	LPSECURITY_ATTRIBUTES lpSecurity = nullptr;
	DWORD flProtect = PAGE_READWRITE;
	DWORD dwFileMapAccess = FILE_MAP_ALL_ACCESS;

	// Create file if required
	scope_guard scgFile;
	if(bFile)
	{
		// Other params
		int ret = CreateFileInternal(fileName);
		RETVAL_ON_NEG(
			ret,
			-1);

		// Set scope guard
		scgFile.SetAndEnable(
			[this](){
				DeleteFileInternal();
			});
	}

	// File mapping size
	DWORD sizeLO = (DWORD)_size;
	DWORD sizeHI = (DWORD)(_size >> 32);
	// Create File Mapping
	_hFileMap = CreateFileMappingA(
		_hFile, lpSecurity, flProtect, sizeHI, sizeLO, _mapName);
	if (nullptr == _hFileMap)
	{
		return -2;
	}

	// Disable scopeguard
	scgFile.Disable();

	return 1;
}

int MMap::CloseFileMappingInternal()
{
	// Scopeguard for File
	scope_guard scgDeleteFile([this](){
		DeleteFileInternal();
	});

	if(INVALID_HANDLE_VALUE == _hFileMap)
	{
		return 0;
	}

	// Close File mapping
	CloseHandle(_hFileMap);
	_hFileMap = INVALID_HANDLE_VALUE;

	// Clear member
	string oldMapName = _mapName;
	SecureZeroMemory(_mapName, 256);
	_size = -1;

	Logger::Log0("MMap::CloseFileMappingInternal: File Mapping '" + string(oldMapName) + "' Closed");

	return 1;
}

int MMap::MapViewInternal()
{
	// Map view
	DWORD dwFileMapAccess = FILE_MAP_ALL_ACCESS;
	_pData = MapViewOfFile(
		_hFileMap, dwFileMapAccess, 0, 0, _size);
	if (nullptr == _pData)
	{
		return -1;
	}

	return 1;
}

int MMap::UnmapViewInternal()
{
	if(nullptr == _pData)
	{
		return 0;
	}

	// Unmap file view
	UnmapViewOfFile((void*)_pData);
	_pData = nullptr;

	Logger::Log0("MMap::UnmapViewInternal: View of File Mapping '" + string(_mapName) + "' Unmaped");

	return 1;
}

HRESULT MMap::Create(const string &name, size_t size, bool bFile, const string &fileName)
{
	if(IsCreated())
	{
		Release();
	}

	if(size <= 0 || name.empty())
	{
		return E_INVALIDARG;
	}

	// Create FileMapping
	RETVAL_ON_NEG_AND(
		CreateFileMappingInternal(name, size, bFile, fileName),
		E_FAIL,
		;);
	// Set scope guard for FileMapping
	scope_guard scgFileMapping(
		[this](){
			CloseFileMappingInternal();
		});

	// Map view
	RETVAL_ON_NEG_AND(
		MapViewInternal(),
		E_FAIL,
		;);

	// Init memory
	//SecureZeroMemory(pData, size);

	// Update status
	_status = (_bFile ? MMAP_STATUS::MMAP_SYNC : MMAP_STATUS::MMAP_LIVE);

	// Disable scopeguard
	scgFileMapping.Disable();

	return S_OK;
}

HRESULT	MMap::Close()
{
	// Validate status
	if(MMAP_STATUS::MMAP_EMPTY == _status)
	{
		return E_STATUS_ERROR;
	}
	if(MMAP_STATUS::MMAP_OFFLINE == _status)
	{
		
		return E_STATUS_ERROR;
	}

	// Update status
	_status		= MMAP_STATUS::MMAP_OFFLINE;

	// Unmap file view
	UnmapViewInternal();

	return S_OK;
}

HRESULT MMap::Open()
{
	// Validate status
	if(MMAP_STATUS::MMAP_EMPTY == _status)
	{
		return E_STATUS_ERROR;
	}
	if(MMAP_STATUS::MMAP_LIVE == _status ||
		MMAP_STATUS::MMAP_SYNC == _status)
	{
		return E_STATUS_ERROR;
	}

	// Map view
	RETVAL_ON_NEG_AND(
		MapViewInternal(),
		E_FAIL,
		;);

	// Update status
	_status = (_bFile ? MMAP_STATUS::MMAP_SYNC : MMAP_STATUS::MMAP_LIVE);

	return S_OK;
}

HRESULT MMap::Clear()
{
	// Validate status
	if(MMAP_STATUS::MMAP_EMPTY == _status)
	{
		return S_ALREADY_DONE;
	}

	// Update status
	_status		= MMAP_STATUS::MMAP_EMPTY;

	// Scopeguard for FileMapping
	scope_guard scgCloseFileMapping([this](){
		CloseFileMappingInternal();
	});

	// Unmap file view TODO:ret
	UnmapViewInternal();

	return S_OK;
}

HRESULT MMap::ZeroMem(size_t len, size_t pos)
{
	if(!IsCreated())
	{
		return E_NOT_INITIALIZED;
	}

	if(len <= 0)
	{
		return E_INVALID_ARG;
	}
	
	// overflow judgement
	if(XOverflow<size_t>::AddGT(len, pos, _size))
	{
		return E_OVERFLOW;
	}

	memset(((char*)_pData + pos), 0, len);

	return S_OK;
}

HRESULT MMap::Write(const void *buf, size_t len, size_t pos)
{
	if(!IsCreated())
	{
		return E_NOT_INITIALIZED;
	}

	if(NULL == buf || len <= 0)
	{
		return E_INVALID_ARG;
	}
	
	// overflow judgement
	if(XOverflow<size_t>::AddGT(len, pos, _size))
	{
		return E_OVERFLOW;
	}

	memmove_s(((char*)_pData + pos), len, buf, len);

	return S_OK;
}

HRESULT MMap::WriteBinary(DWORD num, size_t pos)
{
	if(!IsCreated())
	{
		return E_NOT_INITIALIZED;
	}

	if(XOverflow<size_t>::AddGT(4, pos, _size))
	{
		return E_OVERFLOW;
	}

	*((DWORD*)((char *)_pData + pos)) = num;

	return S_OK;
}

HRESULT MMap::WriteBinary(char b, size_t pos)
{
	if(!IsCreated())
	{
		return E_NOT_INITIALIZED;
	}

	if(pos > _size - 1)
	{
		return E_OVERFLOW;
	}

	((char*)_pData)[pos] = b;

	return S_OK;
}

HRESULT MMap::ReadBinary(char &c, size_t pos) const
{
	if(!IsCreated())
	{
		return E_NOT_INITIALIZED;
	}

	if(pos > _size - 1)
	{
		return E_OVERFLOW;
	}

	c = ((char*)_pData)[pos];

	return S_OK;
}

HRESULT MMap::ReadBinary(DWORD &n, size_t pos) const
{
	if(!IsCreated())
	{
		return E_NOT_INITIALIZED;
	}

	if(pos > _size - 1)
	{
		return E_OVERFLOW;
	}

	n = *(DWORD*)(&((char*)_pData)[pos]);

	return S_OK;
}

#pragma endregion MMap


/************************
 Event
*************************/
#pragma region Event

Event::Event():
	bCreated	(false),
	hEvent		(INVALID_HANDLE_VALUE),
	name		()
{
}

Event::Event(const string &name, bool bAutoReset, bool initVal):
	bCreated	(false),
	hEvent		(INVALID_HANDLE_VALUE),
	name		()
{
	int ret = Create(name, bAutoReset, initVal);
}

Event::~Event()
{
	Close();
}

Event::Event(Event &&evt):
	bCreated	(false),
	hEvent		(INVALID_HANDLE_VALUE),
	name		()
{
	ClearPreAssign();

	bool bCreateOther = evt.bCreated;
	if(bCreateOther)
	{
		hEvent		= evt.hEvent;
		name		= evt.name;
		bCreated	= evt.bCreated;
	}

	evt.ClearMove();
}

Event& Event::operator = (Event &&evt)
{
	ClearPreAssign();

	bool bCreateOther = evt.bCreated;
	if(bCreateOther)
	{
		hEvent		= evt.hEvent;
		name		= evt.name;
		bCreated	= evt.bCreated;
	}

	evt.ClearMove();

	return *this;
}

int Event::Create(const string &name, bool bAutoReset, bool initVal)
{
	if(IsCreated())
	{
		Close();
	}

	HANDLE hEvt = INVALID_HANDLE_VALUE;
	hEvt = CreateEventA(NULL, bAutoReset ? FALSE : TRUE, initVal ? TRUE : FALSE, name.c_str());

	if(GetLastError() == ERROR_ALREADY_EXISTS)
	{
		return 0;
	}

	if(NULL == hEvt)
	{
		return -1;
	}

	this->name = name;
	hEvent = hEvt;
	bCreated = true;

	return 1;
}

int Event::Close()
{
	bool bCreatedOld = bCreated;
	bCreated = false;

	if(INVALID_HANDLE_VALUE != hEvent)
	{
		::CloseHandle(hEvent);
		hEvent = INVALID_HANDLE_VALUE;
	}
	name = "";

	return bCreatedOld ? 1 : 0;
}

bool Event::Signal()
{
	if(!IsCreated())
	{
		return false;
	}

	SetEvent(hEvent);

	return true;
}

int Event::Wait(DWORD dw)
{
	if(!IsCreated())
	{
		return -1;
	}

	DWORD retWait = WaitForSingleObject(hEvent, dw);
	if(WAIT_OBJECT_0 == retWait)
	{
		return 1;
	}
	else if(WAIT_TIMEOUT == retWait)
	{
		return -2;
	}

	return -3;
}


BaseTrigger::BaseTrigger():
	_func		(),
	_bEnabled	(false)
{
}

BaseTrigger::~BaseTrigger()
{
	Clear();
}

int BaseTrigger::Set(const func &fun)
{
	_func = fun;

	return 1;
}

int BaseTrigger::SetAndEnable(const func &fun)
{
	_func = fun;
	_bEnabled = true;

	return 1;
}

int BaseTrigger::Enable(const func &fun)
{
	_bEnabled = true;
	return 1;
}

int BaseTrigger::Disable(const func &fun)
{
	_bEnabled = false;
	return 1;
}

int BaseTrigger::Clear()
{
	_bEnabled = false;
	_func = func();
	return 1;
}

int BaseTrigger::Trigger()
{
	if(_func._Empty())
	{
		return -1;
	}

	_func();

	return 1;
}

#pragma endregion Event

#undef _IMGDISP_SOURCE_FILE_UTILITY_CPP
#define _IMGDISP_SOURCE_FILE_THREAD_H
#pragma once

#include <exception>
#include <vector>
#include <queue>
#include <boost/thread/thread.hpp> 

#include "lock.h"


/************************
 Using
*************************/
using std::vector;
using std::queue;
using boost::thread;

using bse::IFollowMember;


/************************
 IStoppable
*************************/
class IStoppable
{
protected:
	bool			*_bStop;// fixed LifeCycle member(move, create new, destroy in dtor)

protected:
	inline LFCTYPE void	ClearPreAssign()
	{
		SAFE_DELETE(_bStop);
	}
	inline LFCTYPE void	ClearMove()
	{
		_bStop = nullptr;
		// Recreat LifeCycle member
		_bStop = new bool(false);
	}
	inline void		Release()
	{
		IStoppable::ClearPreAssign();
	}

private:
	// Disable copy-ctor, = operator
	IStoppable(IStoppable&);
	IStoppable&		operator = (IStoppable&);
public:
	IStoppable();
	~IStoppable();
	
	IStoppable(IStoppable&& other);
	int				AssignMove(IStoppable &other);
	IStoppable&		operator = (IStoppable&& other);

	virtual bool	IsStoped() const PURE;
	inline bool		IsStopFlag() const
	{
		if(nullptr == _bStop)
		{
			return false;
		}
		return *_bStop;
	}
	inline void		Reset()
	{
		if(nullptr != _bStop)
		{
			*_bStop = false;
		}
	}
	inline bool*	GetPtr()
	{
		return _bStop;
	}
	virtual int		Stop();
};



/************************
 ThreadStoppable
*************************/
class ThreadStoppable : protected boost::thread, public IStoppable
{
protected:
	typedef	std::function<void()>	fun0;

protected:
	LFCTYPE void	ClearPreAssign() LFCOVERRIDE;
	LFCTYPE void	ClearMove() LFCOVERRIDE;
	void			Release();

private:
	// Disable copy-ctor, = operator
	ThreadStoppable(ThreadStoppable&);
	ThreadStoppable& operator = (ThreadStoppable&);
public:
	ThreadStoppable();
	~ThreadStoppable();
	
#pragma region Inherit boost::thread

	template <class F>
	explicit ThreadStoppable(F f):
		IStoppable		(),
		boost::thread	()
	{
		// TODO: must be write here?
		boost::thread::operator=(boost::thread(boost::bind(f, IStoppable::GetPtr())));
	}
	template <>
	explicit ThreadStoppable(fun0 f):
		IStoppable		(),
		boost::thread(f)
	{
	}

	ThreadStoppable(ThreadStoppable&& other);
	
	int				AssignMove(ThreadStoppable &other);
	ThreadStoppable& operator = (ThreadStoppable&& other);
	
	template <class F>
	int Set(F f)
	{
		ThreadStoppable::ClearPreAssign();

		*_bStop			= false;
		boost::thread::operator=(boost::thread(boost::bind(f, _bStop)));

		return 1;
	}
	template <>
	int Set(fun0 f)
	{
		ThreadStoppable::ClearPreAssign();
		
		*_bStop			= false;
		boost::thread::operator=(boost::thread(f));

		return 1;
	}

	void swap(ThreadStoppable& x);

	/*inline ThreadStoppable&& move()
	{
		return static_cast<ThreadStoppable&&>(boost::thread::move());
	}*/
	
	inline bool joinable() const
	{
		return boost::thread::joinable();
	}
	inline void join()
	{
		boost::thread::join();
	}

#pragma endregion Inherit boost::thread

#pragma region IStoppable

	inline virtual bool	IsStoped() const OVERRIDE
	{
		if(!joinable())
		{
			return true;
		}

		return false;
	}

#pragma endregion IStoppable

	int				StopWait();
};


/************************
 Thread Pool
*************************/
struct poolElem
{
	boost::thread	_thread;
	bool			_bTask;

protected:
	void			ClearMove();
private:
	poolElem(poolElem &p);
	poolElem&		operator = (poolElem &p);
public:
	poolElem();
	poolElem(poolElem &&p);
	poolElem&		operator = (poolElem &&p);

	void			Clear();
	inline void		Wait();
};


#define THREADPOOL_SLEEPCYCLE_DEF			1
#define THREADPOOL_TASKCOUNTMAXLIMIT_DEF	65536
#define THREADPOOL_TASKCOUNTINFINITE		-1

//template class DLLEXPORT std::vector<poolElem>;
class ThreadPoolBase : public IStoppable
{
public:
	typedef std::function<void()>	Task;
	typedef icrwb_lock				lock_t;
	//using Task = std::function<void()>;

	// Lock
	mutable lock_t		_lock;
	//HANDLE			_hEventTasks;
	//condition_variable _cv;

	// Pool
	IFollowMember<vector<poolElem>>	_pool;

	// Info
	int					_nThread;
	IFollowMember<atom8<int>>	_nIdelThread;// TODO
	// how many task is live(got from queue but not end) sync with atomic _queueTask.
	IFollowMember<atom8<int>>	_nLiveTask;

	// Settings
	string				_name;
	int					_nTaskMax;
	int					_nTaskMaxLimit;
	DWORD				_msCycle;

protected:
	LFCTYPE void	ClearPreAssign();
	LFCTYPE void	ClearMove();
	void			Release();

	virtual int		SetPool(unsigned short nThread) PURE;
	int				AssignMoveInternal(ThreadPoolBase&);
	void			StopInternal();
	int				StopWaitInternal();
	virtual int		ClearInternal();
private:
	// Disable copy-ctor, = operator
	ThreadPoolBase(ThreadPoolBase &);
	ThreadPoolBase&	operator = (ThreadPoolBase&);
public:
#pragma region LifeCycle

	ThreadPoolBase();
	explicit ThreadPoolBase(unsigned short nThread);
	ThreadPoolBase(ThreadPoolBase&&);
	virtual ~ThreadPoolBase();

	int				AssignMove(ThreadPoolBase&) LOCKCONTROLED;
	ThreadPoolBase&	operator = (ThreadPoolBase&&);

	virtual int		Clear() LOCKCONTROLED;
	virtual int		ClearAll() LOCKCONTROLED;// Clear all

#pragma endregion LifeCycle
	
#pragma region Misc
	
	inline int		ThreadCount() const
	{
		return _nThread;
	}
	virtual int		TaskCount() PURE;
	inline int		IdelCount() const
	{
		return _nIdelThread->get();
	}
	virtual bool	IsStoped() const OVERRIDE LOCKCONTROLED;
	int				SetName(const string &name) LOCKCONTROLED;
	int				SetNTaskMax(int nTask) LOCKCONTROLED;
	void			SetSleepCycle(DWORD ms);

#pragma endregion Misc
	
#pragma region Interface

	int				Set(unsigned short nThread) LOCKCONTROLED;
	
	//template<class F, class... Args>
	//virtual int	Commit(F&& f, Args&&... args)
	//virtual int		Commit(Task &&func) PURE;
	int				Stop() LOCKCONTROLED;
	int				StopWait() LOCKCONTROLED;

#pragma endregion Interface
};


// Obsolete
class ThreadPool : public ThreadPoolBase
{
protected:
	lock_t				_lockTask;
	queue<Task>			_tasks;

protected:
	LFCTYPE void	ClearPreAssign() LFCOVERRIDE;
	LFCTYPE void	ClearMove() LFCOVERRIDE;
	void			Release();

	virtual int		SetPool(unsigned short nThread) OVERRIDE;

private:
	// Disable copy-ctor, = operator
	ThreadPool(ThreadPool &);
	ThreadPool&		operator = (ThreadPool&);
public:
#pragma region LifeCycle

	ThreadPool();
	explicit ThreadPool(unsigned short nThread);
	ThreadPool(ThreadPool&&);
	ThreadPool&		operator = (ThreadPool&&);
	virtual ~ThreadPool() OVERRIDE;

	virtual int		Clear() OVERRIDE;// Clear except the lock
	virtual int		ClearAll() OVERRIDE;// Clear all

#pragma endregion LifeCycle
	
#pragma region Misc

	virtual inline int		TaskCount() OVERRIDE
	{
		return (int)_tasks.size();
	}

#pragma endregion Misc
	
#pragma region Interface

	virtual int		Commit(Task &&func);
	//virtual int		Stop() OVERRIDE;
	//virtual int		StopWait() OVERRIDE;

#pragma endregion Interface
};


class ThreadPoolStoppable : public ThreadPoolBase
{
public:
	typedef std::function<void(bool *)>	TaskStoppable;

protected:
	IFollowMember<bool>	_bStopTask;

	IFollowMember<atom<queue<TaskStoppable>>>	_queueTask;

protected:
	virtual int		SetPool(unsigned short nThread) OVERRIDE;
	virtual int		ClearInternal() OVERRIDE;
	virtual int		RemoveAllTaskInternal();
	virtual void	StopTasksAndPoolInternal();// stop tasks & pool
	virtual int		StopTasksAndPoolWaitInternal();// stop tasks & pool

protected:
	LFCTYPE void	ClearPreAssign() LFCOVERRIDE;
	LFCTYPE void	ClearMove() LFCOVERRIDE;
	void			Release();

private:
	// Disable copy-ctor, = operator
	ThreadPoolStoppable(ThreadPoolStoppable &);
	ThreadPoolStoppable&	operator = (ThreadPoolStoppable&);
public:
#pragma region LifeCycle

	ThreadPoolStoppable();
	explicit ThreadPoolStoppable(unsigned short nThread);
	ThreadPoolStoppable(ThreadPoolStoppable&&);
	virtual ~ThreadPoolStoppable() OVERRIDE;

	int				AssignMove(ThreadPoolStoppable&);
	ThreadPoolStoppable&	operator = (ThreadPoolStoppable&&);

	virtual int		Clear() OVERRIDE;

#pragma endregion LifeCycle

#pragma region Misc

	virtual int		TaskCount() OVERRIDE;
	virtual int		QueuedTaskCount();
	virtual bool	IsTaskStoped() const;

#pragma endregion Misc
	
#pragma region Interface

	virtual int		Commit(TaskStoppable &&func, ms_t1 msTimeout = LOCK_TIME_INFINITE);
	virtual int		Commit(Task &&func, ms_t1 msTimeout = LOCK_TIME_INFINITE);
	virtual int		RemoveAllTask();
	virtual int		StopTasksWait();// stop tasks only
	virtual int		StopTasksAndPool();// stop tasks & pool
	virtual int		StopTasksAndPoolWait();// stop tasks & pool

#pragma endregion Interface
};

#undef _IMGDISP_SOURCE_FILE_THREAD_H
#define _IMGDISP_SOURCE_FILE_THREAD_CPP

#include "pch.h"

#include "thread.h"


/************************
 IStoppable
*************************/
IStoppable::IStoppable():
	_bStop			(nullptr)
{
	_bStop = new bool(false);
}

IStoppable::~IStoppable()
{
	Release();
}

IStoppable::IStoppable(IStoppable&& other):
	_bStop		(other._bStop)
{
	other.IStoppable::ClearMove();
}

int IStoppable::AssignMove(IStoppable &other)
{
	// Clear before assignment
	IStoppable::ClearPreAssign();

	_bStop			= other._bStop;
	
	// Clear after move
	other.IStoppable::ClearMove();

	return 1;
}

IStoppable& IStoppable::operator = (IStoppable&& other)
{
	AssignMove(other);

	return *this;
}

int IStoppable::Stop()
{
	if(nullptr == _bStop)
	{
		return -1;
	}

	// TODO: need lock?
	if(*_bStop)
	{
		return 0;
	}

	*_bStop = true;

	return 1;
}


/************************
 ThreadStoppable
*************************/

ThreadStoppable::ThreadStoppable():
	IStoppable		(),
	boost::thread()
{
}

ThreadStoppable::~ThreadStoppable()
{
	Release();
}

ThreadStoppable::ThreadStoppable(ThreadStoppable&& other):
	IStoppable		(std::forward<IStoppable>(other)),
	boost::thread(std::forward<boost::thread>(other))
{
	other.IStoppable::ClearMove();
}

int ThreadStoppable::AssignMove(ThreadStoppable &other)
{
	// Clear before assignment
	ThreadStoppable::ClearPreAssign();

	IStoppable::operator=(std::forward<IStoppable>(other));
	boost::thread::operator=(std::forward<boost::thread>(other));

	// Clear after move
	other.ThreadStoppable::ClearMove();

	return 1;
}

ThreadStoppable& ThreadStoppable::operator = (ThreadStoppable&& other)
{
	AssignMove(other);

	return *this;
}

void ThreadStoppable::ClearPreAssign()
{
	StopWait();
}

void ThreadStoppable::ClearMove()
{
}

void ThreadStoppable::Release()
{
	ThreadStoppable::ClearPreAssign();
}

void ThreadStoppable::swap(ThreadStoppable& x)
{
	boost::thread::swap(x);

	bool *bTStop = _bStop;
	_bStop		= x._bStop;
	x._bStop	= bTStop;
}

int ThreadStoppable::StopWait()
{
	IStoppable::Stop();

	if(!joinable())
	{
		return 0;
	}

	join();

	return 1;
}


/************************
 Thread Pool
*************************/
poolElem::poolElem():
	_thread		(),
	_bTask		(false)
{
}

poolElem::poolElem(poolElem &&p):
	_thread		(std::forward<boost::thread>(p._thread)),
	_bTask		(p._bTask)
{
	Logger::Log0((string)"poolElem: ctor mvoe ");
}

poolElem& poolElem::operator = (poolElem &&p)
{
	Clear();
	
	Logger::Log0((string)"poolElem: thread mvoe ");
	_thread		= std::forward<boost::thread>(p._thread);
	_bTask		= p._bTask;

	p.poolElem::ClearMove();

	return *this;
}

void poolElem::ClearMove()
{
	_bTask		= false;
}

void poolElem::Clear()
{
	Wait();
}

void poolElem::Wait()
{
	//Logger::Log0((string)"poolElem: Wait ");
	if(_thread.joinable())
	{
		_thread.join();
	}
	//Logger::Log0((string)"poolElem: End ");

	_bTask		= false;
}


ThreadPoolBase::ThreadPoolBase():
	IStoppable			(),
	_lock				(),
	_pool				(),
	_nThread			(0),
	_nIdelThread		(0),
	_nLiveTask			(0),
	_name				(),
	_nTaskMaxLimit		(THREADPOOL_TASKCOUNTMAXLIMIT_DEF),
	_nTaskMax			(THREADPOOL_TASKCOUNTINFINITE),
	_msCycle			(THREADPOOL_SLEEPCYCLE_DEF)
{
}

ThreadPoolBase::ThreadPoolBase(unsigned short nThread):
	IStoppable			(),
	_lock				(),
	_pool				(),
	_nThread			(0),
	_nIdelThread		(0),
	_nLiveTask			(0),
	_name				(),
	_nTaskMaxLimit		(THREADPOOL_TASKCOUNTMAXLIMIT_DEF),
	_nTaskMax			(THREADPOOL_TASKCOUNTINFINITE),
	_msCycle			(THREADPOOL_SLEEPCYCLE_DEF)
{
	int ret = Set(nThread);
}

ThreadPoolBase::ThreadPoolBase(ThreadPoolBase&& pool):
	IStoppable			(),
	_lock				(),
	_pool				(),
	_nThread			(0),
	_nIdelThread		(0),
	_nLiveTask			(0),
	_name				(),
	_nTaskMaxLimit		(THREADPOOL_TASKCOUNTMAXLIMIT_DEF),
	_nTaskMax			(THREADPOOL_TASKCOUNTINFINITE),
	_msCycle			(THREADPOOL_SLEEPCYCLE_DEF)
{
	// Assign
	AssignMove(pool);
}

ThreadPoolBase::~ThreadPoolBase()
{
	// Do not lock, to not affect derived class Destructor

	Release();
}

int ThreadPoolBase::AssignMoveInternal(ThreadPoolBase& pool)
{
	// Clear before assignment
	ThreadPoolBase::ClearPreAssign();

	// Assign
	IStoppable::AssignMove(std::forward<IStoppable>(pool));
	_pool				= std::forward<IFollowMember<vector<poolElem>>>(pool._pool);
	_nThread			= pool._nThread;
	_nIdelThread		= std::forward<IFollowMember<atom8<int>>>(pool._nIdelThread);
	_nLiveTask			= std::forward<IFollowMember<atom8<int>>>(pool._nLiveTask);
	_name				= std::forward<string>(pool._name);
	_nTaskMaxLimit		= pool._nTaskMaxLimit;
	_nTaskMax			= pool._nTaskMax;
	_msCycle			= pool._msCycle;

	// Clear after move
	pool.ThreadPoolBase::ClearMove();

	return 1;
}

void ThreadPoolBase::StopInternal()
{
	IStoppable::Stop();
}

int ThreadPoolBase::StopWaitInternal()
{
	// Set stop flag
	IStoppable::Stop();

	vector<poolElem> *ppool = _pool.GetRes();
	for(int i = 0; i < ppool->size(); ++i)
	{
		(*ppool)[i].Wait();
	}

	return 1;
}

int ThreadPoolBase::ClearInternal()
{
	StopWaitInternal();

	_pool.Reset();

	IStoppable::Reset();

	// Info
	_nThread		= 0;
	_nIdelThread->set(0);
	_nLiveTask->set(0);

	// Do not clear settings

	return 1;
}

int ThreadPoolBase::AssignMove(ThreadPoolBase& pool)
{
	// ======>> LOCK OTHER <<=======
	scope_guard scgLockOther;
	pool._lock.LockGuard(scgLockOther);
	// ======>> LOCK <<=======
	scope_guard scgLock;
	_lock.LockGuard(scgLock);

	// Clear before assignment
	ThreadPoolBase::ClearPreAssign();
	
	// Assign
	IStoppable::AssignMove(std::forward<IStoppable>(pool));
	_pool				= std::forward<IFollowMember<vector<poolElem>>>(pool._pool);
	_nThread			= pool._nThread;
	_nIdelThread		= std::forward<IFollowMember<atom8<int>>>(pool._nIdelThread);
	_nLiveTask			= std::forward<IFollowMember<atom8<int>>>(pool._nLiveTask);
	_name				= std::forward<string>(pool._name);
	_nTaskMaxLimit		= pool._nTaskMaxLimit;
	_nTaskMax			= pool._nTaskMax;
	_msCycle			= pool._msCycle;

	// ======>> UNLOCK <<=======
	scgLock.Release();

	// Clear after move
	pool.ThreadPoolBase::ClearMove();

	return 1;
}

ThreadPoolBase& ThreadPoolBase::operator = (ThreadPoolBase&& pool)
{
	// Assign
	AssignMove(pool);

	return *this;
}

int ThreadPoolBase::Clear()
{
	// ======>> LOCK <<=======
	scope_guard scgLock;
	_lock.LockGuard(scgLock);

	ClearInternal();

	return 1;
}

void ThreadPoolBase::ClearPreAssign()
{
	StopWaitInternal();

	//
	// Clear member
	//
	_nThread		= 0;
	_nIdelThread->set(0);
	_nLiveTask->set(0);
	
	//
	// Clear settings
	//
	_msCycle = THREADPOOL_SLEEPCYCLE_DEF;
}

void ThreadPoolBase::ClearMove()
{
	// Pool
	//_pool

	// Info
	_nThread		= 0;
	_nIdelThread->set(0);
	_nLiveTask->set(0);

	// Clear settings
	_name.clear();
	_nTaskMax		= THREADPOOL_TASKCOUNTINFINITE;
	_nTaskMaxLimit	= THREADPOOL_TASKCOUNTMAXLIMIT_DEF;
	_msCycle		= THREADPOOL_SLEEPCYCLE_DEF;
}

void ThreadPoolBase::Release()
{
	ThreadPoolBase::ClearPreAssign();
}

int ThreadPoolBase::ClearAll()
{
	// ======>> LOCK <<=======
	scope_guard scgLock;
	_lock.LockGuard(scgLock);
	
	ClearInternal();

	// Clear settings
	_msCycle = THREADPOOL_SLEEPCYCLE_DEF;

	return 1;
}

int ThreadPoolBase::Set(unsigned short nThread)
{
	// ======>> LOCK WRITE<<=======
	scope_guard scgLockWrite;
	_lock.LockWriteGuard(scgLockWrite);

	RET_ON_NEG(
		SetPool(nThread));

	return 1;
}

bool ThreadPoolBase::IsStoped() const
{
	// ======>> LOCK IREAD<<=======
	scope_guard scgLockIRead;
	_lock.LockIReadGuard(scgLockIRead);

	const vector<poolElem> *ppool = _pool.GetResC();
	bool bStoppedActually = true;
	for(int i = 0; i < ppool->size(); ++i)
	{
		if((*ppool)[i]._thread.joinable())
		{
			bStoppedActually = false;
		}
	}

	return bStoppedActually;
}

int ThreadPoolBase::SetName(const string &name)
{
	// ======>> LOCK WRITE<<=======
	scope_guard scgLockWrite;
	_lock.LockWriteGuard(scgLockWrite);

	_name = name;

	return 1;
}

int ThreadPoolBase::SetNTaskMax(int nTask)
{
	// ======>> LOCK WRITE<<=======
	scope_guard scgLockWrite;
	_lock.LockWriteGuard(scgLockWrite);

	if(nTask > _nTaskMaxLimit)
	{
		return -1;
	}

	_nTaskMax = nTask;

	return 1;
}

void ThreadPoolBase::SetSleepCycle(DWORD ms)
{
	_msCycle = ms;
}

int ThreadPoolBase::Stop()
{
	// ======>> LOCK IREAD<<=======
	scope_guard scgLockIRead;
	_lock.LockIReadGuard(scgLockIRead);

	StopInternal();

	return 1;
}

int ThreadPoolBase::StopWait()
{
	// ======>> LOCK WRITE<<=======
	scope_guard scgLockWrite;
	_lock.LockWriteGuard(scgLockWrite);

	StopWaitInternal();

	return 1;
}

ThreadPool::ThreadPool():
	ThreadPoolBase		(),
	_lockTask			(),
	_tasks				()
{
}

ThreadPool::ThreadPool(unsigned short nThread):
	ThreadPoolBase		(nThread),
	_lockTask			(),
	_tasks				()
{
	nThread = max(nThread, 1);
	int ret = SetPool(nThread);
}

ThreadPool::ThreadPool(ThreadPool&& pool):
	ThreadPoolBase		(std::forward<ThreadPoolBase>(pool)),
	_lockTask			(),
	_tasks				(std::forward<queue<Task>>(pool._tasks))
{
	pool.ThreadPool::ClearMove();
}

ThreadPool& ThreadPool::operator = (ThreadPool &&pool)
{
	// Clear before assignment
	ThreadPool::ClearPreAssign();

	ThreadPoolBase::operator=(std::forward<ThreadPoolBase>(pool));
	_tasks				= std::forward<queue<Task>>(pool._tasks);
	
	// Clear after move
	pool.ThreadPool::ClearMove();

	return *this;
}

ThreadPool::~ThreadPool()
{
	Release();
}

void ThreadPool::ClearPreAssign()
{
}

void ThreadPool::ClearMove()
{
}

void ThreadPool::Release()
{
	ThreadPool::ClearPreAssign();
}

int ThreadPool::Clear()
{
	ThreadPoolBase::Clear();

	_tasks.swap(queue<Task>());

	return 1;
}

int ThreadPool::ClearAll()
{
	ThreadPoolBase::ClearAll();

	return 1;
}

int ThreadPool::SetPool(unsigned short nThread)
{
	// Validate basic
	if(nThread <= 0)
	{
		return -1;
	}

	// Check stop flag
	bool *bStopPool = IStoppable::GetPtr();
	if(nullptr == bStopPool)
	{
		return -2;
	}
	
	// Clear
	Clear();

	// Set stop flag
	IStoppable::Reset();

	_nThread = nThread;
	atom8<int> *pNIdelThread = _nIdelThread.GetRes();
	pNIdelThread->set(_nThread);
	vector<poolElem> *ppool = _pool.GetRes();
	ppool->resize(_nThread);
	for(int iThread = 0; iThread < _nThread; ++iThread)
	{
		(*ppool)[iThread]._thread = boost::thread(
			[this, iThread, pNIdelThread, ppool, bStopPool]()
			{
				poolElem &poolWorker = (*ppool)[iThread];

				while(!*bStopPool)
				{
					scope_guard scgLock;
					int ret = _lockTask.TryLockGuard(scgLock);
					//Logger::Log0("ThreadPool: try locked " + to_string(ret));
					CONTINUE_ON_NP_AND(
						ret,
						Sleep(_msCycle););
					
					string taskStr = "";
					Task task;
					{
						if(_tasks.empty())
						{
							scgLock.Release();
							Sleep(_msCycle);
							continue;
						}
						
						taskStr = '\'' + to_string((int)&task) + '\'';
						Logger::Log0((string)"ThreadPool: 1 task " + taskStr + " get from pool");
						task = std::move(_tasks.front());
						_tasks.pop();

						scgLock.Release();
						//Logger::Log0("ThreadPool: unlocked");
					}

					// TODO
					if(*bStopPool)
					{
						break;
					}
					
					if(!task._Empty())
					{
						Logger::Log0((string)"ThreadPool: task " + taskStr + " begin");

						pNIdelThread->dec();
						poolWorker._bTask = true;

						// Run task
						task();
						
						poolWorker._bTask = false;
						pNIdelThread->inc();

						Logger::Log0((string)"ThreadPool: task " + taskStr + " end");
					}

					Sleep(_msCycle);
				}
		}).move();
	}

	return 1;
}

int ThreadPool::Commit(Task &&func)
{
	if(IStoppable::IsStopFlag())
	{
		return -1;
	}

	scope_guard scgLock;
	RET_ON_NEG(
		_lockTask.TryLockGuard(scgLock));

	_tasks.emplace(func);

	scgLock.Release();

	return 1;
}




ThreadPoolStoppable::ThreadPoolStoppable():
	ThreadPoolBase		(),
	_bStopTask			(),
	_queueTask			()
{
}

ThreadPoolStoppable::ThreadPoolStoppable(unsigned short nThread):
	ThreadPoolBase		(nThread),
	_bStopTask			(),
	_queueTask			()
{
	nThread = max(nThread, 1);
	int ret = SetPool(nThread);
}

ThreadPoolStoppable::ThreadPoolStoppable(ThreadPoolStoppable&& pool):
	ThreadPoolBase		(),
	_bStopTask			(),
	_queueTask			()
{
	// Assign
	AssignMove(pool);
}

int ThreadPoolStoppable::AssignMove(ThreadPoolStoppable& pool)
{
	// ======>> LOCK OTHER <<=======
	scope_guard scgLockOther;
	pool._lock.LockGuard(scgLockOther);
	// ======>> LOCK <<=======
	scope_guard scgLock;
	_lock.LockGuard(scgLock);

	// Clear before assignment
	ThreadPoolStoppable::ClearPreAssign();
	
	// Assign
	ThreadPoolBase::AssignMoveInternal(std::forward<ThreadPoolBase>(pool));// call AssignMoveInternal
	_bStopTask.AssignMove(std::forward<IFollowMember<bool>>(pool._bStopTask));
	_queueTask.AssignMove(std::forward<IFollowMember<atom<queue<TaskStoppable>>>>(pool._queueTask));

	// ======>> UNLOCK <<=======
	scgLock.Release();

	// Clear after move
	pool.ThreadPoolStoppable::ClearMove();

	return 1;
}

ThreadPoolStoppable& ThreadPoolStoppable::operator = (ThreadPoolStoppable &&pool)
{
	AssignMove(pool);

	return *this;
}

ThreadPoolStoppable::~ThreadPoolStoppable()
{
	// ======>> LOCK <<=======
	scope_guard scgLock;
	_lock.LockGuard(scgLock);

	Release();
}

int ThreadPoolStoppable::Clear()
{
	// ======>> LOCK <<=======
	scope_guard scgLock;
	_lock.LockGuard(scgLock);

	return ClearInternal();
}

void ThreadPoolStoppable::ClearPreAssign()
{
}

void ThreadPoolStoppable::ClearMove()
{
}

void ThreadPoolStoppable::Release()
{
	ThreadPoolStoppable::ClearPreAssign();
}

int ThreadPoolStoppable::SetPool(unsigned short nThread)
{
	// Validate basic
	if(nThread <= 0)
	{
		return -2;
	}

	// Check stop flag
	bool *bStopPool = IStoppable::GetPtr();
	if(nullptr == bStopPool)
	{
		return -5;
	}

	// Clear
	ClearInternal();

	// Follow member extract
	vector<poolElem> *pPool		= _pool.GetRes();
	atom8<int> *pNIdelThread	= _nIdelThread.GetRes();
	atom8<int> *pNLiveTask		= _nLiveTask.GetRes();
	bool *bStopTask				= _bStopTask.GetRes();
	atom<queue<TaskStoppable>> *pQueueTask = _queueTask.GetRes();

	// Init
	_nThread = nThread;
	pNIdelThread->set(_nThread);
	pPool->resize(_nThread);

	// Set stop flag
	IStoppable::Reset();
	*_bStopTask = false;

	// 
	DWORD msCycle				= _msCycle;
	string name					= _name;
	int nThr					= _nThread;

	for(int iThread = 0; iThread < _nThread; ++iThread)
	{
		(*pPool)[iThread]._thread = boost::thread(
			[iThread, nThr, pNIdelThread, pNLiveTask,
			pPool, bStopPool, pQueueTask, bStopTask,
			msCycle, name]()
			{
				const string logH = "ThreadPoolStoppable " "'" + name + "#" + to_string(iThread) + "'" ": ";
				
				const string strIDThread = "THREAD#" + to_string(iThread + 1) + "/" + to_string(nThr) ;
				poolElem &poolWorker = (*pPool)[iThread];

				while(true)
				{
					//Ticker ticker;

					// Check StopPool signal
					if(*bStopPool)
					{
						Logger::Log0(logH, strIDThread + " INTERRUPTTED");
						break;
					}

					// Get task from queue
					string taskStr = "";
					TaskStoppable task;
					{
						function<bool(queue<TaskStoppable>*)> funcPopTask =
							[&task, pNLiveTask](queue<TaskStoppable> *pQT)
							{
								if(nullptr == pQT)
								{
									return false;
								}
								if(pQT->empty())
								{
									return false;
								}
								task = std::move(pQT->front());
								pQT->pop();
								pNLiveTask->inc();
								return true;
							};
						bool retPopTask = false;
						pQueueTask->execute(
							funcPopTask, retPopTask,
							LOCK_TIME_INFINITE);

						if(!retPopTask)
						{
							Sleep(msCycle);
							continue;
						}
						
						taskStr = "'" + to_string((int)&task) + "'";
						//Logger::Log0(logH + "1 Task " + taskStr + " got from pool ");
					}

					// Check StopPool signal
					if(*bStopPool)
					{
						Logger::Log0(logH, strIDThread + " INTERRUPTTED");
						break;
					}
					
					if(!task._Empty())
					{
						Logger::Log0(logH + "Task " + taskStr + " Begin");

						pNIdelThread->dec();
						poolWorker._bTask = true;
						// Reset stoptask flag
						*bStopTask = false;
						
						// Run task
						task(bStopTask);
						
						*bStopTask = false;
						poolWorker._bTask = false;
						pNIdelThread->inc();
						pNLiveTask->dec();

						Logger::Log0(logH + "Task " + taskStr + " End");
					}

					// Sleep
					Sleep(msCycle);

					// Check StopPool signal
					if(*bStopPool)
					{
						Logger::Log0(logH, strIDThread + " INTERRUPTTED");
						break;
					}
				}
				Logger::Log0(logH, strIDThread + " End");
		}).move();
	}

	return 1;
}

int ThreadPoolStoppable::ClearInternal()
{
	ThreadPoolBase::ClearInternal();

	StopTasksAndPoolWaitInternal();

	// Remove all tasks
	RemoveAllTaskInternal();

	return 1;
}

int ThreadPoolStoppable::RemoveAllTaskInternal()
{
	function<bool(queue<TaskStoppable>*)> funcClearTask =
		[](queue<TaskStoppable> *pQT)
		{
			if(nullptr == pQT)
			{
				return false;
			}
			pQT->swap(queue<TaskStoppable>());
			return true;
		};
	bool retClearTask = false;
	_queueTask->execute(
		funcClearTask, retClearTask,
		LOCK_TIME_INFINITE);
	if(!retClearTask)
	{
		return -2;
	}

	return 1;
}
void ThreadPoolStoppable::StopTasksAndPoolInternal()
{
	// Stop task
	*_bStopTask = true;

	// Stop pool
	StopInternal();
}

int ThreadPoolStoppable::StopTasksAndPoolWaitInternal()
{
	// Stop task
	*_bStopTask = true;

	// Remove all tasks
	//RemoveAllTaskInternal();

	// Stop pool
	return ThreadPoolBase::StopWaitInternal();
}

int ThreadPoolStoppable::Commit(TaskStoppable &&task, ms_t1 msTimeout)
{
	const string logH = "ThreadPoolStoppable " "'" + _name + "'" ": ";

	if(IStoppable::IsStopFlag())
	{
		return -1;
	}

	// ======>> LOCK WRITE <<=======
	scope_guard scgLock;
	RETVAL_ON_NP(
		_lock.LockWriteGuard(scgLock, msTimeout),
		-2);

	int nTaskInQueue = -1;
	int nTaskLive = -1;
	function<bool(queue<TaskStoppable>*)> funcPushTask =
		[&task, &nTaskInQueue, &nTaskLive, this](queue<TaskStoppable> *pQT)
		{
			if(nullptr == pQT)
			{
				return false;
			}

			// Limit task
			nTaskLive = _nLiveTask->get();
			nTaskInQueue = (int)pQT->size();
			int nTaskTotal = nTaskLive + nTaskInQueue;
			if(_nTaskMax >= 0)
			{
				if(nTaskTotal + 1 > _nTaskMax)
				{
					return false;
				}
			}
			else
			{
				if(nTaskTotal + 1 > _nTaskMaxLimit)
				{
					return false;
				}
			}

			// push Task
			pQT->emplace(task);
			nTaskInQueue = (int)pQT->size();
			return true;
		};
	bool retPushTask = false;
	RETVAL_ON_NEG(
		_queueTask->execute(
			funcPushTask, retPushTask,
			msTimeout),
		-3);

	if(!retPushTask)
	{
		return -4;
	}

	//Logger::Log0(logH +
	//	"Commit 1 task. nTaskInQueue: " + to_string(nTaskInQueue) +
	//	", nIdel: " + to_string(_nIdelThread->get()) +
	//	", nLive: " + to_string(nTaskLive));

	return 1;
}

int ThreadPoolStoppable::Commit(Task &&task, ms_t1 msTimeout)
{
	const string logH = "ThreadPoolStoppable " "'" + _name + "'" ": ";

	if(IStoppable::IsStopFlag())
	{
		return -1;
	}

	// ======>> LOCK WRITE <<=======
	scope_guard scgLock;
	RETVAL_ON_NP(
		_lock.LockWriteGuard(scgLock),
		-2);
	
	int nTaskInQueue = -1;
	int nTaskLive = -1;
	function<bool(queue<TaskStoppable>*)> funcPushTask =
		[&task, &nTaskInQueue, &nTaskLive, this](queue<TaskStoppable> *pQT)
		{
			if(nullptr == pQT)
			{
				return false;
			}

			// Limit task
			nTaskLive = _nLiveTask->get();
			nTaskInQueue = (int)pQT->size();
			int nTaskTotal = nTaskLive + nTaskInQueue;
			if(_nTaskMax >= 0)
			{
				if(nTaskTotal + 1 > _nTaskMax)
				{
					return false;
				}
			}
			else
			{
				if(nTaskTotal + 1 > _nTaskMaxLimit)
				{
					return false;
				}
			}

			// push Task
			pQT->emplace(
				[task](bool *pbStop)
				{
					task();
				});
			nTaskInQueue = (int)pQT->size();
			return true;
		};
	bool retPushTask = false;
	RETVAL_ON_NEG(
		_queueTask->execute(
			funcPushTask, retPushTask,
			msTimeout),
		-3);

	if(!retPushTask)
	{
		return -4;
	}

	//Logger::Log0(logH +
	//	"Commit 1 task. nTaskInQueue: " + to_string(nTaskInQueue) +
	//	", nIdel: " + to_string(_nIdelThread->get()) +
	//	", nLive: " + to_string(nTaskLive));

	return 1;
}

int ThreadPoolStoppable::StopTasksAndPoolWait()
{
	// ======>> LOCK WRITE <<=======
	scope_guard scgLock;
	_lock.LockWriteGuard(scgLock);

	return StopTasksAndPoolWaitInternal();
}

int ThreadPoolStoppable::StopTasksAndPool()
{
	// ======>> LOCK IREAD <<=======
	scope_guard scgLock;
	_lock.LockIReadGuard(scgLock);

	StopTasksAndPoolInternal();

	return 1;
}

int ThreadPoolStoppable::RemoveAllTask()
{
	// ======>> LOCK WRITE <<=======
	scope_guard scgLock;
	_lock.LockWriteGuard(scgLock);

	RemoveAllTaskInternal();

	return 1;
}

int ThreadPoolStoppable::StopTasksWait()
{
	// ======>> LOCK WRITE <<=======
	scope_guard scgLock;
	_lock.LockWriteGuard(scgLock);

	// TODO: for multithread, lock bStopped?	
	// Stop task
	*_bStopTask = true;
	
	// Remove all tasks
	RemoveAllTaskInternal();

	// Check till all stopped, TODO
	while(true)
	{
		bool bStoppedActually = true;
		for(int t = 0; t < _pool->size(); ++t)
		{
			if((*_pool)[t]._bTask)
			{
				bStoppedActually = false;
				break;
			}
		}

		if(bStoppedActually)
		{
			break;
		}
	}

	return 1;
}

int ThreadPoolStoppable::TaskCount()
{
	int nTaskTotal = -1;
	function<bool(queue<TaskStoppable>*)> funcGetQueuedTaskCount =
		[&nTaskTotal, this](queue<TaskStoppable> *pQT)
		{
			if(nullptr == pQT)
			{
				return false;
			}
			nTaskTotal = (int)(pQT->size() + _nLiveTask->get());
			return true;
		};
	bool ret = false;
	_queueTask->execute(
		funcGetQueuedTaskCount, ret,
		LOCK_TIME_INFINITE);

	if(!ret)
	{
		return -1;
	}

	return nTaskTotal;
}

int ThreadPoolStoppable::QueuedTaskCount()
{
	int nQueueTask = -1;
	function<bool(queue<TaskStoppable>*)> funcGetQueueTaskCount =
		[&nQueueTask](queue<TaskStoppable> *pQT)
		{
			if(nullptr == pQT)
			{
				return false;
			}
			nQueueTask = (int)pQT->size();
			return true;
		};
	bool ret = false;
	_queueTask->execute(
		funcGetQueueTaskCount, ret,
		LOCK_TIME_INFINITE);

	if(!ret)
	{
		return -1;
	}

	return nQueueTask;
}

bool ThreadPoolStoppable::IsTaskStoped() const
{
	// ======>> LOCK IREAD <<=======
	scope_guard scgLock;
	_lock.LockIReadGuard(scgLock);

	const vector<poolElem> *ppool = _pool.GetResC();
	bool bStoppedActually = true;
	for(int t = 0; t < ppool->size(); ++t)
	{
		if((*ppool)[t]._bTask)
		{
			bStoppedActually = false;
			break;
		}
	}

	return bStoppedActually;
}

#undef _IMGDISP_SOURCE_FILE_THREAD_CPP
#define _IMGDISP_SOURCE_FILE_IMGBASE_H
#pragma once

#include <vector>

#include "ippi.h"
#include "ipps.h"

#include "gdal.h"
#include "gdal_priv.h"

#include "png.h"

#include "utility.h"


/************************
 Using
*************************/
using std::vector;

using bse::funcScopeGuardNewList;
using bse::enable_if_int3264;
using bse::XOverflow;
using bse::scope_guard_comp;



/************************
 Define
*************************/
// Bit operation
#define C_QWORDBITS(Q, BITS)	((Q) & (C_QMASK(BITS)))
#define C_QMASK(BITS)			(MAXUINT64 >> (64 - (BITS)))
#define C_DMASK(BITS)			(MAXUINT32 >> (32 - (BITS)))
#define C_WMASK(BITS)			(MAXUINT16 >> (16 - (BITS)))
#define C_MASK(Q, MASK)			((Q) & (MASK))

// Compare
// SIGNED greater than/equal to UNSIGNED
#define GE_SU(s, u)			(((s) >= 0) && (((decltype(u))(s)) >= (u)))

// Image
// Offset the pointer of length s
#define OFF_PTR(p, off)			(p = (decltype(p))((byte*)(p) + (off)))
#define GO_STRIDE(p, s)			OFF_PTR(p, s)
#define IMG_OFF(x, y, s, d)		((size_t)(y)*(s) + (x)*(d))
// Go to the pixel position (x, y)
//  of an image with start pointer p,
//  and stride, depth = (s, d)
#define IMG_POS(p, x, y, s, d)	((void*)((byte*)(p) + IMG_OFF(x, y, s, d)))
#define IMG_OFFPOS(p, pos)		((p) + (pos))

#define INVALID_WIDTH		(-1)
#define INVALID_WIDTH_DIV	(0)
#define INVALID_HEIGHT		(-1)
#define INVALID_HEIGHT_DIV	(0)
#define INVALID_DEPTH		(0)
#define INVALID_STRIDE		(0)
#define INVALID_SIZE		(0)

// Color
#define COL_PART(v)			(min(max((v), 0), 255))
#define R_PART(col)			((byte)((col >>  0) & 0xFF))
#define G_PART(col)			((byte)((col >>  8) & 0xFF))
#define B_PART(col)			((byte)((col >> 16) & 0xFF))
#define A_PART(col)			((byte)((col >> 24) & 0xFF))
#define R_PART_LE(col)		((byte)((col >> 16) & 0xFF))
#define G_PART_LE(col)		((byte)((col >>  8) & 0xFF))
#define B_PART_LE(col)		((byte)((col >>  0) & 0xFF))
#define A_PART_LE(col)		((byte)((col >> 24) & 0xFF))
#define R_PART_LE_PURE(col)	((col >> 16) & 0xFF)
#define G_PART_LE_PURE(col)	((col >>  8) & 0xFF)
#define B_PART_LE_PURE(col)	((col >>  0) & 0xFF)
#define A_PART_LE_PURE(col)	((col >> 24) & 0xFF)
#define RGB_LE(r,g,b)		((COLORREF)(((byte)(b)|((word)((byte)(g))<<8))|(((dword)(byte)(r))<<16)))
#define RGB_A_LE(r,g,b,a)	((COLORREF)(((byte)(b)|((word)((byte)(g))<<8))|(((dword)(byte)(r))<<16)|(((dword)(byte)(a))<<24)))

#define ALPHABLEND(bc1, bc2, a)		((bc1*a + bc2*(255 - a))/255)

#define COLOR4B_LE_BLACK	(RGB_LE(0, 0, 0))


#define RET_ON_ALLOC_FAIL(alloc, stts)	DO_SOMETHING(try{\
											DO_SOMETHING(alloc);\
										}\
										catch(std::exception ex){\
											DO_SOMETHING(stts);\
											return IMGSYS_RET::ISR_ALLOCFAIL;\
										})


namespace ImgDisplay
{

#pragma region Typedef
/************************
 basic type define
*************************/
typedef unsigned __int8		byte;
typedef unsigned __int16	word;
typedef unsigned __int32	dword;
typedef unsigned __int64	qword;

typedef __int8				int8;
typedef __int16				int16;
typedef __int32				int32;
typedef __int64				int64;
//typedef __int128			int128;

typedef unsigned __int8		uint8,		ui8;
typedef unsigned __int16	uint16,		ui16;
typedef unsigned __int32	uint32,		ui32;
typedef unsigned __int64	uint64,		ui64;
//typedef unsigned __int128	uint128,	ui128;

typedef COLORREF			COLOR4B;

/************************
 image specification type define
*************************/
typedef	double				imgratio,	iratio;

typedef int32				imgcoord,	icoord;
typedef int32				imglen,		ilen;

#define IMGSIZE_MAX			MAX_OF_UNSIGNEDTYPE(imgsize)
typedef ui64				imgsize,	isize;
typedef ui64				imgoff,		ioff;

typedef int64				imgcoord64,	icoord64;
typedef int64				imglen64,	ilen64;

// type of 'base image'
typedef icoord				iDimB;
typedef iDimB				icoordB, ilenB;
// type of 'zoomed image'
typedef icoord64			iDimZ;
typedef iDimZ				icoordZ, ilenZ;

//typedef POINT32				POINTB, VEC2B;
//typedef POINT64				POINTZ, VEC2Z;
//typedef RECT32				RECTB;
//typedef RECT64				RECTZ;

//typedef POINTX<iDimB>		POINTXB;
//typedef POINTX<iDimZ>		POINTXZ;
typedef RECTX<iDimB>		RECTXB;
typedef RECTX<iDimZ>		RECTXZ;

#ifdef USE_64BIT_IMGDISP

typedef int64				istride;

#else

typedef int32				istride;

#endif
#define IMGDEPTH_MAX		MAX_OF_SIGNEDTYPE(idepth)
typedef int32				idepth;

#pragma endregion Typedef


#pragma region Image-Enums
enum IMG_FILETYPE
{
	IFT_UNKNOWN		= -1,
	IFT_BMP			= 0,
	IFT_PNG			= 1,
	IFT_JPEG		= 2,
	IFT_TIFF		= 3,
	IFT_GIF			= 4
};

enum IMGDISP_PIXELFORMAT
{
	IPF_UNKNOWN		= -1,
	IPF_BGR32		= 1,
	IPF_GRAY16		= 2
	//BGRA32,
	//GRAY8
	//BLACKWHITE
};


enum IMAGESYSTEM_RETURNVALUE
{
	// General
	ISR_NULLPTR			= -1,
	ISR_NULLIMG			= -2,
	ISR_OVERFLOW		= -3,

	// Member
	ISR_NULLMEMPTR		= -10,
	ISR_NULLMEM			= -11,
	ISR_NULLLVL			= -12,
	ISR_INVMEMBER		= -14,

	// Args
	ISR_INVARGS			= -20,

	// Invalid
	ISR_INVIMGFORMAT	= -30,

	ISR_INVIMGSIZE		= -31,		// invalid image size
	ISR_INVSRCSIZE			= -32,	// invalid src image size: wBufSrc < 0 || hBufSrc < 0  ( maybe <= 0 in last level )
	ISR_INVDESTSIZE			= -33,	// invalid dest image size

	ISR_INVRCSRC		= -34,		// INVSRCSIZE || INVSRCBASE || INVSRCRANGE
	ISR_INVSRCBASE			= -35,	// xSrc, ySrc < 0
	ISR_INVSRCRANGE			= -36,	// wSrc, hSrc < 0 || x+w, y+h > sizex, sizey
	ISR_INVRCDEST		= -37,
	ISR_INVDESTBASE			= -38,
	ISR_INVDESTRANGE		= -39,

	ISR_INVTARGETSIZE	= -40,

	ISR_INVBLKRANGE		= -46,
	ISR_INVBLKSIZE		= -47,

	// Status
	ISR_INVSTATUS		= -51,

	// Fail
	ISR_FAIL			= -60,
		ISR_ALLOCFAIL		= -61,
		ISR_MEMTOOBIG		= -62,
		ISR_OPENFAIL		= -63,
		ISR_LOADFAIL		= -64,	// Load/read failed
		ISR_LOCKFAIL		= -65,
		ISR_MMAPFAIL		= -66,

	ISR_UNKNOWNOP	= -110,
	ISR_NOTFOUND	= -111,
	ISR_DONOTHING	= -120,

	ISR_POSTPROCESSFAIL	= -121,

	// No Operation
	ISR_NOOPERATION	= 0,	// TODO

	// Succeed
	ISR_SUCCEED		= 1,

	ISR_INTERRUPT	= 100,


};
typedef IMAGESYSTEM_RETURNVALUE		IMGSYS_RET;

#pragma endregion Image-Enums


#pragma region Image Helper
/************************
 Image Helper
*************************/

class DLLEXPORT ImgBase
{
public:
	static inline ui16
	GetFormatDepth(IMGDISP_PIXELFORMAT format)
	{
		switch (format)
		{
		case IMGDISP_PIXELFORMAT::IPF_BGR32:
			return 4;
		case IMGDISP_PIXELFORMAT::IPF_GRAY16:
			return 2;
		case IMGDISP_PIXELFORMAT::IPF_UNKNOWN:
			return INVALID_DEPTH;
		default:
			return INVALID_DEPTH;
		}
	}

	template<typename T>
	static typename
	enable_if_int3264<T, T>::type
	CalcStride(idepth depth, T width)
	{
		if (depth <= INVALID_DEPTH || width <= INVALID_WIDTH_DIV)
		{
			return INVALID_STRIDE;
		}
		// >> Overflow [Stride] << TODO
		if(XOverflow<T>::MulGT((T)(depth), width, MAX_OF_SIGNEDTYPE(T) - 3))
		{
			Logger::Log0("ImgBase::CalcStride: Image stride overflow!");
			return INVALID_STRIDE;
		}
		T stride = (depth * width + 3)/4*4;
		return stride;
	}

	template<typename T>
	static typename
	enable_if_int3264<T, T>::type
	CalcSize(T width, T height, IMGDISP_PIXELFORMAT format, isize &size)
	{
		idepth depth = GetFormatDepth(format);

		if (depth <= INVALID_DEPTH ||
			width <= INVALID_WIDTH_DIV || height <= INVALID_HEIGHT_DIV)
		{
			size	= 0;
			return INVALID_STRIDE;
		}
		// Calculate stride
		T stride = CalcStride(depth, width);
		if(stride <= INVALID_STRIDE)
		{
			return false;
		}

		// >> Overflow [Size] <<
		if(XOverflow<T>::MulOF<isize>(height, stride))
		{
			Logger::Log0("ImgBase::CalcSize: Image size overflow!");
			return false;
		}
		size = (isize)((isize)stride * height);

		return stride;
	}

	template<typename T>
	static typename
	enable_if_int3264<T, T>::type
	CalcStrideAndSize(idepth depth, T width, T height, T &stride, isize &size)
	{
		if (depth <= INVALID_DEPTH ||
			width <= INVALID_WIDTH_DIV || height <= INVALID_HEIGHT_DIV)
		{
			stride	= 0;
			size	= 0;
			return false;
		}

		// Calculate stride
		stride = CalcStride(depth, width);
		if(stride <= INVALID_STRIDE)
		{
			return false;
		}

		// >> Overflow [Size] <<
		if(XOverflow<T>::MulOFB<isize>(height, stride))
		{
			Logger::Log0("ImgBase::CalcStrideAndSize: Image size overflow!");
			return false;
		}
		size = (isize)((isize)stride * height);
		return true;
	}

	static ui64
	GetMaxTypeValue(idepth nTypeBit);

	static void*
	Alloc(size_t sz, scope_guard &scgAlloc);
};

class ImgHelper
{
	template<typename T>
	static inline typename
	enable_if_int3264<T, int>::type
	MipmapUp(T &x, T &y)
	{
		x = (T)((double)x / 2.0 + 0.5);
		y = (T)((double)y / 2.0 + 0.5);

		return 1;
	}
};

#pragma endregion Image Helper


#pragma region Image Process
/************************
 Image Process
*************************/

class DLLEXPORT ImgProcess
{
public:

	template<typename T>
	static typename
	enable_if_int3264<T, iret>::type
	CopyImg(
		const void *pSrc, const RECTX<T> &rcSrc, T strideSrc,
		void *pDst, const POINTX<T> &ptSrc, T strideDst,
		idepth depth)
	{
		// Assert depth of both Src & Dest image are equal

		// Validate basic
		if (nullptr == pSrc || nullptr == pDst)
		{
			return IMGSYS_RET::ISR_NULLIMG;
		}
		if(rcSrc.IsInvalid_Neg())
		{
			return IMGSYS_RET::ISR_INVRCSRC;
		}
		if(depth <= INVALID_DEPTH)
		{
			return IMGSYS_RET::ISR_INVARGS;
		}

		// Copy
		rsize_t lenRow = (rsize_t)(depth * rcSrc.Width());
		void *pRowSrc = IMG_POS(pSrc, rcSrc.left, rcSrc.top, strideSrc, depth);
		void *pRowDst = IMG_POS(pDst, ptSrc.x, ptSrc.y, strideDst, depth);
		for(T y = 0; y < rcSrc.Height(); ++y,
			GO_STRIDE(pRowSrc, strideSrc),
			GO_STRIDE(pRowDst, strideDst))
		{
			memcpy_s(pRowDst, lenRow, pRowSrc, lenRow);
		}

		return IMGSYS_RET::ISR_SUCCEED;
	}

	static bool Clear_Gray16(void* pBuf, int64 wBuf, int64 hBuf, int64 stride, COLOR4B color);

	template<typename T>
	static typename
	enable_if_int3264<T, iret>::type
	Clear_XRGB(void* pBuf, T wBuf, T hBuf, T stride, COLOR4B color)
	{
		if (nullptr == pBuf)
		{
			return false;
		}

		if (wBuf <= 0 || hBuf <= 0)
		{
			return false;
		}

		dword* pRow = (dword*)pBuf;
		for(T y = 0; y < hBuf; ++y,
			GO_STRIDE(pRow, stride))
		{
			for(T x = 0; x < wBuf; ++x)
			{
				pRow[x] = color;
			}
		}

		return true;
	}

	template<typename T>
	static typename
	enable_if_int3264<T, iret>::type
	Fill_XRGB(
		void *pBuf, T wBuf, T hBuf, T strideBuf,
		const RECTX<T> &rcFill, const COLOR4B &color)
	{
		// Validate basic
		if (nullptr == pBuf)
		{
			return IMGSYS_RET::ISR_NULLIMG;
		}
		if(wBuf <= 0 || hBuf <= 0)
		{
			return IMGSYS_RET::ISR_INVDESTSIZE;
		}

		if(rcFill.IsInvalid_Out(wBuf, hBuf))
		{
			return IMGSYS_RET::ISR_INVRCDEST;
		}

		dword* pRowDst = (dword*)IMG_POS(pBuf, rcFill.left, rcFill.top, strideBuf, 4);
	
		T wFill = rcFill.Width();
		for(T y = rcFill.top; y <= rcFill.bottom; ++y,
			GO_STRIDE(pRowDst, strideBuf))
		{
			for(T x = 0; x < wFill; ++x)
			{
				pRowDst[x] = color;
			}
		}

		return IMGSYS_RET::ISR_SUCCEED;
	}

	template<typename T>
	static typename
	enable_if_int3264<T, iret>::type
	FillExclude_XRGB(
		void* pBuf, T wBuf, T hBuf, T strideBuf,
		const COLOR4B &color,
		T xExclude, T yExclude, T rExclude, T bExclude)
	{
		// TODO: empty region fast validation
		if (xExclude <= 0 && rExclude >= wBuf &&
			yExclude <= 0 && bExclude >= hBuf)
		{
			return 2;
		}
	
		// Validate basic
		if (nullptr == pBuf)
		{
			return IMGSYS_RET::ISR_NULLIMG;
		}
		if(wBuf <= 0 || hBuf <= 0)
		{
			return IMGSYS_RET::ISR_INVDESTSIZE;
		}

		// full region validation
		if (xExclude > wBuf - 1	|| yExclude > hBuf - 1	||
			rExclude < 0		|| bExclude < 0			||
			rExclude < xExclude	|| bExclude < yExclude)
		{
			// clear full region
			ImgProcess::Clear_XRGB(pBuf, wBuf, hBuf, strideBuf, color);
			return 3;
		}

		// clip region
		xExclude = max(xExclude, 0);
		yExclude = max(yExclude, 0);
		rExclude = min(rExclude, wBuf - 1);
		bExclude = min(bExclude, hBuf - 1);

		dword* pRow = (dword*)pBuf;
		dword* pCol = (dword*)pBuf;

		// clear margin
		// top full row - row-major
		pRow = (dword*)pBuf;
		for (T row = 0; row < yExclude; ++row,
			GO_STRIDE(pRow, strideBuf))
		{
			for (T col = 0; col < wBuf; ++col)
			{
				pRow[col] = color;
			}
		}

		// left middle row - column-major
		pCol = (dword*)pBuf + wBuf * yExclude;
		for (T col = 0; col < xExclude; ++col, ++pCol)
		{
			pRow = pCol;
			for (T row = yExclude; row <= bExclude; ++row,
				GO_STRIDE(pRow, strideBuf))
			{
				*pRow = color;
			}
		}
		// right middle row - column-major
		pCol = (dword*)pBuf + wBuf * yExclude + rExclude + 1;
		for (T col = rExclude + 1; col < wBuf; ++col, ++pCol)
		{
			pRow = pCol;
			for (T row = yExclude; row <= bExclude; ++row,
				GO_STRIDE(pRow, strideBuf))
			{
				*pRow = color;
			}
		}
		// bottom full row - row-major
		pRow = (dword*)pBuf + wBuf * (bExclude + 1);
		for (T row = bExclude + 1; row < hBuf; ++row,
			GO_STRIDE(pRow, strideBuf))
		{
			for (T col = 0; col < wBuf; ++col)
			{
				pRow[col] = color;
			}
		}

		return IMGSYS_RET::ISR_SUCCEED;
	}
	template<typename T>
	static typename
	enable_if_int3264<T, iret>::type
	FillExclude_Gray16(
		void* pBuf, T wBuf, T hBuf, T strideBuf,
		const COLOR4B &color,
		T xExclude, T yExclude, T rExclude, T bExclude)
	{	
		// TODO: empty region fast validation
		if (xExclude <= 0 && rExclude >= wBuf &&
			yExclude <= 0 && bExclude >= hBuf)
		{
			return 2;
		}

		// Validate basic
		if (nullptr == pBuf)
		{
			return IMGSYS_RET::ISR_NULLIMG;
		}
		if(wBuf <= 0 || hBuf <= 0)
		{
			return IMGSYS_RET::ISR_INVDESTSIZE;
		}

		word colorVal = (word)(color);
		// full region validation
		if (xExclude > wBuf - 1	|| yExclude > hBuf - 1	||
			rExclude < 0		|| bExclude < 0			||
			rExclude < xExclude || bExclude < yExclude)
		{
			// clear full region
			ImgProcess::Clear_Gray16(pBuf, wBuf, hBuf, strideBuf, colorVal);
			return 3;
		}

		// clip region
		xExclude = max(xExclude, 0);
		yExclude = max(yExclude, 0);
		rExclude = min(rExclude, wBuf - 1);
		bExclude = min(bExclude, hBuf - 1);

		word* pRow = (word*)pBuf;
		word* pCol = (word*)pBuf;

		// clear margin
		// top full row - row-major
		pRow = (word*)pBuf;
		for (T row = 0; row < yExclude; ++row,
			GO_STRIDE(pRow, strideBuf))
		{
			for (T col = 0; col < wBuf; ++col)
			{
				pRow[col] = colorVal;
			}
		}

		// left middle row - column-major
		pCol = (word*)((byte*)pBuf + strideBuf * yExclude);
		for (T col = 0; col < xExclude; ++col, ++pCol)
		{
			pRow = pCol;
			for (T row = yExclude; row <= bExclude; ++row,
				GO_STRIDE(pRow, strideBuf))
			{
				*pRow = colorVal;
			}
		}
		// right middle row - column-major
		pCol = (word*)((byte*)pBuf + strideBuf * yExclude + (rExclude + 1) * 2);
		for (T col = rExclude + 1; col < wBuf; ++col, ++pCol)
		{
			pRow = pCol;
			for (T row = yExclude; row <= bExclude; ++row,
				GO_STRIDE(pRow, strideBuf))
			{
				*pRow = colorVal;
			}
		}
		// bottom full row - row-major
		pRow = (word*)((byte*)pBuf + strideBuf * (bExclude + 1));
		for (T row = bExclude + 1; row < hBuf; ++row,
			GO_STRIDE(pRow, strideBuf))
		{
			for (T col = 0; col < wBuf; ++col)
			{
				pRow[col] = colorVal;
			}
		}

		return IMGSYS_RET::ISR_SUCCEED;
	}


	template<typename T>
	static typename
	enable_if_int3264<T, iret>::type
	Scale(
		const void *pImgSrc, T wImgSrc, T hImgSrc, T strideSrc,
		void *pImgDst, T wImgDst, T hImgDst, T strideDst,
		int format,
		int interpolation)
	{
		// Validate basic
		if(nullptr == pImgSrc || nullptr == pImgDst)
		{
			return IMGSYS_RET::ISR_NULLIMG;
		}

		if(wImgSrc <= 0 || hImgSrc <= 0 ||
			wImgDst <= 0 || hImgDst <= 0)
		{
			return IMGSYS_RET::ISR_INVIMGSIZE;
		}

		// factor
		double xFactor = (double)wImgDst/wImgSrc;
		double yFactor = (double)hImgDst/hImgSrc;

		// ROI
		const IppiRect rcSrc = {0, 0, wImgSrc, hImgSrc};
		const IppiRect rcDst = {0, 0, wImgDst, hImgDst};
		
		int ret = -1;
		Ipp8u *buf = nullptr;
		int bufsize;
		switch(format)
		{
		case (int)IMGDISP_PIXELFORMAT::IPF_BGR32:
			ippiResizeGetBufSize(rcSrc, rcDst, 4, interpolation, &bufsize);
			buf = ippsMalloc_8u(bufsize); // memory allocation
			if (nullptr != buf) {
				IppiSize ss = {wImgSrc, hImgSrc};
				//IppiSize sd = {wImg2, hImg2};

				double xShift = 0.0;
				double yShift = 0.0;

				IppStatus s = ippiResizeSqrPixel_8u_C4R(
					(byte*)pImgSrc, ss, strideSrc, rcSrc,
					(byte*)pImgDst, strideDst, rcDst,
					xFactor, yFactor, xShift, yShift,
					interpolation,
					buf);
				ippsFree(buf);
				ret = s;
			}
			break;
		case (int)IMGDISP_PIXELFORMAT::IPF_GRAY16:
			ippiResizeGetBufSize(rcSrc, rcDst, 1, interpolation, &bufsize);
			buf = ippsMalloc_8u(bufsize); // memory allocation
			if (nullptr != buf) {
				IppiSize ss = {wImgSrc, hImgSrc};
				//IppiSize sd = {wImg2, hImg2};

				double xShift = 0.0;
				double yShift = 0.0;

				IppStatus s = ippiResizeSqrPixel_16u_C1R(
					(word*)pImgSrc, ss, strideSrc, rcSrc,
					(word*)pImgDst, strideDst, rcDst,
					xFactor, yFactor, xShift, yShift,
					interpolation,
					buf);
				ippsFree(buf);
				ret = s;
			}
			break;
		}

		return ret;
	}
	template<>
	static iret Scale(
		const void *pImgSrc, int64 wImgSrc, int64 hImgSrc, int64 strideSrc,
		void *pImgDst, int64 wImgDst, int64 hImgDst, int64 strideDst,
		int format,
		int interpolation)
	{
		// Validate basic
		if(nullptr == pImgSrc || nullptr == pImgDst)
		{
			return IMGSYS_RET::ISR_NULLIMG;
		}

		if(wImgSrc <= 0 || hImgSrc <= 0 ||
			wImgDst <= 0 || hImgDst <= 0)
		{
			return IMGSYS_RET::ISR_INVIMGSIZE;
		}

		// >> Overflow [IPP] <<
		typedef XOverflow<int64> XOverflow;
		if(XOverflow::OverflowUpper<int>(wImgSrc) || XOverflow::OverflowUpper<int>(hImgSrc) ||
			XOverflow::OverflowUpper<int>(wImgDst) || XOverflow::OverflowUpper<int>(hImgDst))
		{
			return IMGSYS_RET::ISR_OVERFLOW;
		}

		// factor
		double xFactor = (double)wImgDst/wImgSrc;
		double yFactor = (double)hImgDst/hImgSrc;

		// ROI
		const IppiRect rcSrc = {0, 0, (int)wImgSrc, (int)hImgSrc};
		const IppiRect rcDst = {0, 0, (int)wImgDst, (int)hImgDst};
		
		int ret = -1;
		Ipp8u *buf = nullptr;
		int bufsize;
		switch(format)
		{
		case (int)IMGDISP_PIXELFORMAT::IPF_BGR32:
			ippiResizeGetBufSize(rcSrc, rcDst, 4, interpolation, &bufsize);
			buf = ippsMalloc_8u(bufsize); // memory allocation
			if (nullptr != buf) {
				IppiSize ss = {(int)wImgSrc, (int)hImgSrc};
				//IppiSize sd = {wImg2, hImg2};

				double xShift = 0.0;
				double yShift = 0.0;

				IppStatus s = ippiResizeSqrPixel_8u_C4R(
					(byte*)pImgSrc, ss, strideSrc, rcSrc,
					(byte*)pImgDst, strideDst, rcDst,
					xFactor, yFactor, xShift, yShift,
					interpolation,
					buf);
				ippsFree(buf);
				ret = s;
			}
			break;
		case (int)IMGDISP_PIXELFORMAT::IPF_GRAY16:
			ippiResizeGetBufSize(rcSrc, rcDst, 1, interpolation, &bufsize);
			buf = ippsMalloc_8u(bufsize); // memory allocation
			if (nullptr != buf) {
				IppiSize ss = {(int)wImgSrc, (int)hImgSrc};
				//IppiSize sd = {wImg2, hImg2};

				double xShift = 0.0;
				double yShift = 0.0;

				IppStatus s = ippiResizeSqrPixel_16u_C1R(
					(word*)pImgSrc, ss, strideSrc, rcSrc,
					(word*)pImgDst, strideDst, rcDst,
					xFactor, yFactor, xShift, yShift,
					interpolation,
					buf);
				ippsFree(buf);
				ret = s;
			}
			break;
		}

		return ret;
	}

	// ImgProcess::RenderClip
	//  render the entire image into the buffer
	//  clip if the image is out of buffer range
	//  x,y,w,hClip indicates the clip rect of buffer
	template<typename T>
	static typename
	enable_if_int3264<T, iret>::type
	RenderClip_XRGB(
		void *pImg, T wImg, T hImg, T strideImg,
		void *pBuf, T wBuf, T hBuf, T strideBuf,
		T xDest, T yDest, T x2Dest, T y2Dest,
		int interpolation)
	{
		const idepth __depth = 4;
	
		// Validate basic
		if(nullptr == pImg || nullptr == pBuf)
		{
			return IMGSYS_RET::ISR_NULLIMG;
		}

		if(wImg <= 0 || hImg <= 0 ||
			wBuf <= 0 || hBuf <= 0)
		{
			return IMGSYS_RET::ISR_INVIMGSIZE;
		}
		
		if(x2Dest < xDest || y2Dest < yDest)
		{
			return IMGSYS_RET::ISR_INVDESTRANGE;
		}

		// Clip region
		T xClip		= (T)max(xDest, 0);
		T yClip		= (T)max(yDest, 0);
		T x2Clip	= (T)min(x2Dest, wBuf);
		T y2Clip	= (T)min(y2Dest, hBuf);
		T wClip		= (T)max(x2Clip - xClip, 0);
		T hClip		= (T)max(y2Clip - yClip, 0);

		// Factor
		double xFactor = ((double)(x2Dest - xDest)/wImg);
		double yFactor = ((double)(y2Dest - yDest)/hImg);

		// Interpolation
		if(xFactor < 1)
		{
			if(xFactor > 0.75)
			{
				interpolation = IPPI_INTER_CUBIC;
			}
			else
			{
				interpolation = IPPI_INTER_SUPER;
			}
		}
		//IPPI_INTER_SUPER
		//IPPI_INTER_CUBIC2P_CATMULLROM

		// ROI
		const IppiRect rcSrc = {0, 0, wImg, hImg};
		const IppiRect rcDst = {xClip, yClip, wClip, hClip};

		IppStatus s = IppStatus::ippStsNoErr;
		Ipp8u * buf;
		int bufsize;
		ippiResizeGetBufSize(rcSrc, rcDst, __depth, interpolation, &bufsize);
		buf = ippsMalloc_8u(bufsize); // buffer allocation
		if (nullptr != buf) {
			IppiSize ss = {wImg, hImg};
			//IppiSize sd = {wBuf, hBuf};

			// possibly loss of accuracy
			double xShift = (double)xDest;
			double yShift = (double)yDest;

			s = ippiResizeSqrPixel_8u_C4R(
				(byte*)pImg, ss, strideImg, rcSrc,
				(byte*)pBuf, strideBuf, rcDst,
				xFactor, yFactor, xShift, yShift,
				interpolation,
				buf);
			ippsFree(buf);
		}

		return s;
	}
	template<>
	static iret RenderClip_XRGB(
		void *pImg, int64 wImg, int64 hImg, int64 strideImg,
		void *pBuf, int64 wBuf, int64 hBuf, int64 strideBuf,
		int64 xDest, int64 yDest, int64 x2Dest, int64 y2Dest,
		int interpolation)
	{
		const idepth __depth = 4;

		// Validate basic
		if(nullptr == pImg || nullptr == pBuf)
		{
			return IMGSYS_RET::ISR_NULLIMG;
		}

		if(wImg <= 0 || hImg <= 0 ||
			wBuf <= 0 || hBuf <= 0)
		{
			return IMGSYS_RET::ISR_INVIMGSIZE;
		}

		if(x2Dest < xDest || y2Dest < yDest)
		{
			return IMGSYS_RET::ISR_INVDESTRANGE;
		}

		// Clip region
		int64 xClip		= (int64)max(xDest, 0);
		int64 yClip		= (int64)max(yDest, 0);
		int64 x2Clip	= (int64)min(x2Dest, wBuf);
		int64 y2Clip	= (int64)min(y2Dest, hBuf);
		int64 wClip		= (int64)max(x2Clip - xClip, 0);
		int64 hClip		= (int64)max(y2Clip - yClip, 0);

		// Factor
		double xFactor = ((double)(x2Dest - xDest)/wImg);
		double yFactor = ((double)(y2Dest - yDest)/hImg);

		// Interpolation
		if(xFactor < 1)
		{
			if(xFactor > 0.75)
			{
				interpolation = IPPI_INTER_CUBIC;
			}
			else
			{
				interpolation = IPPI_INTER_SUPER;
			}
		}
		//IPPI_INTER_SUPER
		//IPPI_INTER_CUBIC2P_CATMULLROM

		// >> Overflow [IPP] <<
		typedef XOverflow<int64>	XOverflow;
		if(XOverflow::OverflowUpper<int>(wImg) || XOverflow::OverflowUpper<int>(hImg) ||
			XOverflow::OverflowUpper<int>(xClip) || XOverflow::OverflowUpper<int>(yClip) ||
			XOverflow::OverflowUpper<int>(wClip) || XOverflow::OverflowUpper<int>(hClip))
		{
			return IMGSYS_RET::ISR_OVERFLOW;
		}

		// ROI
		const IppiRect rcSrc = {0, 0, (int)wImg, (int)hImg};
		const IppiRect rcDst = {(int)xClip, (int)yClip, (int)wClip, (int)hClip};
		
		IppStatus s = IppStatus::ippStsNoErr;
		Ipp8u * buf;
		int bufsize;
		ippiResizeGetBufSize(rcSrc, rcDst, __depth, interpolation, &bufsize);
		buf = ippsMalloc_8u(bufsize); // buffer allocation
		if (nullptr != buf) {
			IppiSize ss = {(int)wImg, (int)hImg};
			//IppiSize sd = {wBuf, hBuf};

			// possibly loss of accuracy
			double xShift = (double)xDest;
			double yShift = (double)yDest;

			s = ippiResizeSqrPixel_8u_C4R(
				(byte*)pImg, ss, strideImg, rcSrc,
				(byte*)pBuf, strideBuf, rcDst,
				xFactor, yFactor, xShift, yShift,
				interpolation,
				buf);
			ippsFree(buf);
		}

		return s;
	}

	template<typename T>
	static typename
	enable_if_int3264<T, iret>::type
	Circle_XRGB(
		void *pImg, T wImg, T hImg, T strideImg,
		POINTX<T> pt, int r = 1, const COLOR4B &color = COLOR4B_LE_BLACK)
	{
		const int depth = 4;

		// Validate basic
		if(nullptr == pImg)
		{
			return IMGSYS_RET::ISR_NULLIMG;
		}

		if(wImg <= 0 || hImg <= 0)
		{
			return IMGSYS_RET::ISR_INVIMGSIZE;
		}

		if(r <= 0)
		{
			return IMGSYS_RET::ISR_INVARGS;
		}
		T re = r - 1;
		if(XOverflow<T>::AddLT(pt.x, re, 0) || XOverflow<T>::AddGE(pt.x, -re, wImg) ||
			XOverflow<T>::AddLT(pt.y, re, 0) || XOverflow<T>::AddGE(pt.y, -re, hImg))
		{
			return IMGSYS_RET::ISR_INVDESTBASE;
		}

		T iLeft		= max(pt.x - re, 0);
		T iRight	= min(pt.x + re, wImg - 1);
		T iTop		= max(pt.y - re, 0);
		T iBottom	= min(pt.y + re, hImg - 1);

		// TODO
		double ra = r - 0.5;
		double ras = ra*ra;
		dword* pRow0 = (dword*)IMG_POS(pImg, iLeft, iTop, strideImg, depth);
		for(T iy = iTop; iy <= iBottom; ++iy, GO_STRIDE(pRow0, strideImg))
		{
			T vOff = pt.y - iy;
			double dhSpan = sqrt(ras - vOff*vOff);
			T hSpan = ceil(dhSpan - 0.5);
			double dm = dhSpan - (T)(dhSpan);
			byte alpha = (byte)(255*(dm <= 0.5 ? 0.8*dm + 0.5 : 0.8*dm - 0.3));
			T iRowLeft = pt.x - hSpan;
			T iRowRight = pt.x + hSpan;

			dword *pRow = IMG_OFFPOS(pRow0, max(iLeft, iRowLeft + 1) - iLeft);
			for(T ix = max(iLeft, iRowLeft + 1); ix <= min(iRight, iRowRight - 1); ++ix, ++pRow)
			{
				*pRow = color;
			}

			if(iRowLeft >= iLeft && iRowLeft <= iRight)
			{
				pRow = IMG_OFFPOS(pRow0, iRowLeft - iLeft);
				dword pix = *pRow;
				*pRow = RGB_LE(
					COL_PART(ALPHABLEND(R_PART_LE(color), R_PART_LE(pix), alpha)),
					COL_PART(ALPHABLEND(G_PART_LE(color), G_PART_LE(pix), alpha)),
					COL_PART(ALPHABLEND(B_PART_LE(color), B_PART_LE(pix), alpha)));
			}

			if(iRowRight >= iLeft && iRowRight <= iRight)
			{
				pRow = IMG_OFFPOS(pRow0, iRowRight - iLeft);
				dword pix = *pRow;
				*pRow = RGB_LE(
					COL_PART(ALPHABLEND(R_PART_LE(color), R_PART_LE(pix), alpha)),
					COL_PART(ALPHABLEND(G_PART_LE(color), G_PART_LE(pix), alpha)),
					COL_PART(ALPHABLEND(B_PART_LE(color), B_PART_LE(pix), alpha)));
			}
		}

		return IMGSYS_RET::ISR_SUCCEED;
	}
#ifdef USE_OBSOLETE_IMGPROCESS
	static iret RenderClip_Gray16(
		const void *pImg, int wImg, int hImg, int strideImg,
		void *pBuf, int wBuf, int hBuf, int strideBuf,
		int xDest, int yDest, int wDest, int hDest,
		int interpolation);

	// ImgProcess::RenderClip
	//  render the entire image into the buffer
	//  clip if the image is out of buffer range
	//  x,y,w,hClip indicates the clip rect of buffer
	static iret RenderClip(
		const void *pImg, int wImg, int hImg, int strideImg,
		void *pBuf, int wBuf, int hBuf, int strideBuf,
		int xDest, int yDest, int wDest, int hDest,
		int format,
		int interpolation);
#endif
};

#pragma endregion Image Process


#pragma region Image IImgSpec
/************************
 IImgSpec
*************************/

template<typename T, typename = typename enable_if_int3264<T>::type>
class DLLEXPORT IImgSpecLite
{
public:
	typedef T		iDim;
protected:
	iDim			_width;
	iDim			_height;

	idepth			_depth;
	iDim			_stride;
	isize			_size;

	static const iDim	_strideMax;
protected:
	LFCTYPE void	ClearPreAssign()
	{
	}
	LFCTYPE void	ClearMove()
	{
		_width		= INVALID_WIDTH;
		_height		= INVALID_HEIGHT;
		_depth		= INVALID_DEPTH;
		_stride		= INVALID_STRIDE;
		_size		= INVALID_SIZE;
	}


protected:
	virtual iret	SetSize(iDim width, iDim height)
	{
		if(width <= INVALID_WIDTH_DIV || width <= INVALID_HEIGHT_DIV)
		{
			return IMGSYS_RET::ISR_INVARGS;
		}

		_width		= width;
		_height		= height;

		return IMGSYS_RET::ISR_SUCCEED;
	}
	virtual iret	SetPixelFormat(IMGDISP_PIXELFORMAT format)
	{
		if (IMGDISP_PIXELFORMAT::IPF_UNKNOWN == format)
		{
			return IMGSYS_RET::ISR_INVIMGFORMAT;
		}

		// Calculate depth
		_depth = ImgBase::GetFormatDepth(format);
		RETVAL_ON_TRUE(
			_depth <= INVALID_DEPTH,
			IMGSYS_RET::ISR_INVARGS);
	
		// Calculate stride & size
		iDim stride = INVALID_STRIDE;
		RETVAL_ON_FALSE(
			ImgBase::CalcStrideAndSize(_depth, _width, _height, stride, _size),
			IMGSYS_RET::ISR_FAIL);

		// Set stride
		_stride = stride;

		return IMGSYS_RET::ISR_SUCCEED;
	}
	virtual iret	SetStrideForce(iDim strideForce)
	{
		_stride = strideForce;
		_size = _width*_height*_depth;// no padding size

		return IMGSYS_RET::ISR_SUCCEED;
	}

public:
	IImgSpecLite():
		_width		(INVALID_WIDTH),
		_height		(INVALID_HEIGHT),
		_depth		(INVALID_DEPTH),
		_stride		(INVALID_STRIDE),
		_size		(INVALID_SIZE)
	{
	}
	IImgSpecLite(const IImgSpecLite &ispec):
		_width		(ispec._width),
		_height		(ispec._height),
		_depth		(ispec._depth),
		_stride		(ispec._stride),
		_size		(ispec._size)
	{
	}

	iret			Assign(const IImgSpecLite &ispec)
	{
		// Clear before assignment
		IImgSpecLite::ClearPreAssign();

		// Assign
		_width		= ispec._width;
		_height		= ispec._height;
		_depth		= ispec._depth;
		_stride		= ispec._stride;
		_size		= ispec._size;

		return IMGSYS_RET::ISR_SUCCEED;
	}
	iret			AssignMove(IImgSpecLite &ispec)
	{
		// Clear before assignment
		IImgSpecLite::ClearPreAssign();

		// Assign
		_width		= ispec._width;
		_height		= ispec._height;
		_depth		= ispec._depth;
		_stride		= ispec._stride;
		_size		= ispec._size;

		// Clear after move
		ispec.IImgSpecLite::ClearMove();

		return IMGSYS_RET::ISR_SUCCEED;
	}
	IImgSpecLite&	operator = (const IImgSpecLite &ispec)
	{
		// Assign
		Assign(ispec);

		return *this;
	}

	virtual iret	Clear()
	{
		_width		= INVALID_WIDTH;
		_height		= INVALID_HEIGHT;
		_depth		= INVALID_STRIDE;
		_stride		= INVALID_STRIDE;
		_size		= INVALID_SIZE;

		return IMGSYS_RET::ISR_SUCCEED;
	}

	bool			FormatMatch(const IImgSpecLite& ispec) const
	{
		return _depth == ispec._depth;
	}
	inline iDim		GetWidth() const
	{
		return _width;
	}
	inline iDim		GetHeight() const
	{
		return _height;
	}
	inline iDim		GetStride() const
	{
		return _stride;
	}
	inline idepth	GetBytesPerPixel() const
	{
		return _depth;
	}

	virtual iret	SetSpec(iDim width, iDim height,
		IMGDISP_PIXELFORMAT format)
	{
		RET_ON_NEG(
			SetSize(width, height));

		RET_ON_NEG(
			SetPixelFormat(format));

		return IMGSYS_RET::ISR_SUCCEED;
	}
};


template<typename T>
class DLLEXPORT IImgSpec : public IImgSpecLite<T>
{
protected:
	// PixelFormat
	IMGDISP_PIXELFORMAT _format;

protected:
	LFCTYPE void	ClearPreAssign()
	{
	}
	LFCTYPE void	ClearMove()
	{

		// IImgSpecLite
		//IImgSpecLite

		// PixelFormat
		_format			= IMGDISP_PIXELFORMAT::IPF_UNKNOWN;
	} 

public:
	IImgSpec():
		IImgSpecLite	(),
		_format			(IMGDISP_PIXELFORMAT::IPF_UNKNOWN)
	{
	}
	IImgSpec(const IImgSpec &ispec):
		IImgSpecLite	(ispec),
		_format			(ispec._format)
	{
	}
	
	iret			Assign(const IImgSpec &ispec)
	{
		// Clear before assignment
		IImgSpec::ClearPreAssign();
	
		// Assign
		// IImgSpecLite
		RET_ON_NEG(
			IImgSpecLite::Assign(ispec));
		// PixelFormat
		_format			= ispec._format;

		return IMGSYS_RET::ISR_SUCCEED;
	}
	iret			AssignMove(IImgSpec &ispec)
	{
		// Clear before assignment
		IImgSpec::ClearPreAssign();
	
		// Assign
		// IImgSpecLite
		RET_ON_NEG(
			IImgSpecLite::AssignMove(ispec));
		// PixelFormat
		_format			= ispec._format;

		// Clear after move
		ispec.IImgSpec::ClearMove();

		return IMGSYS_RET::ISR_SUCCEED;
	}
	IImgSpec&		operator = (const IImgSpec &ispec)
	{
		// Assign
		Assign(ispec);

		return *this;
	}

	virtual iret	Clear() OVERRIDE
	{
		// IImgSpecLite
		IImgSpecLite::Clear();
		// PixelFormat
		_format			= IMGDISP_PIXELFORMAT::IPF_UNKNOWN;

		return IMGSYS_RET::ISR_SUCCEED;
	}
	
	bool			FormatMatch(const IImgSpec& ispec) const
	{
		return _format == ispec._format;
	}
	virtual iret	SetPixelFormat(IMGDISP_PIXELFORMAT format) OVERRIDE
	{
		RET_ON_NEG(
			IImgSpecLite::SetPixelFormat(format));

		_format			= format;

		return IMGSYS_RET::ISR_SUCCEED;
	}
	IMGDISP_PIXELFORMAT	GetPixelFormat() const
	{
		return _format;
	}
};

#pragma endregion Image IImgSpec


#pragma region Image Data Buffer
/************************
 Image Data Buffer
*************************/

enum IMGBUF_STATUS
{
	IBF_EMPTY		= 0,
	IBF_SPEC		= 1, //Only specification is set
	IBF_DATA		= 2
};

// Image data buffer
template<typename T>
class DLLEXPORT ImgBuf : public IImgSpec<T>
{
public:
	// Core type
	typedef	T					iDim;

	// Aux type
	typedef	RECTX<T>			IRECT;
	typedef	POINTX<T>			IPOINT, IVEC2;

private:
	// Disable copy-ctor, = operator
	ImgBuf(const ImgBuf &other);
	ImgBuf&		operator = (const ImgBuf &other);
protected:
	IMGBUF_STATUS	_status;
	void*		pImg;
	scope_guard	scgImg;

public:
	ImgBuf():
		IImgSpec		(),
		_status			(IMGBUF_STATUS::IBF_EMPTY),
		pImg			(nullptr),
		scgImg			()
	{
	}
	ImgBuf(ImgBuf&& other):
		IImgSpec		(),
		_status			(IMGBUF_STATUS::IBF_EMPTY),
		pImg			(nullptr),
		scgImg			()
	{
		AssignMove(other);
	}
	iret	AssignMove(ImgBuf& other)
	{
		// Clear pre assignment
		ImgBuf::Clear();

		// [Assign]
		IImgSpec::AssignMove(other);
		pImg	= other.pImg;
		scgImg	= std::move(other.scgImg);
		// Assign [Status] last
		_status	= other._status;

		// Clear move
		other.ImgBuf::Clear();

		return IMGSYS_RET::ISR_SUCCEED;
	}
	ImgBuf& operator = (ImgBuf&& other)
	{
		AssignMove(other);

		return *this;
	}

	iret		Setup(iDim w, iDim h, IMGDISP_PIXELFORMAT format)
	{
		// Clear first
		ImgBuf::Clear();

		// scope guard for Fail Clear
		scope_guard scgClear(
			[this](){
				ImgBuf::Clear();
			});

		// Set spec
		RET_ON_NEG(
			IImgSpec::SetSpec(w, h, format));

		// Alloc
		pImg = ImgBase::Alloc(_size, scgImg);
		RETVAL_ON_NULLPTR_AND(
			pImg,
			IMGSYS_RET::ISR_ALLOCFAIL,
			Logger::Log0("ImgBuf::Setup: Alloc error");
			);
		// TODO
		//memset(pImg, 0, sizeImg);

		// Update status
		_status = IBF_DATA;

		// Abandon scope guard for Fail Clear
		scgClear.Abandon();

		return true;
	}
	iret		SetupFrom(iDim width, iDim height, IMGDISP_PIXELFORMAT format, 
		void *pData, iDim strideForce = INVALID_STRIDE)
	{
		if(nullptr == pData)
		{
			return IMGSYS_RET::ISR_NULLPTR;
		}

		// Clear first
		ImgBuf::Clear();

		// scope guard for Fail Clear
		scope_guard scgClear(
			[this](){
				ImgBuf::Clear();
			});

		// Set spec
		RET_ON_NEG(
			IImgSpec::SetSpec(width, height, format));
		if(INVALID_STRIDE != strideForce)
		{
			RET_ON_NEG(
				IImgSpec::SetStrideForce(strideForce));
		}

		// Data
		pImg = pData;
		// TODO
		//memset(pImg, 0, sizeImg);

		// Update status
		_status = IMGBUF_STATUS::IBF_DATA;

		// Abandon scope guard for Fail Clear
		scgClear.Abandon();

		return true;
	}
	iret		SetupSpec(iDim width, iDim height, IMGDISP_PIXELFORMAT format, 
		iDim strideForce = INVALID_STRIDE)
	{
		// Clear first
		ImgBuf::Clear();

		// scope guard for Fail Clear
		scope_guard scgClear(
			[this](){
				ImgBuf::Clear();
			});

		// Set spec
		RET_ON_NEG(
			IImgSpec::SetSpec(width, height, format));
		if(INVALID_STRIDE != strideForce)
		{
			RET_ON_NEG(
				IImgSpec::SetStrideForce(strideForce));
		}

		// Update status
		_status = IMGBUF_STATUS::IBF_SPEC;

		// Abandon scope guard for Fail Clear
		scgClear.Abandon();

		return IMGSYS_RET::ISR_SUCCEED;
	}
	iret		SetupData(void *pData)
	{
		if(IMGBUF_STATUS::IBF_SPEC != _status)
		{
			return IMGSYS_RET::ISR_INVSTATUS;
		}

		if(nullptr == pData)
		{
			return IMGSYS_RET::ISR_NULLPTR;
		}

		// Data
		pImg = pData;

		// Update status
		_status = IMGBUF_STATUS::IBF_DATA;

		return IMGSYS_RET::ISR_SUCCEED;
	}
	iret		ClearData()
	{
		if(IMGBUF_STATUS::IBF_DATA != _status)
		{
			return IMGSYS_RET::ISR_INVSTATUS;
		}

		pImg = nullptr;

		// Update status
		_status = IMGBUF_STATUS::IBF_SPEC;

		return IMGSYS_RET::ISR_SUCCEED;
	}
	iret		AccessFrom(void *p, IMGDISP_PIXELFORMAT format, idepth d, iDim s,
		const IRECT &rc)
	{
		// Validate basic
		if(nullptr == p)
		{
			return IMGSYS_RET::ISR_NULLIMG;
		}
		if(IMGDISP_PIXELFORMAT::IPF_UNKNOWN == format || d < INVALID_DEPTH || s <= INVALID_STRIDE)
		{
			return IMGSYS_RET::ISR_INVARGS;
		}
		if(rc.IsInvalid_Size())
		{
			return IMGSYS_RET::ISR_INVRCSRC;
		}

		// Clear first
		ImgBuf::Clear();

		// Set
		_depth			= d;
		_stride			= s;
		_format			= format;

		pImg = IMG_POS(p, rc.left, rc.top, s, d);
		_width			= rc.Width();
		_height			= rc.Height();

		// Update status
		_status = IMGBUF_STATUS::IBF_DATA;

		return IMGSYS_RET::ISR_SUCCEED;
	}
	iret		AccessFrom(const ImgBuf& imgBuf, const IRECT &rc)
	{
		if(!imgBuf.HasData())
		{
			return IMGSYS_RET::ISR_INVARGS;
		}
		if(rc.IsInvalid_Size(imgBuf._width, imgBuf._height))
		{
			return IMGSYS_RET::ISR_INVRCSRC;
		}

		// Clear first
		ImgBuf::Clear();
		
		// Set
		_depth			= imgBuf._depth;
		_stride			= imgBuf._stride;
		_format			= imgBuf._format;

		pImg = IMG_POS(imgBuf.pImg, rc.left, rc.top, _stride, _depth);
		_width			= rc.Width();
		_height			= rc.Height();

		// Update status
		_status = IMGBUF_STATUS::IBF_DATA;

		return IMGSYS_RET::ISR_SUCCEED;
	}
	
	bool		FormatMatch(const ImgBuf& imgBuf) const
	{
		// Validate status
		if(!imgBuf.HasData())
		{
			return false;
		}
		if(!HasData())
		{
			return false;
		}

		return IImgSpec::FormatMatch(imgBuf);
	}
	iret		Clone(ImgBuf &imgBuf) const
	{
		imgBuf.ImgBuf::Clear();

		// [IImgSpec]
		imgBuf.IImgSpec::Assign(*this);
		
		// [Data]
		// Validate status
		if(!HasData())
		{
			return IMGSYS_RET::ISR_SUCCEED;
		}

		// Alloc
		void *pImgNew = ImgBase::Alloc(imgBuf._size, imgBuf.scgImg);
		RETVAL_ON_NULLPTR_AND(
			pImgNew,
			IMGSYS_RET::ISR_ALLOCFAIL,
			Logger::Log0("ImgBuf::CloneFrom: Alloc error");
			);
		RET_ON_NEG(
			ImgProcess::CopyImg(
				(const void*)pImg, Rect(), _stride,
				pImgNew, IPOINT(0, 0), imgBuf._stride,
				_depth));
		// TODO
		//memset(pImgNew, 0, sizeImg);

		imgBuf.pImg		= pImgNew;
		imgBuf._status	= _status;

		return IMGSYS_RET::ISR_SUCCEED;
	}
	iret		ScaleFrom(const ImgBuf &imgBuf, iDim w, iDim h, IRECT rcDst = IRECT::DefaultRect)
	{
		// Validate status
		if(!imgBuf.HasData())
		{
			return IMGSYS_RET::ISR_NULLIMG;
		}

		// Validate basic
		if(IRECT::DefaultRect.Equals(rcDst))
		{
			rcDst = IRECT::FromXYWH(0, 0, w, h);
		}
		if(rcDst.IsInvalid_Out(w, h))
		{
			return IMGSYS_RET::ISR_INVRCDEST;
		}

		// Clear
		ImgBuf::Clear();

		// Setup
		RETVAL_ON_NEG(
			Setup(w, h, imgBuf._format),
			IMGSYS_RET::ISR_FAIL);

		// Interpolation
		int interpolation = IPPI_INTER_NN;
		if (_width < imgBuf._width && _height < imgBuf._width)
		{
			interpolation = IPPI_INTER_SUPER;
		}

		// Dest spec
		void *pDest = IMG_POS(pImg, rcDst.left, rcDst.top, _stride, _depth);
		iDim wDest = rcDst.Width();
		iDim hDest = rcDst.Height();

		// Scale
		iret ret = ImgProcess::Scale(
			imgBuf.pImg, imgBuf._width, imgBuf._height, imgBuf._stride,
			pDest, wDest, hDest, _stride,
			(int)_format,
			interpolation);
		RET_ON_NEG(
			ret);

		return IMGSYS_RET::ISR_SUCCEED;
	}
	iret		ScaleFrom(const ImgBuf &imgBuf, IRECT rcDst = IRECT::DefaultRect)
	{
		// Validate status
		if(!imgBuf.HasData())
		{
			return IMGSYS_RET::ISR_NULLIMG;
		}
		if(!HasData())
		{
			return IMGSYS_RET::ISR_NULLIMG;
		}

		// Validate basic
		if(IRECT::DefaultRect.Equals(rcDst))
		{
			rcDst = IRECT::FromXYWH(0, 0, _width, _height);
		}

		// Interpolation
		int interpolation = IPPI_INTER_NN;
		if (_width < imgBuf._width && _height < imgBuf._height)
		{
			interpolation = IPPI_INTER_SUPER;
		}

		// Dest spec
		void *pDest = IMG_POS(pImg, rcDst.left, rcDst.top, _stride, _depth);
		iDim wDest = rcDst.Width();
		iDim hDest = rcDst.Height();

		// Scale
		iret ret = ImgProcess::Scale(
			imgBuf.pImg, imgBuf._width, imgBuf._height, imgBuf._stride,
			pDest, wDest, hDest, _stride,
			(int)_format,
			interpolation);
		RET_ON_NEG(
			ret);

		return IMGSYS_RET::ISR_SUCCEED;
	}
	iret		CopyTo(IRECT rcSrc, ImgBuf &imgBuf, const IPOINT &ptDest = IPOINT(0, 0)) const
	{
		// Validate status
		if(!imgBuf.HasData())
		{
			return IMGSYS_RET::ISR_NULLIMG;
		}
		if(!HasData())
		{
			return IMGSYS_RET::ISR_NULLIMG;
		}

		// Validate basic
		if(rcSrc.IsInvalid_Out(_width, _height))
		{
			return IMGSYS_RET::ISR_INVRCSRC;
		}
		if(ptDest.IsNegative())
		{
			return IMGSYS_RET::ISR_INVDESTBASE;
		}

		// Validate format
		if(!FormatMatch(imgBuf))
		{
			return IMGSYS_RET::ISR_INVIMGFORMAT;
		}

		// Correct region
		//rcSrc.CorrectSize(imgBuf._width, imgBuf._height);

		// Validate copy size
		if(rcSrc.IsInvalid_Size(imgBuf._width - ptDest.x, imgBuf._height - ptDest.y))
		{
			return IMGSYS_RET::ISR_INVRCSRC;
		}

		// Copy
		RET_ON_NEG(
			ImgProcess::CopyImg(
				(const void*)pImg, rcSrc, _stride,
				imgBuf.pImg, ptDest, imgBuf._stride,
				_depth));

		return IMGSYS_RET::ISR_SUCCEED;
	}

	void*		GetPImg() const
	{
		return pImg;
	}
	inline bool	HasData() const
	{
		return IMGBUF_STATUS::IBF_DATA == _status;;
	}
	inline bool	IsEmpty() const
	{
		return IMGBUF_STATUS::IBF_EMPTY == _status;
	}
	iret		Clear()
	{
		_status	= IMGBUF_STATUS::IBF_EMPTY;
		scgImg.Release();
		pImg	= nullptr;

		// [IImgSpec]
		IImgSpec::Clear();

		return IMGSYS_RET::ISR_SUCCEED;
	}

	inline IRECT	Rect() const
	{
		return IRECT(0, 0, _width - 1, _height - 1);
	}
	iret		ExtractScgComp(scope_guard_comp &comp)
	{
		if(!HasData() || scgImg.NotWork())
		{
			return IMGSYS_RET::ISR_INVSTATUS;
		}

		comp = std::move(scgImg);
		return IMGSYS_RET::ISR_SUCCEED;
	}
	iret ExportPlain(const string& file) const
	{
		ofstream out(file);
		if(!out.is_open())
		{
			return IMGSYS_RET::ISR_FAIL;
		}

		out.write((const char*)pImg, _size);

		out.close();

		return IMGSYS_RET::ISR_SUCCEED;
	}
};

#pragma endregion Image Data Buffer

}

#undef _IMGDISP_SOURCE_FILE_IMGBASE_H
#define _IMGDISP_SOURCE_FILE_IMGBASE_CPP

#include "pch.h"

#include "ImgBase.h"


namespace ImgDisplay
{

#pragma region Image Helper


ui64 ImgBase::GetMaxTypeValue(idepth nTypeBit)
{
	if(nTypeBit <= 0)
	{
		return 0;
	}
	return (((ui64)1 << nTypeBit) - 1);
}

void* ImgBase::Alloc(size_t sz, scope_guard &scgAlloc)
{
	scgAlloc.Release();

	void *p = nullptr;
	try
	{
		p = new byte[sz];
	}
	catch(std::exception ex)
	{
		return nullptr;
	}
	scgAlloc.SetAndEnable(std::bind(funcScopeGuardNewList, p));

	return p;
}

#pragma endregion Image Helper


#pragma region Image Data Buffer

#pragma endregion Image Data Buffer


#pragma region Image Process

bool ImgProcess::Clear_Gray16(
	void* pBuf, int64 wBuf, int64 hBuf, int64 stride,
	COLOR4B color)
{
	if (nullptr == pBuf)
	{
		return false;
	}

	if (wBuf <= INVALID_WIDTH_DIV || hBuf <= INVALID_HEIGHT_DIV)
	{
		return false;
	}

	word* pRow = (word*)pBuf;
	for (int64 j = 0; j < hBuf; ++j,
		GO_STRIDE(pRow, stride))
	{
		for (int64 i = 0; i < wBuf; ++i)
		{
			pRow[i] = color;
		}
	}

	return true;
}

#ifdef USE_OBSOLETE_IMGPROCESS
iret ImgProcess::RenderClip_Gray16(
	const void *pImg, int wImg, int hImg, int strideImg,
	void *pBuf, int wBuf, int hBuf, int strideBuf,
	int xDest, int yDest, int wDest, int hDest,
	int interpolation)
{
	// Validate basic
	if(nullptr == pImg || nullptr == pBuf)
	{
		return IMGSYS_RET::ISR_NULLIMG;
	}

	if(wImg <= 0 || hImg <= 0 ||
		wBuf <= 0 || hBuf <= 0)
	{
		return IMGSYS_RET::ISR_INVIMGSIZE;
	}
		
	if(wDest <= 0 || hDest <= 0)
	{
		return IMGSYS_RET::ISR_INVDESTRANGE;
	}

	int xClip   = (int)max(xDest, 0);
	int yClip   = (int)max(yDest, 0);
	int x2Clip  = (int)min(xDest + wDest, wBuf);
	int y2Clip  = (int)min(yDest + hDest, hBuf);
	int wClip   = (int)max(x2Clip - xClip, 0);
	int hClip   = (int)max(y2Clip - yClip, 0);

	// factor
	double xFactor = ((long double)wDest/wImg);
	double yFactor = ((long double)hDest/hImg);

	if(xFactor < 1)
	{
		if(xFactor > 0.75)
		{
			interpolation = IPPI_INTER_CUBIC;
		}
		else
		{
			interpolation = IPPI_INTER_SUPER;
		}
	}
	//IPPI_INTER_SUPER
	//IPPI_INTER_CUBIC2P_CATMULLROM

	// ROI
	const IppiRect rcSrc = {0, 0, wImg, hImg};
	const IppiRect rcDst = {xClip, yClip, wClip, hClip};
		
	IppStatus s = IppStatus::ippStsNoErr;
	Ipp8u * buf;
	int bufsize;
	ippiResizeGetBufSize(rcSrc, rcDst, 1, interpolation, &bufsize);
	buf = ippsMalloc_8u(bufsize); // buffer allocation
	if (nullptr != buf) {
		IppiSize ss = {wImg, hImg};
		//IppiSize sd = {wBuf, hBuf};
		
		// possibly loss of accuracy
		double xShift = (double)xDest;
		double yShift = (double)yDest;

		s = ippiResizeSqrPixel_16u_C1R(
			(word*)pImg, ss, strideImg, rcSrc,
			(word*)pBuf, strideBuf, rcDst,
			xFactor, yFactor, xShift, yShift,
			interpolation,
			buf);
		ippsFree(buf);
	}

	return s;
}

iret ImgProcess::RenderClip(
	const void *pImg, int wImg, int hImg, int strideImg,
	void *pBuf, int wBuf, int hBuf, int strideBuf,
	int xDest, int yDest, int wDest, int hDest,
	int format,
	int interpolation)
{
	// Validate basic
	if(nullptr == pImg || nullptr == pBuf)
	{
		return IMGSYS_RET::ISR_NULLIMG;
	}

	if(wImg <= 0 || hImg <= 0 ||
		wBuf <= 0 || hBuf <= 0)
	{
		return IMGSYS_RET::ISR_INVIMGSIZE;
	}
		
	if(wDest <= 0 || hDest <= 0)
	{
		return IMGSYS_RET::ISR_INVDESTRANGE;
	}

	int xClip	= (int)max(xDest, 0);
	int yClip	= (int)max(yDest, 0);
	int x2Clip	= (int)min(xDest + wDest, wBuf);
	int y2Clip	= (int)min(yDest + hDest, hBuf);
	int wClip	= (int)max(x2Clip - xClip, 0);
	int hClip	= (int)max(y2Clip - yClip, 0);

	// factor
	double xFactor = (double)wDest/wImg;
	double yFactor = (double)hDest/hImg;

	if(xFactor < 1)
	{
		if(xFactor > 0.75)
		{
			interpolation = IPPI_INTER_CUBIC;
		}
		else
		{
			interpolation = IPPI_INTER_SUPER;
		}
	}
	//IPPI_INTER_SUPER
	//IPPI_INTER_CUBIC2P_CATMULLROM

	// ROI
	const IppiRect rcSrc = {0, 0, wImg, hImg};
	const IppiRect rcDst = {xClip, yClip, wClip, hClip};
		
	IppStatus s = IppStatus::ippStsNoErr;
	Ipp8u * buf;
	int bufsize;
	switch(format)
	{
	case (int)IMGDISP_PIXELFORMAT::IPF_BGR32:
		ippiResizeGetBufSize(rcSrc, rcDst, 4, interpolation, &bufsize);
		buf = ippsMalloc_8u(bufsize); // buffer allocation
		if (nullptr != buf) {
			IppiSize ss = {wImg, hImg};
			//IppiSize sd = {wBuf, hBuf};

			double xShift = (double)xDest;
			double yShift = (double)yDest;

			s = ippiResizeSqrPixel_8u_C4R(
				(byte*)pImg, ss, strideImg, rcSrc,
				(byte*)pBuf, strideBuf, rcDst,
				xFactor, yFactor, xShift, yShift,
				interpolation,
				buf);
			ippsFree(buf);
		}
		break;
	case (int)IMGDISP_PIXELFORMAT::IPF_GRAY16:
		ippiResizeGetBufSize(rcSrc, rcDst, 1, interpolation, &bufsize);
		buf = ippsMalloc_8u(bufsize); // buffer allocation
		if (nullptr != buf) {
			IppiSize ss = {wImg, hImg};
			//IppiSize sd = {wBuf, hBuf};

			double xShift = (double)xDest;
			double yShift = (double)yDest;

			s = ippiResizeSqrPixel_16u_C1R(
				(word*)pImg, ss, strideImg, rcSrc,
				(word*)pBuf, strideBuf, rcDst,
				xFactor, yFactor, xShift, yShift,
				interpolation,
				buf);
			ippsFree(buf);
		}
		break;
	}

	return s;
}
#endif

#pragma endregion Image Process


#pragma region Image IImgSpec

#pragma endregion Image IImgSpec

}

#undef _IMGDISP_SOURCE_FILE_IMGBASE_CPP
#define _IMGDISP_SOURCE_FILE_IMGBLOCKER_H
#pragma once

#include "ImgBase.h"



namespace ImgDisplay
{

#pragma region Image Blocker
/************************
 Image Blocker
*************************/
#define INVALID_BLOCKSIZE		0
#define INVALID_BLOCKSIZE_DIV	0


enum BLOCKER_STATUS
{
	BLOCKER_NOTSET	= 1,
	BLOCKER_SET		= 2
};

template<typename T>
struct BLOCKER_DIV
{
	// Core type
	typedef	T					iDim;
	typedef	iDim				idxblk;

	iDim		ori;
	idxblk		oriblk;
	iratio		ratio;
	iDim		src;
	BLOCKER_DIV():
		ori		(0),
		oriblk	(0),
		ratio	(0.0),
		src		(0)
	{
	}
	BLOCKER_DIV(iDim o, idxblk b, iratio r, iDim s):
		ori		(o),
		oriblk	(b),
		ratio	(r),
		src		(s)
	{
	}
};

template<typename T>
class DLLEXPORT Blocker
{
public:
	// Core type
	typedef	T					iDim;

	typedef	iDim				idimblk;
	typedef	iDim				idxblk;

	// Aux type
	typedef	RECTX<iDim>			IRECT;
	typedef	POINTX<iDim>		IPOINT, IVEC2;

	// Blocker type
	typedef BLOCKER_DIV<iDim>	div_s;
	typedef vector<iratio>		arr_divratio;
	typedef vector<iDim>		arr_divsrc;
	typedef vector<iDim>		arr_divdst;
	typedef vector<div_s>		arr_divori;

protected:
	// Status
	BLOCKER_STATUS	_status;

	// Basic spec info
	idimblk			_sizeBlock;

	iDim			_width;
	iDim			_height;

	// Redundant info
	idxblk			_nx;
	idxblk			_ny;

	arr_divratio	_arrDivX;
	arr_divratio	_arrDivY;
	//  source divide: equals front edge of the block with the index
	arr_divsrc		_arrDivSrcX;
	arr_divsrc		_arrDivSrcY;

	// Origin spec info
	iDim			_sizeBlockOri;
	iDim			_widthOri;
	iDim			_heightOri;
	idxblk			_iStdX;	// blocks within [0, iStdX] are standard blocks
	idxblk			_iStdY;
	arr_divori		_arrDivInfoX;
	arr_divori		_arrDivInfoY;

protected:
	virtual bool	CalcBlockCount()
	{
		if(_sizeBlock <= INVALID_BLOCKSIZE_DIV)
		{
			return false;
		}

		// >> Overflow [idxblk] <<
		//  the 2nd '+1' means: divide count is 1 larger than block count
		typedef XOverflow<iDim>	XOverflow;
		if(XOverflow::Overflow<idxblk>((_width - 1) / _sizeBlock + 1 + 1)
			|| XOverflow::Overflow<idxblk>((_height - 1) / _sizeBlock + 1 + 1))
		{
			Logger::Log0("Blocker::CalcBlockCount: idxblk overflow");
			return false;
		}

		_nx = (_width - 1) / _sizeBlock + 1;
		_ny = (_height - 1) / _sizeBlock + 1;

		return true;
	}
	virtual bool	CalcBlockDivide()// calculate block divide after spec set
	{
		RET_ON_FALSE(CalcBlockCount());

		// Calculate divide array
		_arrDivSrcX.resize(_nx + 1);
		for (idxblk i = 0; i < _nx; ++i)
		{
			_arrDivSrcX[i] = i * _sizeBlock;
		}
		_arrDivSrcX[_nx] = _width;
		_arrDivSrcY.resize(_ny + 1);
		for (idxblk j = 0; j < _ny; ++j)
		{
			_arrDivSrcY[j] = j * _sizeBlock;
		}
		_arrDivSrcY[_ny] = _height;

		// Calculate divide ratio array
		_arrDivX.resize(_nx + 1);
		for (idxblk i = 0; i < _nx; ++i)
		{
			_arrDivX[i] = (double)_arrDivSrcX[i] / _width;
		}
		_arrDivX[_nx] = 1;
		_arrDivY.resize(_ny + 1);
		for (idxblk j = 0; j < _ny; ++j)
		{
			_arrDivY[j] = (double)_arrDivSrcY[j] / _height;
		}
		_arrDivY[_ny] = 1;

		// Set Origin X
		_arrDivInfoX.resize(_nx + 1);
		for (idxblk i = 0; i < _nx + 1; ++i)
		{
			_arrDivInfoX[i].ori		= _arrDivSrcX[i];
			_arrDivInfoX[i].oriblk	= i;
			_arrDivInfoX[i].ratio	= _arrDivX[i];
			_arrDivInfoX[i].src		= _arrDivSrcX[i];
		}
		// Set Origin Y
		_arrDivInfoY.resize(_ny + 1);
		for (idxblk j = 0; j < _ny + 1; ++j)
		{
			_arrDivInfoY[j].ori		= _arrDivSrcY[j];
			_arrDivInfoY[j].oriblk	= j;
			_arrDivInfoY[j].ratio	= _arrDivY[j];
			_arrDivInfoY[j].src		= _arrDivSrcY[j];
		}
		// Set standard X, Y
		idxblk nx = (idxblk)(_arrDivInfoX.size() - 1);
		idxblk ny = (idxblk)(_arrDivInfoY.size() - 1);
		_iStdX = _arrDivInfoX[nx].ori - _arrDivInfoX[nx - 1].ori == _sizeBlockOri ?
			nx : nx - 1;
		_iStdY = _arrDivInfoY[ny].ori - _arrDivInfoY[ny - 1].ori == _sizeBlockOri ?
			ny : ny - 1;

		// Log info
		string buf0 = "div array: ";
		string buf1 = "src array: ";
		string buf2 = "ratio array: ";
		string buf3 = "blk array: ";
		for(size_t i = 0; i <= nx; ++i)
		{
			buf0 += "," + to_string(_arrDivInfoX[i].ori);
			buf1 += "," + to_string(_arrDivInfoX[i].src);
			buf2 += "," + to_string(_arrDivInfoX[i].ratio);
			buf3 += "," + to_string(_arrDivInfoX[i].oriblk);
		}
		buf0 += "; Y:";
		buf1 += "; Y:";
		buf2 += "; Y:";
		buf3 += "; Y:";
		for(size_t j = 0; j <= ny; ++j)
		{
			buf0 += "," + to_string(_arrDivInfoY[j].ori);
			buf1 += "," + to_string(_arrDivInfoY[j].src);
			buf2 += "," + to_string(_arrDivInfoY[j].ratio);
			buf3 += "," + to_string(_arrDivInfoY[j].oriblk);
		}
		/*Logger::Log0("Blocker::CalcBlockDivide: "
			"\n" + buf0 + "\n" + buf1 + "\n" + buf2 + "\n" + buf3
			+ "\n" + to_string(nx) + ", ny=" + to_string(ny)
			+ ", standard X=" + to_string(_iStdX) + ", standard Y=" + to_string(_iStdY));*/

		return true;
	}
	virtual bool	CalcBlockDivide(const Blocker &blk)
	{
		// [Set Origin X]
		const arr_divori &arrDivInfoX0 = blk._arrDivInfoX;
		size_t nDivX0 = arrDivInfoX0.size();
		RET_ON_TRUE(
			nDivX0 < 2);

		idxblk ix0 = 0;
		idxblk ix1 = 0;
		const idxblk dx0 = 2;
		const idxblk dx1 = 1;
		_arrDivInfoX.clear();
		// Add the first divide
		_arrDivInfoX.push_back(arrDivInfoX0[0]);
		ix0 += dx0;
		ix1 += dx1;
		for(; ix0 < nDivX0; ix0 += dx0, ix1 += dx1)
		{
			// Calculate new divide, based on the base divide
			const div_s &div0 = arrDivInfoX0[ix0];
			div_s div;
			div.ori		= div0.ori;
			div.oriblk	= div0.oriblk;
			div.ratio	= div0.ratio;
			iDim wOri = div0.ori - arrDivInfoX0[ix0 - 2].ori;
			div.src		= (iDim)(_arrDivInfoX.back().src + (double)wOri*_sizeBlock/_sizeBlockOri + 0.5);
		
			_arrDivInfoX.push_back(div);
		}
		// Judge the remained last base divide
		ix0 = ix0 - dx0 + 1;
		if(ix0 <= nDivX0 - 1)
		{
			const div_s &div0 = arrDivInfoX0[ix0];
			iDim w = arrDivInfoX0[ix0].ori - arrDivInfoX0[ix0 - 1].ori;
			div_s div;
			div.ori		= div0.ori;
			div.oriblk	= div0.oriblk;
			div.ratio	= div0.ratio;
			div.src		= (iDim)(_arrDivInfoX.back().src + (double)_sizeBlock*w/_sizeBlockOri + 0.5);
		
			_arrDivInfoX.push_back(div);
		}
		// [Set Origin Y]
		const arr_divori &arrDivInfoY0 = blk._arrDivInfoY;
		size_t nYOri0 = arrDivInfoY0.size();
		RET_ON_TRUE(
			nYOri0 < 2);

		idxblk iy0 = 0;
		idxblk iy1 = 0;
		const idxblk diy0 = 2;
		const idxblk diy1 = 1;
		_arrDivInfoY.clear();
		// Add the first divide
		_arrDivInfoY.push_back(arrDivInfoY0[0]);
		iy0 += diy0;
		iy1 += diy1;
		for(; iy0 < nYOri0; iy0 += diy0, iy1 += diy1)
		{
			// Calculate new divide, based on the base divide
			const div_s &div0 = arrDivInfoY0[iy0];
			div_s div;
			div.ori		= div0.ori;
			div.oriblk	= div0.oriblk;
			div.ratio	= div0.ratio;
			iDim hOri = div0.ori - arrDivInfoY0[iy0 - 2].ori;
			div.src		= (iDim)(_arrDivInfoY.back().src + (double)hOri*_sizeBlock/_sizeBlockOri + 0.5);
		
			_arrDivInfoY.push_back(div);
		}
		// Judge the remained last base divide
		iy0 = iy0 - 2 + 1;
		if(iy0 <= nYOri0 - 1)
		{
			const div_s &div0 = arrDivInfoY0[iy0];
			iDim h = arrDivInfoY0[iy0].ori - arrDivInfoY0[iy0 - 1].ori;
			div_s div;
			div.ori		= div0.ori;
			div.oriblk	= div0.oriblk;
			div.ratio	= div0.ratio;
			div.src		= (iDim)(_arrDivInfoY.back().src + (double)h*_sizeBlock/_sizeBlockOri + 0.5);
		
			_arrDivInfoY.push_back(div);
		}
		// Set standard X, Y
		idxblk nx = (idxblk)(_arrDivInfoX.size() - 1);
		idxblk ny = (idxblk)(_arrDivInfoY.size() - 1);
		_iStdX = _arrDivInfoX[nx].ori - _arrDivInfoX[nx - 1].ori == _sizeBlockOri ?
			nx : nx - 1;
		_iStdY = _arrDivInfoY[ny].ori - _arrDivInfoY[ny - 1].ori == _sizeBlockOri ?
			ny : ny - 1;


		// Set to Basic Info
		_nx = nx;
		_ny = ny;
		_width = _arrDivInfoX.back().src;
		_height = _arrDivInfoY.back().src;

		_arrDivSrcX.resize(_arrDivInfoX.size());
		for(size_t i = 0; i < _arrDivSrcX.size(); ++i)
		{
			_arrDivSrcX[i] = _arrDivInfoX[i].src;
		}
		_arrDivSrcY.resize(_arrDivInfoY.size());
		for(size_t i = 0; i < _arrDivSrcY.size(); ++i)
		{
			_arrDivSrcY[i] = _arrDivInfoY[i].src;
		}
		// Calculate divide ratio array
		_arrDivX.resize(_nx + 1);
		for (idxblk i = 0; i < _nx; ++i)
		{
			_arrDivX[i] = (double)_arrDivSrcX[i] / _width;
		}
		_arrDivX[_nx] = 1;
		_arrDivY.resize(_ny + 1);
		for (idxblk j = 0; j < _ny; ++j)
		{
			_arrDivY[j] = (double)_arrDivSrcY[j] / _height;
		}
		_arrDivY[_ny] = 1;

		// Log info
		string buf0 = "Div array: ";
		string buf1 = "Src array: ";
		string buf2 = "Ratio array: ";
		string buf3 = "Blk array: ";
		for(size_t i = 0; i <= _nx; ++i)
		{
			buf0 += "," + to_string(_arrDivInfoX[i].ori);
			buf1 += "," + to_string(_arrDivInfoX[i].src);
			buf2 += "," + to_string(_arrDivInfoX[i].ratio);
			buf3 += "," + to_string(_arrDivInfoX[i].oriblk);
		}
		buf0 += "; Y:";
		buf1 += "; Y:";
		buf2 += "; Y:";
		buf3 += "; Y:";
		for(size_t j = 0; j <= _ny; ++j)
		{
			buf0 += "," + to_string(_arrDivInfoY[j].ori);
			buf1 += "," + to_string(_arrDivInfoY[j].src);
			buf2 += "," + to_string(_arrDivInfoY[j].ratio);
			buf3 += "," + to_string(_arrDivInfoY[j].oriblk);
		}
		/*Logger::Log0("Blocker::CalcBlockDivide: \n" +
			buf1 + "\n" + buf2 + "\n" + buf3
			+ "\nwidth=" + to_string(_width)
			+ ", height=" + to_string(_height)
			+ ", nX=" + to_string(_nx) + ", nY=" + to_string(_ny)
			+ ", standard X=" + to_string(_iStdX) + ", standard Y=" + to_string(_iStdY));*/

		return true;
	}
	virtual bool	PostUpdateSpec()
	{
		RET_ON_FALSE(CalcBlockDivide());
	
		return true;
	}

protected:
	LFCTYPE void	ClearPreAssign(){}
	LFCTYPE void	ClearMove()
	{
		_status			= BLOCKER_STATUS::BLOCKER_NOTSET;
		_sizeBlock		= INVALID_BLOCKSIZE;
		_width			= 0;
		_height			= 0;
		_nx				= 0;
		_ny				= 0;
		// TODO needed?
		//_arrDivX.clear();
		//_arrDivY.clear();
		//_arrDivSrcX.clear();
		//_arrDivSrcY.clear();
	}
	void			Release()
	{
	}
private:
	// Disable copy-ctor, = operator
	Blocker(Blocker &blker);
	Blocker&		operator = (Blocker &blker);
public:
#pragma region LifeCycle

	Blocker():
		_status			(BLOCKER_STATUS::BLOCKER_NOTSET),
		_sizeBlock		(INVALID_BLOCKSIZE),
		_width			(0),
		_height			(0),
		_nx				(0),
		_ny				(0),
		_arrDivX		(),
		_arrDivY		(),
		_arrDivSrcX		(),
		_arrDivSrcY		(),
		_sizeBlockOri	(0),
		_widthOri		(0),
		_heightOri		(0),
		_iStdX			(-1),
		_iStdY			(-1),
		_arrDivInfoX	(),
		_arrDivInfoY	()
	{
	}
	Blocker(Blocker &&blker):
		_status			(blker._status),
		_sizeBlock		(blker._sizeBlock),
		_width			(blker._width),
		_height			(blker._height),
		_nx				(blker._nx),
		_ny				(blker._ny),
		_arrDivX		(std::forward<arr_divratio>(blker._arrDivX)),
		_arrDivY		(std::forward<arr_divratio>(blker._arrDivY)),
		_arrDivSrcX		(std::forward<arr_divsrc>(blker._arrDivSrcX)),
		_arrDivSrcY		(std::forward<arr_divsrc>(blker._arrDivSrcY)),
		_sizeBlockOri	(blker._sizeBlockOri),
		_widthOri		(blker._widthOri),
		_heightOri		(blker._heightOri),
		_iStdX			(blker._iStdX),
		_iStdY			(blker._iStdY),
		_arrDivInfoX	(std::forward<arr_divori>(blker._arrDivInfoX)),
		_arrDivInfoY	(std::forward<arr_divori>(blker._arrDivInfoY))
	{
		blker.Blocker::ClearMove();
	}
	virtual ~Blocker()
	{
	}

	iret			AssignMove(Blocker &blker)
	{
		// Clear before assignment
		Blocker::ClearPreAssign();

		// Assign
		_sizeBlock		= blker._sizeBlock;
		_width			= blker._width;
		_height			= blker._height;
		_nx				= blker._nx;
		_ny				= blker._ny;
		_arrDivX		= std::forward<arr_divratio>(blker._arrDivX);
		_arrDivY		= std::forward<arr_divratio>(blker._arrDivY);
		_arrDivSrcX		= std::forward<arr_divsrc>(blker._arrDivSrcX);
		_arrDivSrcY		= std::forward<arr_divsrc>(blker._arrDivSrcY);
		_sizeBlockOri	= blker._sizeBlockOri;
		_widthOri		= blker._widthOri;
		_heightOri		= blker._heightOri;
		_iStdX			= blker._iStdX;
		_iStdY			= blker._iStdY;
		_arrDivInfoX	= std::forward<arr_divori>(blker._arrDivInfoX);
		_arrDivInfoY	= std::forward<arr_divori>(blker._arrDivInfoY);
		// Assign status last
		_status			= blker._status;

		// Clear after move
		blker.Blocker::ClearMove();

		return IMGSYS_RET::ISR_SUCCEED;
	}
	Blocker&		operator = (Blocker &&blker)
	{
		AssignMove(blker);

		return *this;
	}

	virtual iret	Clear()
	{
		_status			= BLOCKER_STATUS::BLOCKER_NOTSET;
		// Do not clear setting
		//_sizeBlock		= INVALID_BLOCKSIZE;
		_width			= 0;
		_height			= 0;
		_nx				= 0;
		_ny				= 0;
		_arrDivX.clear();
		_arrDivY.clear();
		_arrDivSrcX.clear();
		_arrDivSrcY.clear();

		_sizeBlockOri	= INVALID_BLOCKSIZE;
		_widthOri		= 0;
		_heightOri		= 0;
		_iStdX			= -1;
		_iStdY			= -1;
		_arrDivInfoX.clear();
		_arrDivInfoY.clear();

		return IMGSYS_RET::ISR_SUCCEED;
	}
	virtual iret	ClearAll()
	{
		Clear();

		//
		// Clear setting
		//
		_sizeBlock		= INVALID_BLOCKSIZE;

		return IMGSYS_RET::ISR_SUCCEED;
	}

#pragma endregion LifeCycle

	inline bool		IsSet() const
	{
		return _status == BLOCKER_STATUS::BLOCKER_SET;
	}
	iret			SetBlockSize(idimblk szBlk)
	{
		if(IsSet())
		{
			// TODO: reset blocks
			return IMGSYS_RET::ISR_INVSTATUS;
		}

		if(szBlk <= INVALID_BLOCKSIZE_DIV)
		{
			return IMGSYS_RET::ISR_INVBLKSIZE;
		}

		_sizeBlock = szBlk;

		return IMGSYS_RET::ISR_SUCCEED;
	}
	inline idimblk	GetBlockSize() const
	{
		return _sizeBlock;
	}
	inline iDim		GetWidth() const
	{
		return _width;
	}
	inline iDim		GetHeight() const
	{
		return _height;
	}
	inline idxblk	GetNBlockX() const
	{
		return _nx;
	}
	inline idxblk	GetNBlockY() const
	{
		return _ny;
	}
	inline const arr_divsrc& GetSrcVecX() const
	{
		return _arrDivSrcX;
	}
	inline const arr_divsrc& GetSrcVecY() const
	{
		return _arrDivSrcY;
	}
	inline bool		IsInsideBlock(const IPOINT &ptIdx) const
	{
		return ptIdx.Inside(_nx, _ny);
	}
	inline bool		IsInsideBlock(const IRECT &rcIdx) const
	{
		return (!rcIdx.IsInvalid_Out(_nx, _ny));
	}
	inline iret		GetBlockRangeRect(IRECT &rcIdx) const
	{
		// Validate status
		if(!IsSet())
		{
			return IMGSYS_RET::ISR_INVSTATUS;
		}

		rcIdx = IRECT::FromXYWH(0, 0, _nx, _ny);

		return IMGSYS_RET::ISR_SUCCEED;
	}
	inline iret		GetStableBlocks(IRECT &rcStable) const
	{
		// Validate status
		if(!IsSet())
		{
			return IMGSYS_RET::ISR_INVSTATUS;
		}

		rcStable = IRECT::FromXYWH(0, 0, _iStdX, _iStdY);

		return IMGSYS_RET::ISR_SUCCEED;
	}
	iret			GetStableBlocksSplit(const IRECT &rcBlk, vector<IRECT> &vecRCStable) const
	{
		// clear vectotr first
		vecRCStable.clear();

		// Validate status
		if(!IsSet())
		{
			return IMGSYS_RET::ISR_INVSTATUS;
		}

		RETVAL_ON_TRUE(
			rcBlk.IsInvalid_Out(_nx, _ny),
			IMGSYS_RET::ISR_INVBLKRANGE);
	
		vector<idxblk> vecXSplit;
		vector<idxblk> vecYSplit;
		vecXSplit.emplace_back(rcBlk.left);
		vecXSplit.emplace_back(rcBlk.right + 1);
		vecYSplit.emplace_back(rcBlk.top);
		vecYSplit.emplace_back(rcBlk.bottom + 1);

		bool bSplitX = _iStdX > rcBlk.left && _iStdX <= rcBlk.right;
		bool bSplitY = _iStdY > rcBlk.top && _iStdY <= rcBlk.bottom;
		if(bSplitX)
		{
			vecXSplit.insert(vecXSplit.begin() + 1, _iStdX);
		}
		if(bSplitY)
		{
			vecYSplit.insert(vecYSplit.begin() + 1, _iStdY);
		}

		for(size_t j = 1; j < vecYSplit.size(); ++j)
		{
			idxblk splitY0 = vecYSplit[j - 1];
			idxblk splitY = vecYSplit[j];
			for(size_t i = 1; i < vecXSplit.size(); ++i)
			{
				idxblk splitX0 = vecXSplit[i - 1];
				idxblk splitX = vecXSplit[i];

				vecRCStable.emplace_back(splitX0, splitY0, splitX - 1, splitY - 1);
			}
		}

		return IMGSYS_RET::ISR_SUCCEED;
	}

	virtual iret	Setup(iDim w, iDim h, idimblk szBlk = INVALID_BLOCKSIZE)
	{
		// Clear
		if(IsSet())
		{
			Clear();
		}

		// Validate basic
		if(w <= INVALID_WIDTH_DIV || h <= INVALID_HEIGHT_DIV)
		{
			return IMGSYS_RET::ISR_INVSRCSIZE;
		}

		idimblk szBlkNew = _sizeBlock;
		if(szBlk != INVALID_BLOCKSIZE)
		{
			szBlkNew = szBlk;
		}
		if(szBlkNew <= INVALID_BLOCKSIZE_DIV)
		{
			return IMGSYS_RET::ISR_INVBLKSIZE;
		}

		// Set
		_width		= w;
		_height		= h;
		_sizeBlock	= szBlkNew;
		// Set Origin
		_widthOri		= _width;
		_heightOri		= _height;
		_sizeBlockOri	= _sizeBlock;

		// Calc Block Divide
		RETVAL_ON_FALSE(
			CalcBlockDivide(),
			IMGSYS_RET::ISR_FAIL);

		_status = BLOCKER_STATUS::BLOCKER_SET;

		return IMGSYS_RET::ISR_SUCCEED;
	}
	virtual iret	Setup(const Blocker &blk)
	{
		// Clear
		if(IsSet())
		{
			Clear();
		}

		if(!blk.IsSet())
		{
			return IMGSYS_RET::ISR_INVSTATUS;
		}

		// Set
		_sizeBlock		= blk._sizeBlock;
		// Set Origin data
		_widthOri		= blk._widthOri;
		_heightOri		= blk._heightOri;
		_sizeBlockOri	= blk._sizeBlockOri*2;

		// Calc Block Divide
		RETVAL_ON_FALSE(
			CalcBlockDivide(blk),
			IMGSYS_RET::ISR_FAIL);

		_status = BLOCKER_STATUS::BLOCKER_SET;

		return IMGSYS_RET::ISR_SUCCEED;
	}

	virtual iret	GetBlockIndex(const IRECT &rc, IRECT &rcIdx) const
	{
		// Validate status
		if(!IsSet())
		{
			return IMGSYS_RET::ISR_INVSTATUS;
		}

		rcIdx.left		= rc.left / _sizeBlock;
		rcIdx.top		= rc.top / _sizeBlock;
		rcIdx.right		= rc.right / _sizeBlock;
		rcIdx.bottom	= rc.bottom / _sizeBlock;

		RETVAL_ON_TRUE(
			rcIdx.IsInvalid_Out(_nx, _ny),
			IMGSYS_RET::ISR_INVBLKRANGE);

		return IMGSYS_RET::ISR_SUCCEED;
	}
	virtual iret	GetFullBlocks(const IRECT &rc, IRECT &rcIdx) const
	{
		// Validate Status
		if(!IsSet())
		{
			return IMGSYS_RET::ISR_INVSTATUS;
		}

		rcIdx.left		= (rc.left + _sizeBlock - 1) / _sizeBlock;
		rcIdx.top		= (rc.top + _sizeBlock - 1) / _sizeBlock;
		rcIdx.right		= (rc.right + 1) / _sizeBlock;
		rcIdx.bottom	= (rc.bottom + 1) / _sizeBlock;

		RETVAL_ON_TRUE(
			rcIdx.IsInvalid_Out(_nx, _ny),
			IMGSYS_RET::ISR_INVBLKRANGE);

		return IMGSYS_RET::ISR_SUCCEED;
	}
	virtual iret	GetBlockFrontEdge(const IPOINT &ptIdx, IPOINT &ptEdge) const
	{
		if(!IsSet())
		{
			return IMGSYS_RET::ISR_INVSTATUS;
		}
	
		RETVAL_ON_FALSE(
			ptIdx.Inside(_nx, _ny),
			IMGSYS_RET::ISR_INVBLKRANGE);

		ptEdge.x		= ptIdx.x * _sizeBlock;
		ptEdge.y		= ptIdx.y * _sizeBlock;

		return IMGSYS_RET::ISR_SUCCEED;
	}
	virtual iret	GetBlockRearEdge(const IPOINT &ptIdx, IPOINT &ptEdge) const
	{
		if(!IsSet())
		{
			return IMGSYS_RET::ISR_INVSTATUS;
		}
	
		RETVAL_ON_FALSE(
			ptIdx.Inside(_nx, _ny),
			IMGSYS_RET::ISR_INVBLKRANGE);


		ptEdge.x = min((ptIdx.x + 1) * _sizeBlock, _sizeBlock) - 1;
		ptEdge.y = min((ptIdx.y + 1) * _sizeBlock, _sizeBlock) - 1;

		return IMGSYS_RET::ISR_SUCCEED;
	}
	virtual iret	GetBlockEdge(const IPOINT &ptIdx, IRECT &rcEdge) const
	{
		if(!IsSet())
		{
			return IMGSYS_RET::ISR_INVSTATUS;
		}

		RETVAL_ON_FALSE(
			ptIdx.Inside(_nx, _ny),
			IMGSYS_RET::ISR_INVBLKRANGE);

		IPOINT ptTL;
		IPOINT ptBR;
		RET_ON_NEG(
			GetBlockFrontEdge(ptIdx, ptTL));
		RET_ON_NEG(
			GetBlockRearEdge(ptIdx, ptBR));

		rcEdge.SetFromTLBR(ptTL, ptBR);

		return IMGSYS_RET::ISR_SUCCEED;
	}
	virtual iret	GetBlockEdge(const IRECT &rcIdx, IRECT &rcEdge) const
	{
		if(!IsSet())
		{
			return IMGSYS_RET::ISR_INVSTATUS;
		}

		RETVAL_ON_TRUE(
			rcIdx.IsInvalid_Out(_nx, _ny),
			IMGSYS_RET::ISR_INVBLKRANGE);

		IPOINT ptTL;
		IPOINT ptBR;
		RET_ON_NEG(
			GetBlockFrontEdge(rcIdx.BasePoint(), ptTL));
		RET_ON_NEG(
			GetBlockRearEdge(rcIdx.EndPoint(), ptBR));

		rcEdge.SetFromTLBR(ptTL, ptBR);

		return IMGSYS_RET::ISR_SUCCEED;
	}

	virtual iret	GetOverlapBlocks(const Blocker &blkDest, const IRECT &rcSrc, IRECT &rcDest) const
	{
		// Validate Status
		if(!IsSet() || !blkDest.IsSet())
		{
			return IMGSYS_RET::ISR_INVSTATUS;
		}

		// Validate rcSrc
		if(!IsInsideBlock(rcSrc))
		{
			return IMGSYS_RET::ISR_INVRCSRC;
		}

		// Get blocks range in base blocker 
		const idxblk iul = _arrDivInfoX[rcSrc.left].ori;
		const idxblk iur = _arrDivInfoX[rcSrc.right + 1].ori;
		const idxblk iut = _arrDivInfoY[rcSrc.top].ori;
		const idxblk iub = _arrDivInfoY[rcSrc.bottom + 1].ori;
	
		// Divide array of dest blocker
		const arr_divori &arrDivXDest = blkDest._arrDivInfoX;
		const arr_divori &arrDivYDest = blkDest._arrDivInfoY;
		// Get blocks range of dest blocker
		idxblk il = -1;
		idxblk it = -1;
		idxblk ir = -1;
		idxblk ib = -1;
		// Horizental [0, _nx - 1]
		bool bHorizentalOverlap = false;
		for(idxblk iblkx = 0; iblkx < arrDivXDest.size() - 1; ++iblkx)
		{
			bool bOverlap = arrDivXDest[iblkx].ori < iur && arrDivXDest[iblkx + 1].ori > iul;
			if(bOverlap)
			{
				bHorizentalOverlap = true;
				if(il == -1)
				{
					il = iblkx;
				}
				ir = iblkx;
			}
			else
			{
				if(bHorizentalOverlap)
				{
					break;
				}
			}
		}
		if(!bHorizentalOverlap)
		{
			return IMGSYS_RET::ISR_INVBLKRANGE;
		}
		// Vertical [0, _ny - 1]
		bool bVerticalOverlap = false;
		for(idxblk iblky = 0; iblky < arrDivYDest.size() - 1; ++iblky)
		{
			bool bOverlap = arrDivYDest[iblky].ori < iub && arrDivYDest[iblky + 1].ori > iut;
			if(bOverlap)
			{
				bVerticalOverlap = true;
				if(it == -1)
				{
					it = iblky;
				}
				ib = iblky;
			}
			else
			{
				if(bVerticalOverlap)
				{
					break;
				}
			}
		}
		if(!bVerticalOverlap)
		{
			return IMGSYS_RET::ISR_INVBLKRANGE;
		}

		rcDest.Set(il, it, ir, ib);

		return IMGSYS_RET::ISR_SUCCEED;
	}
	virtual iret	GetAlignedBlocks(const Blocker &blkDest, const IRECT &rcSrc, IRECT &rcDest) const
	{
		// Validate Status
		if(!IsSet() || !blkDest.IsSet())
		{
			return IMGSYS_RET::ISR_INVSTATUS;
		}

		// Validate rcSrc
		if(!IsInsideBlock(rcSrc))
		{
			return IMGSYS_RET::ISR_INVRCSRC;
		}

		// Get blocks range in base blocker 
		const iDim iul = _arrDivInfoX[rcSrc.left].ori;
		const iDim iur = _arrDivInfoX[rcSrc.right + 1].ori;
		const iDim iut = _arrDivInfoY[rcSrc.top].ori;
		const iDim iub = _arrDivInfoY[rcSrc.bottom + 1].ori;
	
		// Divide array of dest blocker
		const arr_divori &arrDivXDest = blkDest._arrDivInfoX;
		const arr_divori &arrDivYDest = blkDest._arrDivInfoY;
		// Get blocks range of dest blocker
		idxblk il = -1;
		idxblk it = -1;
		idxblk ir = -1;
		idxblk ib = -1;
		// Horizental [0, _nx - 1]
		bool bLeftAligned = false;
		bool bRightAligned = false;
		for(idxblk iblkx = 0; iblkx < arrDivXDest.size() - 1; ++iblkx)
		{
			bool bLeftAlignedThis = arrDivXDest[iblkx].ori == iul;
			bool bRightAlignedThis = arrDivXDest[iblkx + 1].ori == iur;
			if(bLeftAlignedThis)
			{
				if(!bLeftAligned)
				{
					bLeftAligned = true;
				}
				if(il == -1)
				{
					il = iblkx;
				}
			}
			if(bRightAlignedThis)
			{
				bRightAligned = true;
				ir = iblkx;
				break;
			}
		}
		if(!bLeftAligned || !bRightAligned)
		{
			return IMGSYS_RET::ISR_INVBLKRANGE;
		}
		// Vertical [0, _ny - 1]
		bool bTopAligned = false;
		bool bBottomAligned = false;
		for(idxblk iblky = 0; iblky < arrDivYDest.size() - 1; ++iblky)
		{
			bool bTopAlignedThis = arrDivYDest[iblky].ori == iut;
			bool bBottomAlignedThis = arrDivYDest[iblky + 1].ori == iub;
			if(bTopAlignedThis)
			{
				if(!bTopAligned)
				{
					bTopAligned = true;
				}
				if(it == -1)
				{
					it = iblky;
				}
			}
			if(bBottomAlignedThis)
			{
				bBottomAligned = true;
				ib = iblky;
				break;
			}
		}
		if(!bTopAligned || !bBottomAligned)
		{
			return IMGSYS_RET::ISR_INVBLKRANGE;
		}

		rcDest.Set(il, it, ir, ib);

		return IMGSYS_RET::ISR_SUCCEED;
	}

	virtual iret	GetFullAndPartOverlapBlocks(IRECT rc, IRECT &rcIdxFull, IRECT &rcIdxWhole) const
	{
		// Validate Status
		if(!IsSet())
		{
			return IMGSYS_RET::ISR_INVSTATUS;
		}

		// Correct region
		rc.Correct(_width, _height);

		// Get index range
		IRECT rcIdxW;
		RET_ON_NEG(
			GetBlockIndex(rc, rcIdxW));

		// Get Full index range
		IRECT rcIdxF;
		RET_ON_NEG(
			GetFullBlocks(rc, rcIdxF));

		// Output
		rcIdxWhole = rcIdxW;
		rcIdxFull = rcIdxF;

		return IMGSYS_RET::ISR_SUCCEED;
	}

	// static standard
	static iret		GetBlockCount(
		iDim sizeX, iDim sizeY, iDim sizeBlockX, iDim sizeBlockY,
		idxblk &nBlkX, idxblk &nBlkY)
	{
		if(sizeBlockX <= INVALID_BLOCKSIZE_DIV ||
			sizeBlockY <= INVALID_BLOCKSIZE_DIV)
		{
			return IMGSYS_RET::ISR_INVBLKSIZE;
		}

		nBlkX = (sizeX + sizeBlockX - 1) / sizeBlockX; 
		nBlkY = (sizeY + sizeBlockY - 1) / sizeBlockY;

		return IMGSYS_RET::ISR_SUCCEED;
	}
	static iret		GetBlockIndex(
		const IRECT &rc,
		idimblk sizeBlockX, idimblk sizeBlockY,
		IRECT &rcIdx)
	{
		if(sizeBlockX <= INVALID_BLOCKSIZE_DIV ||
			sizeBlockY <= INVALID_BLOCKSIZE_DIV)
		{
			return IMGSYS_RET::ISR_INVBLKSIZE;
		}

		rcIdx.left		= rc.left / sizeBlockX;
		rcIdx.right		= rc.right / sizeBlockX;
		rcIdx.top		= rc.top / sizeBlockY;
		rcIdx.bottom	= rc.bottom / sizeBlockY;
	
		return IMGSYS_RET::ISR_SUCCEED;
	}
};

//typedef	Blocker::idxblk		idxblk;


template<typename T>
class DLLEXPORT Blocker_C1 : public Blocker<T>
{
public:
	// Core type
	typedef	T						iDim;

	typedef	iDim					idimblk;
	typedef	iDim					idxblk;

	// Blocker type
	typedef	Blocker<T>::IRECT			IRECT;
	typedef	Blocker<T>::IPOINT			IPOINT, IVEC2;

	typedef Blocker<T>::div_s			div_s;
	typedef Blocker<T>::arr_divratio	arr_divratio;
	typedef Blocker<T>::arr_divsrc		arr_divsrc;
	typedef Blocker<T>::arr_divdst		arr_divdst;
	typedef Blocker<T>::arr_divori		arr_divori;

protected:
	virtual bool	CalcBlockCount() OVERRIDE 
	{
		if(_sizeBlock <= INVALID_BLOCKSIZE_DIV)
		{
			return false;
		}

		_nx = (idxblk)ceil((double)_width / _sizeBlock);
		_ny = (idxblk)ceil((double)_height / _sizeBlock);

		idimblk szblkXLast = _width % _sizeBlock;
		if (szblkXLast < _sizeBlock / 2.0 && szblkXLast != 0)
		{
			if (_nx > 1)
			{
				_nx--;
			}
		}
		idimblk szBlkYLast = _height % _sizeBlock;
		if (szBlkYLast < _sizeBlock / 2.0 && szBlkYLast != 0)
		{
			if (_ny > 1)
			{
				_ny--;
			}
		}

		return true;
	}
	virtual bool	CalcBlockDivide(const Blocker_C1 &blk)
	{
		// [Set Origin X]
		// Get base array
		const arr_divori &arrDivInfoX0 = blk._arrDivInfoX;
		size_t nDivX0 = arrDivInfoX0.size();
		RET_ON_TRUE(
			nDivX0 < 2);

		idxblk ix0 = 0;
		idxblk ix1 = 0;
		const idxblk dx0 = 2;
		const idxblk dx1 = 1;
		_arrDivInfoX.clear();
		// Add the first divide
		_arrDivInfoX.push_back(arrDivInfoX0[0]);
		ix0 += dx0;
		ix1 += dx1;
		for(; ix0 < nDivX0; ix0 += dx0, ix1 += dx1)
		{
			// Calculate new divide, based on the base divide
			const div_s &div0 = arrDivInfoX0[ix0];
			div_s div;
			div.ori		= div0.ori;
			div.oriblk	= div0.oriblk;
			div.ratio	= div0.ratio;
			iDim wOri = div0.ori - arrDivInfoX0[ix0 - 2].ori;
			div.src		= (iDim)(_arrDivInfoX.back().src + (double)wOri*_sizeBlock/_sizeBlockOri + 0.5);
		
			_arrDivInfoX.push_back(div);
		}
		// Judge the remained last base divide
		ix0 = ix0 - dx0 + 1;
		if(ix0 <= nDivX0 - 1)
		{
			const div_s &div0 = arrDivInfoX0[ix0];
			iDim w = arrDivInfoX0[ix0].ori - arrDivInfoX0[ix0 - 1].ori;
			// Whether the last base divide needed to be merged
			if(w < _sizeBlockOri/2.0 && ix1 > 1)
			{
				div_s &divLast = _arrDivInfoX[ix1 - 1];
				divLast.ori		= div0.ori;
				divLast.oriblk	= div0.oriblk;
				divLast.ratio	= div0.ratio;

				iDim wNew = divLast.ori - _arrDivInfoX[ix1 - 2].ori;
				divLast.src		= (iDim)(_arrDivInfoX[ix1 - 2].src + (double)_sizeBlock*wNew/_sizeBlockOri + 0.5);

			}
			else
			{
				div_s div;
				div.ori		= div0.ori;
				div.oriblk	= div0.oriblk;
				div.ratio	= div0.ratio;
				div.src		= (iDim)(_arrDivInfoX.back().src + (double)_sizeBlock*w/_sizeBlockOri + 0.5);
			
				_arrDivInfoX.push_back(div);
			}
		}
		// Set Origin Y
		const arr_divori &arrDivInfoY0 = blk._arrDivInfoY;
		size_t nDivY0 = arrDivInfoY0.size();
		RET_ON_TRUE(
			nDivY0 < 2);

		idxblk iy0 = 0;
		idxblk iy1 = 0;
		const idxblk dy0 = 2;
		const idxblk dy1 = 1;
		_arrDivInfoY.clear();
		// Add the first divide
		_arrDivInfoY.push_back(arrDivInfoY0[0]);
		iy0 += dy0;
		iy1 += dy1;
		for(; iy0 < nDivY0; iy0 += dy0, iy1 += dy1)
		{
			// Calculate new divide, based on the base divide
			const div_s &div0 = arrDivInfoY0[iy0];
			div_s div;
			div.ori		= div0.ori;
			div.oriblk	= div0.oriblk;
			div.ratio	= div0.ratio;
			iDim h0 = div0.ori - arrDivInfoY0[iy0 - 2].ori;
			div.src		= (iDim)(_arrDivInfoY.back().src + (double)h0*_sizeBlock/_sizeBlockOri + 0.5);
		
			_arrDivInfoY.push_back(div);
		}
		// Judge the remained last divide
		iy0 = iy0 - dy0 + 1;
		if(iy0 <= nDivY0 - 1)
		{
			const div_s &div0 = arrDivInfoY0[iy0];
			iDim h = arrDivInfoY0[iy0].ori - arrDivInfoY0[iy0 - 1].ori;
			// Whether the last base divide needed to be merged
			if(h < _sizeBlockOri/2.0 && iy1 > 1)
			{
				div_s &divLast = _arrDivInfoY[iy1 - 1];
				divLast.ori		= div0.ori;
				divLast.oriblk	= div0.oriblk;
				divLast.ratio	= div0.ratio;

				iDim hNew = divLast.ori - _arrDivInfoY[iy1 - 2].ori;
				divLast.src		= (iDim)(_arrDivInfoY[iy1 - 2].src + (double)hNew*_sizeBlock/_sizeBlockOri + 0.5);
			}
			else
			{
				div_s div;
				div.ori		= div0.ori;
				div.oriblk	= div0.oriblk;
				div.ratio	= div0.ratio;
				div.src		= (iDim)(_arrDivInfoY.back().src + (double)h*_sizeBlock/_sizeBlockOri + 0.5);
			
				_arrDivInfoY.push_back(div);
			}
		}

		// (Do not validate overflow, as it is downsample)!

		// Set standard X, Y
		idxblk nx = (idxblk)(_arrDivInfoX.size() - 1);
		idxblk ny = (idxblk)(_arrDivInfoY.size() - 1);
		_iStdX = _arrDivInfoX[nx].ori - _arrDivInfoX[nx - 1].ori == _sizeBlockOri ?
			nx : nx - 1;
		_iStdY = _arrDivInfoY[ny].ori - _arrDivInfoY[ny - 1].ori == _sizeBlockOri ?
			ny : ny - 1;


		// Set to Basic Info
		_nx = nx;
		_ny = ny;
		_width = _arrDivInfoX.back().src;
		_height = _arrDivInfoY.back().src;

		_arrDivSrcX.resize(_arrDivInfoX.size());
		for(size_t i = 0; i < _arrDivSrcX.size(); ++i)
		{
			_arrDivSrcX[i] = _arrDivInfoX[i].src;
		}
		_arrDivSrcY.resize(_arrDivInfoY.size());
		for(size_t i = 0; i < _arrDivSrcY.size(); ++i)
		{
			_arrDivSrcY[i] = _arrDivInfoY[i].src;
		}
		// Calculate divide ratio array
		_arrDivX.resize(_nx + 1);
		for (idxblk i = 0; i < _nx; ++i)
		{
			_arrDivX[i] = (double)_arrDivSrcX[i] / _width;
		}
		_arrDivX[_nx] = 1;
		_arrDivY.resize(_ny + 1);
		for (idxblk j = 0; j < _ny; ++j)
		{
			_arrDivY[j] = (double)_arrDivSrcY[j] / _height;
		}
		_arrDivY[_ny] = 1;

		// Log info
		string buf0 = "Div array: ";
		string buf1 = "Src array: ";
		string buf2 = "Ratio array: ";
		string buf3 = "Blk array: ";
		for(size_t i = 0; i <= _nx; ++i)
		{
			buf0 += "," + to_string(_arrDivInfoX[i].ori);
			buf1 += "," + to_string(_arrDivInfoX[i].src);
			buf2 += "," + to_string(_arrDivInfoX[i].ratio);
			buf3 += "," + to_string(_arrDivInfoX[i].oriblk);
		}
		buf0 += "; Y:";
		buf1 += "; Y:";
		buf2 += "; Y:";
		buf3 += "; Y:";
		for(size_t j = 0; j <= _ny; ++j)
		{
			buf0 += "," + to_string(_arrDivInfoY[j].ori);
			buf1 += "," + to_string(_arrDivInfoY[j].src);
			buf2 += "," + to_string(_arrDivInfoY[j].ratio);
			buf3 += "," + to_string(_arrDivInfoY[j].oriblk);
		}
		/*Logger::Log0("Blocker_C1::CalcBlockDivide: \n" +
			buf1 + "\n" + buf2 + "\n" + buf3
			+ "\nwidth=" + to_string(_width)
			+ ", height=" + to_string(_height)
			+ ", nX=" + to_string(_nx) + ", nY=" + to_string(_ny)
			+ ", standard X=" + to_string(_iStdX) + ", standard Y=" + to_string(_iStdY));*/

		return true;
	}

protected:
	LFCTYPE void	ClearPreAssign() LFCOVERRIDE{}
	LFCTYPE void	ClearMove() LFCOVERRIDE{}
	void			Release(){}
private:
	// Disable copy-ctor, = operator
	Blocker_C1(Blocker_C1 &blker);
	Blocker_C1&		operator = (Blocker_C1 &blker);
public:
#pragma region LifeCycle

	Blocker_C1():
		Blocker()
	{
	}
	Blocker_C1(Blocker_C1 &&blker):
		Blocker(std::forward<Blocker_C1>(blker))
	{
	}
	virtual ~Blocker_C1() OVERRIDE
	{
		Release();
	}

	iret			AssignMove(Blocker_C1 &blker)
	{
		// Clear before assignment
		Blocker_C1::ClearPreAssign();

		Blocker::AssignMove(std::forward<Blocker_C1>(blker));

		// Clear after move
		blker.Blocker::ClearMove();

		return IMGSYS_RET::ISR_SUCCEED;
	}
	Blocker_C1&		operator = (Blocker_C1 &&blker)
	{
		AssignMove(blker);

		return *this;
	}

	virtual iret	Clear() OVERRIDE
	{
		return Blocker::Clear();
	}
	virtual iret	ClearAll() OVERRIDE
	{
		return Blocker::ClearAll();
	}

#pragma endregion LifeCycle

	virtual iret	Setup(iDim w, iDim h, idimblk szBlk = INVALID_BLOCKSIZE) OVERRIDE
	{
		return Blocker::Setup(w, h, szBlk);
	}
	virtual iret	Setup(const Blocker_C1 &blk)
	{
		// Clear
		if(IsSet())
		{
			Clear();
		}

		if(!blk.IsSet())
		{
			return IMGSYS_RET::ISR_INVSTATUS;
		}

		// Set
		_sizeBlock		= blk._sizeBlock;
		// Set Origin data
		_widthOri		= blk._widthOri;
		_heightOri		= blk._heightOri;
		_sizeBlockOri	= blk._sizeBlockOri*2;

		// Calc Block Divide
		RETVAL_ON_FALSE(
			CalcBlockDivide(blk),
			IMGSYS_RET::ISR_FAIL);

		_status = BLOCKER_STATUS::BLOCKER_SET;

		return IMGSYS_RET::ISR_SUCCEED;
	}

	virtual iret	GetBlockIndex(const IRECT &rc, IRECT &rcIdx) const OVERRIDE
	{
		if(!IsSet())
		{
			return IMGSYS_RET::ISR_INVSTATUS;
		}

		RETVAL_ON_TRUE(
			rc.IsInvalid_Out(_width, _height),
			IMGSYS_RET::ISR_INVRCSRC);

		rcIdx.left		= min(rc.left / _sizeBlock,		_nx - 1);
		rcIdx.top		= min(rc.top / _sizeBlock,		_ny - 1);
		rcIdx.right		= min(rc.right / _sizeBlock,	_nx - 1);
		rcIdx.bottom	= min(rc.bottom / _sizeBlock,	_ny - 1);

		return IMGSYS_RET::ISR_SUCCEED;
	}
	virtual iret	GetFullBlocks(const IRECT &rc, IRECT &rcIdx) const OVERRIDE
	{
		// Validate Status
		if(!IsSet())
		{
			return IMGSYS_RET::ISR_INVSTATUS;
		}

		// Get rcSrc edge
		const iDim isl = rc.left;
		const iDim isr = rc.right;
		const iDim ist = rc.top;
		const iDim isb = rc.bottom;

		// Get Horizental Full
		idxblk iLeftFull = -1;
		idxblk iRightFull = -1;
		for(idxblk iblkx = 0; iblkx < _arrDivInfoX.size() - 1; ++iblkx)
		{
			if(_arrDivInfoX[iblkx].src >= isl)
			{
				if(iLeftFull == -1)
				{
					iLeftFull = iblkx;
				}
			}
			if(_arrDivInfoX[iblkx + 1].src - 1 <= isr)
			{
				iRightFull = iblkx;
			}
		}
		if(iLeftFull == -1 || iRightFull == -1)
		{
			return IMGSYS_RET::ISR_INVBLKRANGE;
		}

		// Get Horizental Full
		idxblk iTopFull = -1;
		idxblk iBottomFull = -1;
		for(idxblk iblky = 0; iblky < _arrDivInfoY.size() - 1; ++iblky)
		{
			if(_arrDivInfoY[iblky].src >= ist)
			{
				if(iTopFull == -1)
				{
					iTopFull = iblky;
				}
			}
			if(_arrDivInfoY[iblky + 1].src - 1 <= isb)
			{
				iBottomFull = iblky;
			}
		}
		if(iTopFull == -1 || iBottomFull == -1)
		{
			return IMGSYS_RET::ISR_INVBLKRANGE;
		}

		// Output
		rcIdx = IRECT(iLeftFull, iTopFull, iRightFull, iBottomFull);

		return IMGSYS_RET::ISR_SUCCEED;
	}
	virtual iret	GetBlockFrontEdge(const IPOINT &ptIdx, IPOINT &ptEdge) const OVERRIDE
	{
		if(!IsSet())
		{
			return IMGSYS_RET::ISR_INVSTATUS;
		}

		RETVAL_ON_FALSE(
			ptIdx.Inside(_nx, _ny),
			IMGSYS_RET::ISR_INVBLKRANGE);

		ptEdge.x		= ptIdx.x * _sizeBlock;
		ptEdge.y		= ptIdx.y * _sizeBlock;
	
		return IMGSYS_RET::ISR_SUCCEED;
	}
	virtual iret	GetBlockRearEdge(const IPOINT &ptIdx, IPOINT &ptEdge) const OVERRIDE
	{
		if(!IsSet())
		{
			return IMGSYS_RET::ISR_INVSTATUS;
		}

		RETVAL_ON_FALSE(
			ptIdx.Inside(_nx, _ny),
			IMGSYS_RET::ISR_INVBLKRANGE);

		ptEdge.x = (ptIdx.x == _nx - 1) ?
			(_width - 1) : (min((ptIdx.x + 1) * _sizeBlock, _width) - 1);
		ptEdge.y = (ptIdx.y == _ny - 1) ?
			(_height - 1) : (min((ptIdx.y + 1) * _sizeBlock, _height) - 1);
	
		return IMGSYS_RET::ISR_SUCCEED;
	}
	virtual iret	GetBlockEdge(const IPOINT &ptIdx, IRECT &rcEdge) const OVERRIDE
	{
		return Blocker::GetBlockEdge(ptIdx, rcEdge);
	}
	virtual iret	GetBlockEdge(const IRECT &rcIdx, IRECT &rcEdge) const OVERRIDE
	{
		return Blocker::GetBlockEdge(rcIdx, rcEdge);
	}
	
	virtual iret	GetBlockDestDivideArray(
		const IVEC2 &sizeTarget,
		arr_divdst &arrDivDstX, arr_divdst &arrDivDstY) const
	{
		iDim wTarget = sizeTarget.x;
		iDim hTarget = sizeTarget.y;

		// Create dest divide array
		arrDivDstX.resize(_arrDivX.size());
		for (idxblk i = 0; i < (idxblk)_arrDivX.size() - 1; ++i)
		{
			arrDivDstX[i] = (iDim)(_arrDivX[i] * wTarget + 0.5);
		}
		arrDivDstX[arrDivDstX.size() - 1] = wTarget;

		arrDivDstY.resize(_arrDivY.size());
		for (idxblk i = 0; i < (idxblk)arrDivDstY.size() - 1; ++i)
		{
			arrDivDstY[i] = (iDim)(_arrDivY[i] * hTarget + 0.5);
		}
		arrDivDstY[arrDivDstY.size() - 1] = hTarget;

		return IMGSYS_RET::ISR_SUCCEED;
	}
	virtual iret	SetBlockDestAndGetRegion(
		const RECTXZ &rcTarget, const IVEC2 &sizeTarget, const IVEC2 &vOff,
		IRECT &rcBlkIdx, IRECT &rcBlkIdxFull, arr_divdst &arrDivX, arr_divdst &arrDivY) const
	{
		/*if(!IsSet())
		{
			return IMGSYS_RET::ISR_INVSTATUS;
		}*/

		iDimZ xImg = (iDimZ)rcTarget.left;
		iDimZ yImg = (iDimZ)rcTarget.top;
		iDimZ rImg = (iDimZ)rcTarget.right;
		iDimZ bImg = (iDimZ)rcTarget.bottom;

		iDim wTarget = sizeTarget.x;
		iDim hTarget = sizeTarget.y;

		// Create dest divide array
		size_t nDivX = _arrDivX.size();
		arrDivX.resize(nDivX);
		for (idxblk i = 0; i < (idxblk)nDivX - 1; ++i)
		{
			arrDivX[i] = (iDimZ)(_arrDivX[i] * wTarget + 0.5);
		}
		arrDivX[arrDivX.size() - 1] = wTarget;
	
		size_t nDivY = _arrDivY.size();
		arrDivY.resize(nDivY);
		for (idxblk i = 0; i < (idxblk)nDivY - 1; ++i)
		{
			arrDivY[i] = (iDimZ)(_arrDivY[i] * hTarget + 0.5);
		}
		arrDivY[arrDivY.size() - 1] = hTarget;

		idxblk blkXF = -1, blkXR = -1, blkYF = -1, blkYR = -1;
		bool bMarginXF = false, bMarginXR = false, bMarginYF = false, bMarginYR = false;

		// last pixel in range
		//iDimZ rImg = xImg + wImg - 1;
		//iDimZ bImg = yImg + hImg - 1;
		// if rImg, bImg > whTarget, it is safe and it will render till whTarget
		for (idxblk j = 1; j < (idxblk)arrDivY.size(); ++j)
		{// [1, len - 1]
			if (arrDivY[j] > yImg)
			{
				blkYF = (idxblk)(j - 1);
				if ((
					(yImg > arrDivY[blkYF])
					|| (/*yLast < hTarget && */bImg < arrDivY[blkYF + 1] - 1)
					))
				{
					bMarginYF = true;
				}
				break;
			}
		}
		for (idxblk j = (idxblk)arrDivY.size() - 2; j >= 0; --j)
		{// [0, len - 2]
			if (arrDivY[j] <= bImg)
			{
				blkYR = (idxblk)(j);
				if ((/*yLast < hTarget && */bImg < arrDivY[blkYR + 1] - 1)
					|| (yImg > arrDivY[blkYR]))
				{
					bMarginYR = true;
				}
				break;
			}
		}
		for (idxblk i = 1; i < (idxblk)arrDivX.size(); ++i)
		{// [1, len - 1]
			if (arrDivX[i] > xImg)
			{
				blkXF = (idxblk)(i - 1);
				if ((
					(xImg > arrDivX[blkXF])
					|| (/*xLast < wTarget && */rImg < arrDivX[blkXF + 1] - 1)
					))
				{
					bMarginXF = true;
				}
				break;
			}
		}
		for (idxblk i = (idxblk)arrDivX.size() - 2; i >= 0; --i)
		{// [0, len - 2]
			if (arrDivX[i] <= rImg)
			{
				blkXR = (idxblk)(i);
				if ((/*xLast < wTarget && */rImg < arrDivX[blkXR + 1] - 1)
					|| (xImg > arrDivX[blkXR]))
				{
					bMarginXR = true;
				}
				break;
			}
		}

		if (blkXF < 0 || blkYF < 0 ||
			blkXR < blkXF || blkYR < blkYF)
		{
			return IMGSYS_RET::ISR_INVBLKRANGE;
		}

		rcBlkIdx.left	= blkXF;
		rcBlkIdx.top	= blkYF;
		rcBlkIdx.right	= blkXR;
		rcBlkIdx.bottom	= blkYR;

		// entire block range
		idxblk blkXFE = blkXF;
		idxblk blkXRE = blkXR;
		idxblk blkYFE = blkYF;
		idxblk blkYRE = blkYR;

		// Update block render status
		//  and update entire block range
		if (bMarginXF)
		{
			++blkXFE;
		}
		if (bMarginXR)
		{
			--blkXRE;
		}
		if (bMarginYF)
		{
			++blkYFE;
		}
		if (bMarginYR)
		{
			--blkYRE;
		}
		rcBlkIdxFull.left	= blkXFE;
		rcBlkIdxFull.top	= blkYFE;
		rcBlkIdxFull.right	= blkXRE;
		rcBlkIdxFull.bottom	= blkYRE;

		// offset	
		for (idxblk i = 0; i < (idxblk)arrDivX.size(); ++i)
		{
			arrDivX[i] -= vOff.x;
		}
		for (idxblk i = 0; i < (idxblk)arrDivY.size(); ++i)
		{
			arrDivY[i] -= vOff.y;
		}

		return IMGSYS_RET::ISR_SUCCEED;
	}
};

#pragma endregion Image Blocker
}

#undef _IMGDISP_SOURCE_FILE_IMGBLOCKER_H
#define _IMGDISP_SOURCE_FILE_IMGBLOCKER_CPP

#include "pch.h"

#include "ImgBlocker.h"


namespace ImgDisplay
{

#pragma region Image Blocker

#pragma endregion Image Blocker

}

#undef _IMGDISP_SOURCE_FILE_IMGBLOCKER_CPP
#define _IMGDISP_SOURCE_FILE_IMGLOADER_H
#pragma once

//#include "ImgBase.h"

#include "ImgBlocker.h"

namespace ImgDisplay
{

#pragma region Image Loader
/************************
 Image Loader Helper
*************************/

inline void CloseGDALDataset(GDALDataset *pDataset)
{
	if(nullptr != pDataset)
	{
		GDALClose((GDALDatasetH) pDataset);

		Logger::Log0("GDAL Dataset closed");
	}
}

inline void funcScopeGuardCPLMalloc(void *ptr);

void* CPLAlloc(size_t sz, scope_guard &scgAlloc);

enum IMGLOADER_STATUS
{
	ILDS_EMPTY	= 0,
	ILDS_CLOSED	= 1,// bind to file
	ILDS_OPENED	= 3
};

struct DLLEXPORT ChannelInfo;
//template class DLLEXPORT std::allocator<ChannelInfo>;
//template class DLLEXPORT vector<ChannelInfo>;

struct ChannelInfo
{
public:
	GDALRasterBand	*pChannel;
	GDALDataType	type;
	bool			bConvert;
	idepth			nBit;
	ui64			maxValue;
	ChannelInfo();
};

/************************
 Image Loader
*************************/
#define IMGLOADER_LOCK_INTERNAL				scope_guard scgLockInternal;\
											_lock.LockGuard(scgLockInternal);
#define IMGLOADER_UNLOCK_INTERNAL			scgLockInternal.Release();
#define IMGLOADER_LOCKREAD_INTERNAL			scope_guard scgLockReadInternal;\
											_lock.LockReadGuard(scgLockReadInternal);
#define IMGLOADER_LOCKREADT_INTERNAL(T, RET)	scope_guard scgLockReadInternal;\
												RET = _lock.LockReadGuard(scgLockReadInternal, T);

#define IMGLOADER_LOCKOTHER_INTERNAL(OTHER)	scope_guard scgLockOtherInternal;\
											(OTHER)._lock.LockGuard(scgLockOtherInternal);
#define IMGLOADER_UNLOCKOTHER_INTERNAL		scgLockOtherInternal.Release();


template<typename T>
class DLLEXPORT ImgLoader
{
protected:
	// Core type
	typedef T					iDim;
	typedef	iDim				idxblk;// TODO Blocker<iDim>::idxblk

	// Aux type
	typedef	RECTX<iDim>			IRECT;
	typedef	POINTX<iDim>		IPOINT, IVEC2;

	// Blocker type
	typedef	Blocker<iDim>			BLOCKER;
private:
	// Aux type
	typedef ImgBuf<iDim>		ImgBuf;

protected:
	typedef	vector<ChannelInfo>		vec_channel;
	
	static bool		__bPrepared;

	mutable icrwb_lock	_lock;

	IMGLOADER_STATUS	_status;

	GDALDataset			*_pDataset;

	string				_filePath;
	IMG_FILETYPE		_fileType;
	IMGDISP_PIXELFORMAT	_format;
	int					_nChannel;

	iDim				_width;
	iDim				_height;

	vector<int>			_mapChannel;
	// Format info of channels
	bool				_bUnstandard;// unstandard pixel format(not XRGB)
	vec_channel			_vecDT;
	idepth				_nBitMax;

protected:
	iret				CheckPngDepth(const string &file);

#ifdef USE_IMGLOADER_OBSOLETE
	iret ReadXRGB0(IRECT rcSrc,
		void *pDest, iDim wDest, iDim hDest, iDim strideDest);
#endif
	iret ReadXRGBInternal(IRECT rcLoad, ImgBuf &imgBuf,
		bool *bInterrupt = nullptr)
	{
		// Validate status
		if(!IsOpen())
		{
			return IMGSYS_RET::ISR_INVSTATUS;
		}

		// Validate basic
		if(!imgBuf.HasData())
		{
			return IMGSYS_RET::ISR_NULLIMG;
		}

		// Validate rcLoad
		if(rcLoad.IsInvalid_Out(_width, _height))
		{
			return IMGSYS_RET::ISR_INVRCSRC;
		}

		// Extract Image Buffer access
		void *pLoad			= imgBuf.GetPImg();
		iDim wLoad			= imgBuf.GetWidth();
		iDim hLoad			= imgBuf.GetHeight();
		iDim strideLoad		= imgBuf.GetStride();

		// Correct rcLoad
		rcLoad.CorrectSize(wLoad, hLoad);
		iDim xSrc	= rcLoad.left;
		iDim ySrc	= rcLoad.top;
		iDim rSrc	= rcLoad.right;
		iDim bSrc	= rcLoad.bottom;

		// Load channels
		bool bAnyChannelSucceeded = false;
		for(int c = 0; c < _vecDT.size(); ++c)
		{
			Ticker ticker;
			ticker.Start();

			// ======>> LOCK <<=======
			//IMGLOADER_LOCK_INTERNAL;

			// Channel specification
			GDALRasterBand *pChannel	= _vecDT[c].pChannel;
			GDALDataType type			= _vecDT[c].type;
			idepth nBit			= _vecDT[c].nBit;
			int bias			= (1 << ((nBit - 8)/2));
			int shift			= nBit - 8;
			qword maxVal		= _vecDT[c].maxValue;
			dword mask			= C_QMASK(nBit);
			idepth nPixelByteLoad	= GetBytesOfGDALDataType(type);
			CONTINUE_IF(
				nullptr == pChannel || type <= GDT_Unknown || nBit <= 0 || nPixelByteLoad <= 0);
		
			// Get channel size
			iDim szX = pChannel->GetXSize();
			iDim szY = pChannel->GetYSize();
			CONTINUE_IF_AND(
				szX <= 0 || szY <= 0,
				Logger::Log0("ImgLoader::ReadXRGBInternal: image size read from GDAL <= 0"););
			// Get block size
			int szBlkXGDAL = 0;
			int szBlkYGDAL = 0;
			pChannel->GetBlockSize(&szBlkXGDAL, &szBlkYGDAL);
			iDim szBlkX = szBlkXGDAL;
			iDim szBlkY = szBlkYGDAL;
			CONTINUE_IF_AND(
				szBlkX <= 0 || szBlkY <= 0,
				Logger::Log0("ImgLoader::ReadXRGBInternal: block size read from GDAL <= 0"););

			// ======>> UNLOCK <<=======
			//IMGLOADER_UNLOCK_INTERNAL;

			// Calculate block count
			idxblk nBlkX = 0;
			idxblk nBlkY = 0;
			CONTINUE_ON_NEG_AND(
				BLOCKER::GetBlockCount(szX, szY, szBlkX, szBlkY, nBlkX, nBlkY),
				Logger::Log0("ImgLoader::ReadXRGB: Calculate block count error"););
			//assert(nBlkX > 0 && nBlkY > 0); // do not validate this
			//CONTINUE_IF_AND(
			//	nBlkX <= 0 || nBlkY <= 0,
			//	Logger::Log0("ImgLoader::ReadXRGB: block count to be loaded <= 0");)

			// Calculate block index range
			IRECT rcBlkIdx;
			CONTINUE_ON_NEG_AND(
				BLOCKER::GetBlockIndex(rcLoad, szBlkX, szBlkY, rcBlkIdx),
				Logger::Log0("ImgLoader::ReadXRGBInternal: Calculate block index error"););
			//
		
			// Dest channels
			vector<int> vecChannelDest;
			for(int ic = 0; ic < _mapChannel.size(); ++ic)
			{
				if((c + 1) == _mapChannel[ic])
				{
					vecChannelDest.emplace_back(ic);
				}
			}
			CONTINUE_IF_AND(
				vecChannelDest.empty(),
				Logger::Log0("ImgLoader::ReadXRGBInternal: No corresponding dest channel found of channel[" +
					to_string(c) + "], continue to next channel"););
		
			// Src specification
			iDim strideLoadTemp = szBlkX * nPixelByteLoad;
			size_t szBlock = szBlkY * strideLoadTemp;
			// Dest specification
			idepth nPixelByteDest = 1;
			const int nChannelDestTotal = 4;
			idepth pixelSpaceDest = nChannelDestTotal * nPixelByteDest;

			// Check Interrupt Signal
			if(nullptr != bInterrupt && *bInterrupt)
			{
				return IMGSYS_RET::ISR_INTERRUPT;
			}

			//Logger::Log0("ImgLoader::ReadXRGBInternal: "
			//	"Begin to load chn#" + to_string(c + 1) + "/" + to_string(_vecDT.size()) +
			//	": " +
			//	"DataType:" + GetGDALDataTypeStr(type) +
			//	", nBit:" + to_string(nBit) +
			//	", szBlk:[" + to_string(szBlkX) + "," + to_string(szBlkY) + "]"
			//	", nBlk:[" + to_string(nBlkX) + "," + to_string(nBlkY) + "]"
			//	", rcLoad:" + rcBlkIdx.ToString() +
			//	", depth:" + to_string(nPixelByteLoad));
		
			// Allocate temp buffer
			void *pLoadTemp = nullptr;
			scope_guard scgImgTemp;
			//pLoadTemp = ImgBase::Alloc(szBlock, scgImgTemp);// may be error
			pLoadTemp = CPLAlloc(szBlock, scgImgTemp);
			RETVAL_ON_NULLPTR_AND(
				pLoadTemp,
				IMGSYS_RET::ISR_ALLOCFAIL,
				Logger::Log0("ImgLoader::ReadXRGBInternal: Alloc buffer error"););
		
			// Read blocks / convert
			if(_vecDT[c].bConvert)
			{
				for(iDim iy = rcBlkIdx.top; iy <= rcBlkIdx.bottom; ++iy)
				{
					for(iDim ix = rcBlkIdx.left; ix <= rcBlkIdx.right; ++ix)
					{
						// ======>> LOCK <<=======
						//IMGLOADER_LOCK_INTERNAL;
						CPLErr err = 
							pChannel->ReadBlock(ix, iy, pLoadTemp);
						// ======>> UNLOCK <<=======
						//IMGLOADER_UNLOCK_INTERNAL;
					
						iDim lBlk		= ix*szBlkX;
						iDim lLoad		= max(xSrc - lBlk, 0);
						iDim rLoad		= min(szBlkX, rSrc - lBlk + 1);
						iDim tBlk		= iy*szBlkY;
						iDim tLoad		= max(ySrc - tBlk, 0);
						iDim bLoad		= min(szBlkY, bSrc - tBlk + 1);
						iDim lLoadDst	= max(lBlk - xSrc, 0);
						iDim tLoadDst	= max(tBlk - ySrc, 0);

						for(int icDest = 0; icDest < vecChannelDest.size(); ++icDest)
						{
							// no channel offset for src
							int offDst = vecChannelDest[icDest]*nPixelByteDest;
							void *pCvtSrc = IMG_POS(pLoadTemp, lLoad, tLoad, strideLoadTemp, nPixelByteLoad);
							void *pCvtDst = (byte*)IMG_POS(pLoad, lLoadDst, tLoadDst, strideLoad, pixelSpaceDest) + offDst;
							for(iDim y = tLoad; y < bLoad; ++y,
								GO_STRIDE(pCvtSrc, strideLoadTemp),
								GO_STRIDE(pCvtDst, strideLoad))
							{
								void *pCvtSrcRow = (byte*)pCvtSrc;
								byte *pCvtDstRow = (byte*)pCvtDst;
								for(iDim x = lLoad; x < rLoad; ++x,
									GO_STRIDE(pCvtSrcRow, nPixelByteLoad),
									GO_STRIDE(pCvtDstRow, pixelSpaceDest))
								{
									dword q = *((dword*)pCvtSrcRow);
									q = C_MASK(q, mask);
									//*pCvtDstRow = (byte)COL_PART((double)q/rate);
									//*pCvtDstRow = (byte)(min(q + bias, maxVal) >> shift);
									*pCvtDstRow = (q >> shift);
								}
							}
						}

						// Check Interrupt Signal
						if(nullptr != bInterrupt && *bInterrupt)
						{
							Logger::Log0("ImgLoader::ReadXRGBInternal: INTERRUPT");
							return IMGSYS_RET::ISR_INTERRUPT;
						}
					}
				}
			}
			else
			{
				for(iDim iy = rcBlkIdx.top; iy <= rcBlkIdx.bottom; ++iy)
				{
					for(iDim ix = rcBlkIdx.left; ix <= rcBlkIdx.right; ++ix)
					{
						// ======>> LOCK <<=======
						//IMGLOADER_LOCK_INTERNAL;
						CPLErr err = 
							pChannel->ReadBlock(ix, iy, pLoadTemp);
						/*if(iy == rcBlkIdx.top)
						{
							static int o = 0;
							ofstream ooo("C:\\Environment\\" + to_string(o));
							++o;
							ooo << iy << ',' << ix << ',' << c << ',' << (int)pChannel << endl;
							ooo.write((const char *)pLoadTemp, strideLoadTemp);
						}*/
						// ======>> UNLOCK <<=======
						//IMGLOADER_UNLOCK_INTERNAL;
					
						iDim blkLeft		= ix*szBlkX;
						iDim loadLeft	= max(xSrc - blkLeft, 0);
						iDim loadR		= min(szBlkX, rSrc - blkLeft + 1);
						iDim blkTop		= iy*szBlkY;
						iDim loadTop		= max(ySrc - blkTop, 0);
						iDim loadB		= min(szBlkY, bSrc - blkTop + 1);
						iDim loadTopDst	= max(blkTop - ySrc, 0);
						iDim loadLeftDst	= max(blkLeft - xSrc, 0);
					
						for(int icDest = 0; icDest < vecChannelDest.size(); ++icDest)
						{
							// no channel offset for src
							int offDst = vecChannelDest[icDest]*nPixelByteDest;
							byte *pCvtSrc = (byte*)IMG_POS(pLoadTemp, loadLeft, loadTop, strideLoadTemp, nPixelByteLoad);
							byte *pCvtDst = (byte*)IMG_POS(pLoad, loadLeftDst, loadTopDst, strideLoad, pixelSpaceDest) + offDst;
							for(iDim y = loadTop; y < loadB; ++y,
								GO_STRIDE(pCvtSrc, strideLoadTemp),
								GO_STRIDE(pCvtDst, strideLoad))
							{
								byte *pCvtSrcRow = (byte*)pCvtSrc;
								byte *pCvtDstRow = (byte*)pCvtDst;
								for(iDim x = loadLeft; x < loadR; ++x,
									GO_STRIDE(pCvtSrcRow, 1),
									GO_STRIDE(pCvtDstRow, pixelSpaceDest))
								{
									*pCvtDstRow = *pCvtSrcRow;
								}
							}
						}

						// Check Interrupt Signal
						if(nullptr != bInterrupt && *bInterrupt)
						{
							Logger::Log0("ImgLoader::ReadXRGBInternal: INTERRUPT");
							return IMGSYS_RET::ISR_INTERRUPT;
						}
					}
				}
			}

			bAnyChannelSucceeded = true;
			Logger::Log0((string)"ImgLoader::ReadXRGBInternal: " +
				"chn#" + to_string(c + 1) + " load finished"
				"[" + to_string(ticker.Cycle()) + "]");
		}
		if(!bAnyChannelSucceeded)
		{
			return IMGSYS_RET::ISR_LOADFAIL;
		}

		return IMGSYS_RET::ISR_SUCCEED;
	}
public:
	static inline idepth GetBytesOfGDALDataType(GDALDataType dt)
	{
		switch(dt)
		{
		case GDALDataType::GDT_Byte:
			return 1;
			break;
		case GDALDataType::GDT_UInt16:
		case GDALDataType::GDT_Int16:
		case GDALDataType::GDT_CInt16:
			return 2;
			break;
		case GDALDataType::GDT_UInt32:
		case GDALDataType::GDT_Int32:
		case GDALDataType::GDT_Float32:
		case GDALDataType::GDT_CInt32:
		case GDALDataType::GDT_CFloat32:
			return 4;
			break;
		case GDALDataType::GDT_Float64:
		case GDALDataType::GDT_CFloat64:
			return 8;
			break;
		default:
			return 0;
			break;
		}
	}
	static inline idepth GetBitsOfBytes(idepth depth)
	{
		// >> Overflow [8*depth] <<
		if(OVERFLOW_MUL(8, depth, IMGDEPTH_MAX))
		{
			return 0;
		}
		return 8*depth;
	}
	static string	GetGDALDataTypeStr(GDALDataType type)
	{
		switch(type)
		{
		case GDALDataType::GDT_Byte:
			return "byte";
			break;
		case GDALDataType::GDT_UInt16:
			return "u16";
			break;
		case GDALDataType::GDT_Int16:
			return "i16";
			break;
		case GDALDataType::GDT_CInt16:
			return "ci16";
			break;
		case GDALDataType::GDT_UInt32:
			return "u32";
			break;
		case GDALDataType::GDT_Int32:
			return "i32";
			break;
		case GDALDataType::GDT_Float32:
			return "f32";
			break;
		case GDALDataType::GDT_CInt32:
			return "ci32";
			break;
		case GDALDataType::GDT_CFloat32:
			return "cf32";
			break;
		case GDALDataType::GDT_Float64:
			return "f64";
			break;
		case GDALDataType::GDT_CFloat64:
			return "cf64";
			break;
		default:
			return "unknown";
			break;
		}
	}
	static GDALDataType GetGDALDataTypeOfBits(idepth nBit)
	{
		if(nBit <= 0)
		{
			return GDT_Unknown;
		}
		else if(nBit <= 8)
		{
			return GDT_Byte;
		}
		else if(nBit <= 16)
		{
			return GDT_UInt16;
		}
		else if(nBit <= 32)
		{
			return GDT_UInt32;
		}
		else if(nBit <= 64)
		{
			return GDT_Float64;
		}
		else
		{
			return GDT_Unknown;
		}
	}
	static iret		GetGDALChannelMapXRGB(vector<int> &vecMap, int nChannel)
	{
		vecMap.clear();
		switch(nChannel)
		{
		case 3:
			vecMap.emplace_back(3);
			vecMap.emplace_back(2);
			vecMap.emplace_back(1);
			break;
		case 4:
			vecMap.emplace_back(3);
			vecMap.emplace_back(2);
			vecMap.emplace_back(1);
			vecMap.emplace_back(4);
			break;
		case 1:
			vecMap.emplace_back(1);
			vecMap.emplace_back(1);
			vecMap.emplace_back(1);
			break;
		default:
			return IMGSYS_RET::ISR_FAIL;
			break;
		}

		return IMGSYS_RET::ISR_SUCCEED;
	}

	static bool		Prepare()
	{
		GDALAllRegister();

		Logger::Log0("ImgLoader: Prepared");

		__bPrepared = true;
		return __bPrepared;
	}

protected:
	LFCTYPE void	ClearPreAssign()
	{
		_status = IMGLOADER_STATUS::ILDS_EMPTY;
	
		if(nullptr != _pDataset)
		{
			GDALClose((GDALDatasetH)_pDataset);
			_pDataset = nullptr;
		}
	}
	LFCTYPE void	ClearMove()
	{
		_status = IMGLOADER_STATUS::ILDS_EMPTY;

		_pDataset		= nullptr;

		_filePath.clear();
		_fileType		= IMG_FILETYPE::IFT_UNKNOWN;
		_format			= IMGDISP_PIXELFORMAT::IPF_UNKNOWN;

		_nChannel		= 0;
		_width			= 0;
		_height			= 0;
		_mapChannel.clear();
		_bUnstandard	= false;
		_vecDT.clear();
		_nBitMax		= 0;
	}
	void			Release()
	{
		ImgLoader::ClearPreAssign();
	}
private:
	// Disable copy-ctor, = operator
	ImgLoader(ImgLoader &loader);
	ImgLoader&		operator = (ImgLoader &loader);
public:
	ImgLoader():
		_lock			(),
		_status			(IMGLOADER_STATUS::ILDS_EMPTY),
		_pDataset		(nullptr),
		_filePath		(),
		_fileType		(IMG_FILETYPE::IFT_UNKNOWN),
		_format			(IMGDISP_PIXELFORMAT::IPF_UNKNOWN),
		_nChannel		(0),
		_width			(0),
		_height			(0),
		_mapChannel		(),
		_bUnstandard	(false),
		_vecDT			(),
		_nBitMax		(0)
	{
		if(!__bPrepared)
		{
			Prepare();
		}
	}
	ImgLoader(ImgLoader &&loader):
		_lock			(),
		_status			(IMGLOADER_STATUS::ILDS_EMPTY),
		_pDataset		(nullptr),
		_filePath		(),
		_fileType		(IMG_FILETYPE::IFT_UNKNOWN),
		_format			(IMGDISP_PIXELFORMAT::IPF_UNKNOWN),
		_nChannel		(0),
		_width			(0),
		_height			(0),
		_mapChannel		(),
		_bUnstandard	(false),
		_vecDT			(),
		_nBitMax		(0)
	{
		// Assign
		AssignMove(loader);
	}
	~ImgLoader()
	{
		// ======>> LOCK <<=======
		IMGLOADER_LOCK_INTERNAL;

		Release();
	}
	
	iret			AssignMove(ImgLoader &loader)
	{
		// ======>> LOCK OTHER <<=======
		IMGLOADER_LOCKOTHER_INTERNAL(loader);
		// ======>> LOCK <<=======
		IMGLOADER_LOCK_INTERNAL;

		// Clear before assignment
		ImgLoader::ClearPreAssign();

		// Assign
		_pDataset		= loader._pDataset;
		_filePath		= loader._filePath;
		_fileType		= loader._fileType;
		_format			= loader._format;
		_nChannel		= loader._nChannel;
		_width			= loader._width;
		_height			= loader._height;
		_mapChannel		= std::forward<vector<int>>(loader._mapChannel);
		_bUnstandard	= loader._bUnstandard;
		_vecDT			= std::forward<vec_channel>(loader._vecDT);
		_nBitMax		= loader._nBitMax;
		// Assign status last
		_status			= loader._status;

		// ======>> UNLOCK <<=======
		IMGLOADER_UNLOCK_INTERNAL;

		// Clear after move
		loader.ImgLoader::ClearMove();

		return IMGSYS_RET::ISR_SUCCEED;
	}
	ImgLoader&		operator = (ImgLoader &&loader)
	{
		AssignMove(loader);

		return *this;
	}

	iret			Clear()
	{
		// ======>> LOCK <<=======
		IMGLOADER_LOCK_INTERNAL;

		_status = IMGLOADER_STATUS::ILDS_EMPTY;

		if(nullptr != _pDataset)
		{
			GDALClose((GDALDatasetH)_pDataset);
			_pDataset = nullptr;
		}

		_filePath.clear();
		_fileType		= IMG_FILETYPE::IFT_UNKNOWN;
		_format			= IMGDISP_PIXELFORMAT::IPF_UNKNOWN;

		_nChannel		= 0;
		_width			= 0;
		_height			= 0;
		_mapChannel.clear();
		_bUnstandard	= false;
		_vecDT.clear();
		_nBitMax		= 0;

		return IMGSYS_RET::ISR_SUCCEED;
	}

	iret			Open(const string &file)
	{
		// ======>> LOCK <<=======
		IMGLOADER_LOCK_INTERNAL;

		// Clear if built
		if(IsImageBind())
		{
			Clear();
		}

		// Open file
		GDALDataset *pDatasetNew = (GDALDataset*)GDALOpen(file.c_str(), GA_ReadOnly);

		if(nullptr == pDatasetNew)
		{
			return IMGSYS_RET::ISR_OPENFAIL;
		}

		// Set dataset
		_pDataset = pDatasetNew;

		// Set specification
		_filePath	= file;
		//_fileType
		//_format
		_nChannel	= _pDataset->GetRasterCount();
		_width		= _pDataset->GetRasterXSize();
		_height		= _pDataset->GetRasterYSize();

		_bUnstandard = false;
		_vecDT.resize(_nChannel);
		for(int i = 1; i <= _nChannel; ++i)
		{
			GDALRasterBand *pChannel = _pDataset->GetRasterBand(i);
			if(nullptr == pChannel)
			{
				continue;
			}
			_vecDT[i - 1].pChannel = pChannel;

			GDALDataType dt = pChannel->GetRasterDataType();
			if(dt <= GDT_Unknown)
			{
				Logger::Log0("Band#" + to_string((_Longlong)i) + ": get band info failed");
				continue;
			}
			_vecDT[i - 1].type = dt;

			idepth nByte = GetBytesOfGDALDataType(dt);
			idepth nBit = GetBitsOfBytes(nByte);
			if(nBit <= 0)
			{
				return IMGSYS_RET::ISR_INVIMGFORMAT;
			}

			_vecDT[i - 1].nBit = nBit;
			_vecDT[i - 1].maxValue = ImgBase::GetMaxTypeValue(_vecDT[i - 1].nBit);
			if(nBit != 8)
			{
				_vecDT[i - 1].bConvert = true;
				_bUnstandard = true;
			}
			_nBitMax = max(_nBitMax, nBit);
		}
	
		// Get channel map
		RET_ON_NEG(
			GetGDALChannelMapXRGB(_mapChannel, _nChannel));
		RETVAL_ON_TRUE(
			(_mapChannel.size() > 4 || _mapChannel.empty()),
			IMGSYS_RET::ISR_FAIL);

		// Customized nBit
		if(_width > 10000)
		{
			for(int j = 0; j < _vecDT.size(); ++j)
			{
				if(_vecDT[j].nBit == 16)
				{
					_vecDT[j].nBit = 12;
					_vecDT[j].maxValue = ImgBase::GetMaxTypeValue(_vecDT[j].nBit);
					_vecDT[j].bConvert = true;
				}
			}
		}
	
		_status = IMGLOADER_STATUS::ILDS_OPENED;

		// Log info
		string infoChannel = "";
		infoChannel += "Band#" + to_string((_Longlong)1) + ": DataType=" +
			GetGDALDataTypeStr(_vecDT[0].type);
		for(int i = 1; i < _nChannel; ++i)
		{
			infoChannel += "; Band#" + to_string((_Longlong)i + 1) +
				": DataType=" + GetGDALDataTypeStr(_vecDT[i].type) +
				", nBit=" + to_string(_vecDT[i].nBit);
		}
		Logger::Log0(
			"ImgLoader::Open: Opened. "
			"nChn:" + to_string((_Longlong)_nChannel) +
			", width:" + to_string((_Longlong)_width) +
			", height:" + to_string((_Longlong)_height) +
			", channels:" "[" + infoChannel + "]");

		return IMGSYS_RET::ISR_SUCCEED;
	}
	iret			TryOpen(const string &file);
	inline bool		IsOpen()
	{
		return _status == IMGLOADER_STATUS::ILDS_OPENED;
	}
	inline bool		IsImageBind()
	{
		return _status != IMGLOADER_STATUS::ILDS_EMPTY;
	}
	iret			Close()
	{
		// ======>> LOCK <<=======
		IMGLOADER_LOCK_INTERNAL;

		if(!IsOpen())
		{
			return 0;
		}

		_status = IMGLOADER_STATUS::ILDS_CLOSED;

		if(nullptr != _pDataset)
		{
			GDALClose((GDALDatasetH)_pDataset);
			_pDataset = nullptr;
		}

		return IMGSYS_RET::ISR_SUCCEED;
	}
	inline int		GetNChannel()
	{
		if(!IsImageBind())
		{
			return -1;
		}

		return _nChannel;
	}
	inline iDimB	GetImgWidth()
	{
		if(!IsImageBind())
		{
			return -1;
		}

		return _width;
	}
	inline iDimB	GetImgHeight()
	{
		if(!IsImageBind())
		{
			return -1;
		}

		return _height;
	}

	iret ReadXRGB(
		ImgBuf &imgBuf,
		const IRECT &rcLoad,
		bool *bInterrupt = nullptr,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE)
	{
		// Clear buffer first
		imgBuf.Clear();

		// ======>> LOCK <<=======
		int retLock = -1;
		IMGLOADER_LOCKREADT_INTERNAL(msTimeoutLock, retLock);
		RETVAL_ON_NP(
			retLock,
			IMGSYS_RET::ISR_LOCKFAIL);

		// Validate status
		if(!IsOpen())
		{
			return IMGSYS_RET::ISR_INVSTATUS;
		}
		// Validate basic
		if(rcLoad.IsInvalid_Out(_width, _height))
		{
			return IMGSYS_RET::ISR_INVRCSRC;
		}

		// Get buffer specificaiton
		const idepth depthImg = 4;
		iDim wLoad = rcLoad.Width();
		iDim hLoad = rcLoad.Height();

		ImgBuf imgBufTemp;
		RETVAL_ON_NEG_AND(
			imgBufTemp.Setup(wLoad, hLoad, IMGDISP_PIXELFORMAT::IPF_BGR32),
			IMGSYS_RET::ISR_FAIL,
			Logger::Log0("ImgLoader::ReadXRGB: Setup temp image buffer failed"););
		
		// ReadXRGBInternal
		iret ret = ReadXRGBInternal(rcLoad, imgBufTemp, bInterrupt);
		RETVAL_ON_NEG_AND(
			ret,
			IMGSYS_RET::ISR_LOADFAIL,
			Logger::Log0((string)"ImgLoader::ReadXRGB: Failed!"););

		// Set out params
		imgBuf = std::move(imgBufTemp);

		return ret;
	}
	iret ReadAllXRGB(
		ImgBuf &imgBuf,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE)
	{
		// Clear buffer first
		imgBuf.Clear();

		// ======>> LOCK <<=======
		int retLock = -1;
		IMGLOADER_LOCKREADT_INTERNAL(msTimeoutLock, retLock);
		RETVAL_ON_NP(
			retLock,
			IMGSYS_RET::ISR_LOCKFAIL);

		// Validate status
		if(!IsOpen())
		{
			return IMGSYS_RET::ISR_INVSTATUS;
		}

		// Get buffer specificaiton
		const idepth depthImg = 4;
		IRECT rcLoad = IRECT::FromXYWH(0, 0, _width, _height);
		iDim wLoad = rcLoad.Width();
		iDim hLoad = rcLoad.Height();

		ImgBuf imgBufTemp;
		RETVAL_ON_NEG_AND(
			imgBufTemp.Setup(wLoad, hLoad, IMGDISP_PIXELFORMAT::IPF_BGR32),
			IMGSYS_RET::ISR_FAIL,
			Logger::Log0("ImgLoader::ReadXRGB: Setup temp image buffer failed"););

		// ReadXRGBInternal
		iret ret = ReadXRGBInternal(rcLoad, imgBufTemp);
		RETVAL_ON_NEG_AND(
			ret,
			IMGSYS_RET::ISR_LOADFAIL,
			Logger::Log0((string)"ImgLoader::ReadAllXRGB: Failed!"););

		// Set out params
		imgBuf = std::move(imgBufTemp);

		return ret;
	}
};

template<typename T>
bool ImgLoader<T>::__bPrepared = Prepare();

#pragma endregion Image Loader

}

#undef _IMGDISP_SOURCE_FILE_IMGLOADER_H
#define _IMGDISP_SOURCE_FILE_IMGLOADER_CPP

#include "pch.h"

#include "ImgLoader.h"

namespace ImgDisplay
{


#pragma region Image Loader

inline void funcScopeGuardCPLMalloc(void *ptr)
{
	CPLFree(ptr);
	Logger::Log0("funcScopeGuardCPLMalloc: ptr " + to_string((_ULonglong)ptr) + " freed");
}

void* CPLAlloc(size_t sz, scope_guard &scgAlloc)
{
	scgAlloc.Release();

	void *p = nullptr;
	try
	{
		p = CPLMalloc(sz);
	}
	catch(std::exception ex)
	{
		return nullptr;
	}
	scgAlloc.SetAndEnable(std::bind(funcScopeGuardCPLMalloc, p));

	return p;
}

ChannelInfo::ChannelInfo():
	pChannel		(nullptr),
	type			(GDT_Unknown),
	bConvert		(false),
	nBit			(0),
	maxValue		(0)
{
}

#ifdef USE_IMGLOADER_OBSOLETE
iret ImgLoader::ReadXRGB0(
	IRECT rcSrc,
	void *pDest, iDim wDest, iDim hDest, iDim strideDest)
{
	if(!IsOpen())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	if(nullptr == pDest)
	{
		return IMGSYS_RET::ISR_NULLIMG;
	}
	if(wDest < 1|| hDest < 1)
	{
		return IMGSYS_RET::ISR_INVDESTSIZE;
	}
	if(rcSrc.IsInvalid_Out(_width, _height))
	{
		return IMGSYS_RET::ISR_INVRCSRC;
	}

	// correct rcSrc
	rcSrc.CorrectSize(wDest, hDest);

	iDim xSrc	= rcSrc.left;
	iDim ySrc	= rcSrc.top;
	iDim rSrc	= rcSrc.right;
	iDim bSrc	= rcSrc.bottom;
	iDim wSrc	= rcSrc.Width();
	iDim hSrc	= rcSrc.Height();

	// specification of dest
	const int nChannelDestTotal		= 4;
	GDALDataType dtDest				= GDT_Byte;
	
	int nChannelDest		= _nChannel;
	idepth nPixelByteDest		= GetBytesOfGDALDataType(dtDest);
	int nBandSpaceDest		= nPixelByteDest;
	int pixelSpaceDest		= nChannelDestTotal * nPixelByteDest;
	// fit bandmap and nChannelDest to XRGB
	vector<int> mapChannel;
	if(GetGDALChannelMapXRGB(mapChannel, _nChannel) < 0)
	{
		return IMGSYS_RET::ISR_FAIL;
	}
	nChannelDest = (int)mapChannel.size();

	CPLErr err = CPLErr::CE_None;
	if(_bUnstandard)
	{
		// specification of convert source
		GDALDataType dtCvt	= GetGDALDataTypeOfBits(_nBitMax);
		
		int nChannelCvt		= nChannelDest;
		idepth nPixelByteCvt	= GetBytesOfGDALDataType(dtCvt);
		int nBandSpaceCvt	= nPixelByteCvt;
		int pixelSpaceCvt	= nChannelCvt * nPixelByteCvt;
		iDim strideCvt		= CalcStride(pixelSpaceCvt, wSrc);
		size_t sizeCvt		= hSrc*strideCvt;

		// Alloc
		void *pCvt			= nullptr;
		scope_guard scgImg;
		pCvt = ImgBase::Alloc(sizeCvt, scgImg);
		RETVAL_ON_NULLPTR_AND(
			pCvt,
			IMGSYS_RET::ISR_ALLOCFAIL,
			Logger::Log0("ImgLoader::ReadXRGB0: alloc error");
			);

		// load to temp buffer
		err = _pDataset->RasterIO(
			GF_Read, xSrc, ySrc, wSrc, hSrc,
			pCvt, wDest, hDest,
			dtCvt, nChannelCvt, mapChannel.data(), pixelSpaceCvt, strideCvt, nBandSpaceCvt);

		// convert pixel type
		for(int c = 0; c < nChannelCvt; ++c)
		{
			int idxChannelSrc = mapChannel[c] - 1;

			ui64 maxVal	= _vecDT[idxChannelSrc].maxValue;
			int nBit		= _vecDT[idxChannelSrc].nBit;
			if(maxVal <= 0 || nBit <= 0)
			{
				return IMGSYS_RET::ISR_FAIL;
			}

			double rate = (double)maxVal/255;
			int bias = (1 << ((nBit - 8)/2));

			int offCvt = idxChannelSrc*nPixelByteCvt;
			int offDst = c*nPixelByteDest;
			void *pCvtSrc = (byte*)pCvt + ySrc*strideCvt + xSrc*pixelSpaceCvt + offCvt;
			void *pCvtDst = (byte*)pDest + offDst;
			for(int y = 0; y < hSrc; ++y,
				GO_STRIDE(pCvtSrc, strideCvt),
				GO_STRIDE(pCvtDst, strideDest))
			{
				void *pCvtSrcRow = (byte*)pCvtSrc;
				byte *pCvtDstRow = (byte*)pCvtDst;
				for(int x = 0; x < wSrc; ++x,
					GO_STRIDE(pCvtSrcRow, pixelSpaceCvt),
					GO_STRIDE(pCvtDstRow, pixelSpaceDest))
				{
					qword q = *((qword*)pCvtSrcRow);
					q = C_MASK(q, nBit);
					//*pCvtDstRow = (byte)COL_PART((double)q/rate);
					*pCvtDstRow = (byte)((q + bias) >> (nBit - 8));
				}
			}
		}

	}
	else
	{
		err = _pDataset->RasterIO(
			GF_Read, xSrc, ySrc, wSrc, hSrc,
			pDest, wDest, hDest,
			dtDest, nChannelDest, mapChannel.data(), pixelSpaceDest, strideDest, nBandSpaceDest);
	}

	return (iret)err;
}
#endif

#pragma endregion Image Loader

}

#undef _IMGDISP_SOURCE_FILE_IMGLOADER_CPP
#define _IMGDISP_SOURCE_FILE_IMGDISPBASE_H
#pragma once

//#include "ImgBase.h"
#include "ImgLoader.h"


namespace ImgDisplay
{

#pragma region Image IBlock
/************************
 IBlock
*************************/

template<typename T>
class __declspec(dllexport) IBlock
{
public:
	// Core type
	typedef T						iDim;
	typedef	iDim					idxblk;// TODO

	// Blocker type
	typedef	Blocker_C1<iDim>		BLOCKER;
protected:
	// Block position
	idxblk			_idxX;
	idxblk			_idxY;

	iDim			_xSrc;
	iDim			_ySrc;
	ioff			_offset;

	// Specification
	iDim			_wBlk;
	iDim			_hBlk;

protected:
	LFCTYPE void	ClearPreAssign()
	{
	}
	LFCTYPE void	ClearMove()
	{
		_idxX		= -1;
		_idxY		= -1;
		_xSrc		= -1;
		_ySrc		= -1;
		_offset		= -1;
		_wBlk		= INVALID_WIDTH;
		_hBlk		= INVALID_HEIGHT;
	}

public:
	IBlock():
		_idxX		(-1),
		_idxY		(-1),
		_xSrc		(-1),
		_ySrc		(-1),
		_offset		(-1),
		_wBlk		(INVALID_WIDTH),
		_hBlk		(INVALID_HEIGHT)
	{
	}
	IBlock(const IBlock& iblk):
		_idxX		(iblk._idxX),
		_idxY		(iblk._idxY),
		_xSrc		(iblk._xSrc),
		_ySrc		(iblk._ySrc),
		_offset		(iblk._offset),
		_wBlk		(iblk._wBlk),
		_hBlk		(iblk._hBlk)
	{
	}

	iret			Assign(const IBlock &iblk)
	{
		// Clear before assignment
		IBlock::ClearPreAssign();
	
		// Assign
		_idxX		= iblk._idxX;
		_idxY		= iblk._idxY;
		_xSrc		= iblk._xSrc;
		_ySrc		= iblk._ySrc;
		_offset		= iblk._offset;
		_wBlk		= iblk._wBlk;
		_hBlk		= iblk._hBlk;

		return IMGSYS_RET::ISR_SUCCEED;
	}
	iret			AssignMove(IBlock &iblk)
	{
		// Clear before assignment
		IBlock::ClearPreAssign();

		// Assign
		_idxX		= iblk._idxX;
		_idxY		= iblk._idxY;
		_xSrc		= iblk._xSrc;
		_ySrc		= iblk._ySrc;
		_offset		= iblk._offset;
		_wBlk		= iblk._wBlk;
		_hBlk		= iblk._hBlk;

		// Clear after move
		iblk.IBlock::ClearMove();

		return IMGSYS_RET::ISR_SUCCEED;
	}
	IBlock& operator = (const IBlock &iblk)
	{
		// Assign
		Assign(iblk);

		return *this;
	}

	virtual iret	Clear()
	{
		_idxX		= -1;
		_idxY		= -1;
		_xSrc		= -1;
		_ySrc		= -1;
		_offset		= -1;
		_wBlk		= INVALID_WIDTH;
		_hBlk		= INVALID_HEIGHT;

		return IMGSYS_RET::ISR_SUCCEED;
	}
	virtual iret	SetBlock(
		idxblk ix, idxblk iy, iDim xSrcPos, iDim ySrcPos,
		iDim width, iDim height, idepth depth, iDim stride = INVALID_STRIDE)
	{
		if (ix < 0 || iy < 0 ||
			xSrcPos < 0 || ySrcPos < 0 ||
			width <= 0 || height <= 0
			//|| offset < 0
			)
		{
			return IMGSYS_RET::ISR_INVRCSRC;
		}

		_idxX		= ix;
		_idxY		= iy;

		_xSrc		= xSrcPos;
		_ySrc		= ySrcPos;

		iDim strideActual = (INVALID_STRIDE == stride) ? ImgBase::CalcStride(depth, width) : stride;
		_offset		= IMG_OFF(_xSrc, _ySrc, strideActual, depth);

		_wBlk		= width;
		_hBlk		= height;

		return IMGSYS_RET::ISR_SUCCEED;
	}
};

#pragma endregion Image IBlock


#pragma region IImgData
/************************
 IImgData
*************************/

enum IMGDATA_STORAGE
{
	//IDS_PMEM	= 0,	// Private memory
	IDS_GMAP	= 1,	// Global MMap
	IDS_MMAP	= 2		// Private MMap 
};

template<typename T>
class __declspec(dllexport) IImgData : public ImgBuf<T>
{
protected:
	// Core type
	typedef	T					iDim;

	// Aux type
	typedef	RECTX<T>			IRECT;
	typedef	POINTX<T>			IPOINT, IVEC2;

protected:
	IMGDATA_STORAGE	_store;

	MMap			_mmap;

	string			_tmpFileDir;

protected:
	LFCTYPE void	ClearPreAssign()
	{
	}
	LFCTYPE void	ClearMove()
	{
		_store			= IMGDATA_STORAGE::IDS_MMAP;
	}
	void			Release()
	{
		IImgData::ClearPreAssign();
	}
private:
	IImgData(const IImgData &ispec);
	IImgData&	operator = (const IImgData &iimg);
public:
	IImgData():
		ImgBuf			(),
		_store			(IMGDATA_STORAGE::IDS_MMAP),
		_mmap			(),
		_tmpFileDir		()
	{
	}
	IImgData(IImgData &&ispec):
		ImgBuf			(),
		_store			(IMGDATA_STORAGE::IDS_MMAP),
		_mmap			(),
		_tmpFileDir		()
	{
		AssignMove(ispec);
	}
	virtual ~IImgData()
	{
		Release();
	}
	
	iret			AssignMove(IImgData &iimg)
	{
		// Clear before assignment
		IImgData::ClearPreAssign();

		RET_ON_NEG(
			ImgBuf::AssignMove(iimg));
		_store			= iimg._store;
		_mmap.AssignMove(std::forward<MMap>(iimg._mmap));
		_tmpFileDir		= std::forward<string>(iimg._tmpFileDir);

		// Clear move
		iimg.IImgData::ClearMove();

		return IMGSYS_RET::ISR_SUCCEED;
	}
	IImgData&	operator = (IImgData &&iimg)
	{
		// Assign
		AssignMove(iimg);

		return *this;
	}

	virtual iret	Clear() OVERRIDE
	{
		// ImgBuf
		ImgBuf::Clear();

		// MMap
		_mmap.Clear();

		// Settings
		//_store
		//_tmpFileDir

		return IMGSYS_RET::ISR_SUCCEED;
	}

	iret			SetStoreMode(IMGDATA_STORAGE modeStore)
	{
		if(!IsEmpty())
		{
			return IMGSYS_RET::ISR_INVSTATUS;
		}
		_store = modeStore;
		return IMGSYS_RET::ISR_SUCCEED;
	}
	virtual iret	SetTempFileDir(const string &tmpFileDir)
	{
		_tmpFileDir = tmpFileDir;
		if(_tmpFileDir.empty())
		{
			_tmpFileDir += '\\';
		}
		else
		{
			if(_tmpFileDir.back() != '\\')
			{
				_tmpFileDir += '\\';
			}
		}

		return IMGSYS_RET::ISR_SUCCEED;
	}
	virtual iret	Setup(iDim width, iDim height,
		IMGDISP_PIXELFORMAT format,
		const string &shmName,
		void *pDataGMap = nullptr, iDim strideForce = INVALID_STRIDE) PURE;

	inline bool	IsEmpty() const
	{
		return ImgBuf::IsEmpty();
	}
};

#pragma endregion IImgData


#pragma region Image IImgDataBlock
/************************
 IImgDataBlock
*************************/

template<typename T>
class __declspec(dllexport) IImgDataBlock : public IImgData<T>
{
protected:
	// Core type
	typedef	T					iDim;

	// Aux type
	typedef	RECTX<T>			IRECT;
	typedef	POINTX<T>			IPOINT, IVEC2;

protected:
	LFCTYPE void	ClearPreAssign()
	{
	}
	LFCTYPE void	ClearMove()
	{
	}
	void			Release()
	{
		IImgDataBlock::ClearPreAssign();
	}
private:
	IImgDataBlock(const IImgDataBlock &ispec);
	IImgDataBlock&	operator = (const IImgDataBlock &iimg);
public:
	IImgDataBlock():
		IImgData			()
	{
	}
	IImgDataBlock(IImgDataBlock &&ispec):
		IImgData			()
	{
		AssignMove(ispec);
	}
	virtual ~IImgDataBlock()
	{
		Release();
	}
	
	iret			AssignMove(IImgDataBlock &iimg)
	{
		// Clear before assignment
		IImgDataBlock::ClearPreAssign();

		RET_ON_NEG(
			IImgData::AssignMove(iimg));

		iimg.IImgDataBlock::ClearMove();

		return IMGSYS_RET::ISR_SUCCEED;
	}
	IImgDataBlock&	operator = (IImgDataBlock &&iimg)
	{
		// Assign
		AssignMove(iimg);

		return *this;
	}

	virtual iret	Setup(iDim width, iDim height,
		IMGDISP_PIXELFORMAT format,
		const string &shmName,
		void *pDataGMap = nullptr, iDim strideForce = INVALID_STRIDE) OVERRIDE
	{
		if(!IsEmpty())
		{
			IImgDataBlock::Clear();
		}

		switch(_store)
		{
		case IMGDATA_STORAGE::IDS_GMAP:
			RET_ON_NEG(
				ImgBuf::SetupFrom(width, height, format, pDataGMap, strideForce));
			break;
		case IMGDATA_STORAGE::IDS_MMAP:
			RET_ON_NEG(
				ImgBuf::SetupSpec(width, height, format));
			RETVAL_ON_FAILED(
				_mmap.Create(shmName, _size),
				IMGSYS_RET::ISR_MMAPFAIL);
			RET_ON_NEG(
				ImgBuf::SetupData((void*)_mmap.GetPData()));
			break;
		default:
			return IMGSYS_RET::ISR_UNKNOWNOP;
			break;
		}

		return IMGSYS_RET::ISR_SUCCEED;
	}
};

#pragma endregion Image IImgDataBlock


#pragma region Image IImgDataLevel
/************************
 IImgDataLevel
*************************/

template<typename T>
class __declspec(dllexport) IImgDataLevel : public IImgData<T>
{
protected:
	// Core type
	typedef T		iDim;

	// Aux type
	typedef	RECTX<T>			IRECT;
	typedef	POINTX<T>			IPOINT, IVEC2;

protected:
	LFCTYPE void	ClearPreAssign() LFCOVERRIDE
	{
	}
	LFCTYPE void	ClearMove()
	{
	}
	void			Release()
	{
		IImgDataLevel::ClearPreAssign();
	}
private:
	IImgDataLevel(const IImgDataLevel &iimg);
	IImgDataLevel&	operator = (const IImgDataLevel &iimg);
public:
	IImgDataLevel():
		IImgData		()
	{
	}
	IImgDataLevel(IImgDataLevel &&ilvl):
		IImgData		()
	{
		AssignMove(ilvl);
	}
	virtual ~IImgDataLevel()
	{
		Release();
	}

	iret			AssignMove(IImgDataLevel &ilvl)
	{
		// Clear before assignment
		IImgDataLevel::ClearPreAssign();

		RET_ON_NEG(
			IImgData::AssignMove(ilvl));

		ilvl.IImgDataLevel::ClearMove();

		return IMGSYS_RET::ISR_SUCCEED;
	}
	IImgDataLevel&	operator = (IImgDataLevel &&ilvl)
	{
		AssignMove(ilvl);

		return *this;
	}

	virtual iret	Setup(iDim width, iDim height,
		IMGDISP_PIXELFORMAT format,
		const string &shmName,
		void *pDataGMap = nullptr, iDim strideForce = INVALID_STRIDE) OVERRIDE
	{
		if(!IsEmpty())
		{
			IImgDataLevel::Clear();
		}

		// Get bFile, file name
		bool bFile = true;
		string fileName = _tmpFileDir + shmName + ".bil";
		switch(_store)
		{
		case IMGDATA_STORAGE::IDS_GMAP:
			// Validate basic
			if(shmName.empty())
			{
				return IMGSYS_RET::ISR_INVARGS;
			}

			RET_ON_NEG(
				ImgBuf::SetupSpec(width, height, format));
			RETVAL_ON_FAILED(
				_mmap.Create(shmName, _size, bFile, fileName),
				IMGSYS_RET::ISR_MMAPFAIL);
			// TODO: Zero memory
			//_mmap.ZeroMem(_size);
			RET_ON_NEG(
				ImgBuf::SetupData((void*)_mmap.GetPData()));
			break;
		case IMGDATA_STORAGE::IDS_MMAP:
			RET_ON_NEG(
				ImgBuf::SetupSpec(width, height, format));
			break;
		default:
			return IMGSYS_RET::ISR_UNKNOWNOP;
			break;
		}

		return IMGSYS_RET::ISR_SUCCEED;
	}

	void *GetPData() const
	{
		return ImgBuf::GetPImg();
	}
};

#pragma endregion Image IImgDataLevel


#pragma region Image IImgDataPool
/************************
 IImgDataPool
*************************/

class ImgDataCube
{
protected:
};

//class IImgDataPool : public IImgSpec
//{
//protected:
//	// Blocker
//	Blocker_C1		_blocker;
//};

#pragma endregion Image IImgDataPool


#pragma region Image IImgBuffer
/************************
 IImgBuffer
*************************/

class IImgBuffer
{
protected:
	mutable bool	_bFullLoaded;

protected:
	LFCTYPE void	ClearPreAssign() LFCOVERRIDE;
	LFCTYPE void	ClearMove();
	void			Release();
private:
	IImgBuffer(const IImgBuffer &ibuf);
	IImgBuffer&	operator = (const IImgBuffer &ibuf);
public:
	IImgBuffer();
	IImgBuffer(IImgBuffer &&ibuf);
	virtual ~IImgBuffer();

	iret			AssignMove(IImgBuffer &ibuf);
	//IImgBuffer	&	operator = (IImgBuffer &&ibuf);

	iret			Clear();
};

#pragma endregion Image IImgBuffer


#pragma region ImgRegion
/************************
 ImgRegion
*************************/

template<typename T, typename = typename enable_if_int3264<T>::type>
struct ImgRegion
{
typedef T				iDim;
typedef POINTX<iDim>	VEC2X;

	VEC2X		_sizeTarget;

	RECTXZ		_rcTarget;

	ImgRegion():
		_sizeTarget	(VEC2X(0, 0)),
		_rcTarget	()
	{
	}
	ImgRegion(iDim w, iDim h, iDimZ x, iDimZ y, iDimZ r, iDimZ b):
		_sizeTarget	(VEC2X(w, h)),
		_rcTarget	(RECTXZ(x, y, r, b))
	{
	}
	bool Equals(const ImgRegion &r)
	{
		return _sizeTarget.Equals(r._sizeTarget) && _rcTarget.Equals(r._rcTarget);
	}
	bool Invalid() const
	{
		return _sizeTarget.IsZeroNegative() || _rcTarget.IsInvalid_Size();
	}
};

#pragma endregion ImgRegion

}

#undef _IMGDISP_SOURCE_FILE_IMGDISPBASE_H
#define _IMGDISP_SOURCE_FILE_IMGDISPBASE_CPP

#include "pch.h"

#include "ImgDispBase.h"


namespace ImgDisplay
{


#pragma region Image IBlock

#pragma endregion Image IBlock


#pragma region Image IImgDataBlock

#pragma endregion Image IImgDataBlock


#pragma region Image IImgDataLevel

#pragma endregion Image IImgDataLevel


#pragma region Image IImgBuffer

void IImgBuffer::ClearPreAssign()
{
}

void IImgBuffer::ClearMove()
{
}

void IImgBuffer::Release()
{
}

IImgBuffer::IImgBuffer():
	_bFullLoaded	(false)
{
}

IImgBuffer::IImgBuffer(IImgBuffer &&ibuf):
	_bFullLoaded	(false)
{
	// Assign
	AssignMove(ibuf);
}

IImgBuffer::~IImgBuffer()
{
	Release();
}

iret IImgBuffer::AssignMove(IImgBuffer &ibuf)
{
	// Clear before assignment
	IImgBuffer::ClearPreAssign();

	_bFullLoaded	= ibuf._bFullLoaded;

	// Clear after move
	ibuf.IImgBuffer::ClearMove();

	return IMGSYS_RET::ISR_SUCCEED;
}

iret IImgBuffer::Clear()
{
	_bFullLoaded = false;

	return IMGSYS_RET::ISR_SUCCEED;
}

#pragma endregion Image IImgBuffer


#pragma region ImgRegion

#pragma endregion ImgRegion

}

#undef _IMGDISP_SOURCE_FILE_IMGDISPBASE_CPP
#define _IMGDISP_SOURCE_FILE_IMGDISP_H
#pragma once


#include <time.h>
#include <string>
#include <fstream>
#include <vector>


//#include "ImgBase.h"
#include "ImgDispBase.h"


using std::string;
using std::vector;


namespace ImgDisplay
{


#pragma region Enums Definition

enum IMG_UPDATE_TYPE
{
	IUT_INIT		= 1,
	IUT_UPDATE		= 2
};


// Image Block radio flag
#define IMGBLKSTATUS_ONLINE		0x01
#define IMGBLKSTATUS_OFFLINE	0x02
#define IMGBLKSTATUS_UPDATING	0x08

#define IMGBLKSTATUS_BUILDING		(0x10 | IMGBLKSTATUS_UPDATING)
#define IMGBLKSTATUS_OPENING		(0x20 | IMGBLKSTATUS_UPDATING)
#define IMGBLKSTATUS_DYING			(0x40 | IMGBLKSTATUS_UPDATING)

#define IMGBLKSTATUS_LOADING		(0x100 | IMGBLKSTATUS_UPDATING)
#define IMGBLKSTATUS_UNLOADING		(0x200 | IMGBLKSTATUS_UPDATING)

#define IMGBLKSTATUS_INITLOADING	(0x1000 | IMGBLKSTATUS_UPDATING)
#define IMGBLKSTATUS_SAMPLING		(0x2000 | IMGBLKSTATUS_UPDATING)
#define IMGBLKSTATUS_EDITING		(0x4000 | IMGBLKSTATUS_UPDATING)


#define IMGBLKSTATUS_ISONLINE(S)	(((S) & IMGBLKSTATUS_ONLINE) != 0)
#define IMGBLKSTATUS_ISUPDATING(S)	(((S) & IMGBLKSTATUS_UPDATING) != 0)


enum IMGBLOCK_LOADSTATUS
{
	BLS_EMPTY		= ((-1 & (~IMGBLKSTATUS_ONLINE)) & (~IMGBLKSTATUS_OFFLINE)),

	BLS_READY		= 0,

	BLS_LIVE		= IMGBLKSTATUS_ONLINE,
	BLS_OFFLINE		= IMGBLKSTATUS_OFFLINE,
	BLS_SYNC		= (IMGBLKSTATUS_ONLINE | IMGBLKSTATUS_OFFLINE),

	// EMPTY -> READY
	BLS_BUILDING	= (IMGBLKSTATUS_BUILDING	& (~IMGBLKSTATUS_ONLINE) & (~IMGBLKSTATUS_OFFLINE)),
	// READY -> SYNC
	BLS_OPENING		= (IMGBLKSTATUS_OPENING		& (~IMGBLKSTATUS_ONLINE) & (~IMGBLKSTATUS_OFFLINE)),
	// ANY -> EMPTY
	BLS_DYING		= (IMGBLKSTATUS_DYING		& (~IMGBLKSTATUS_ONLINE) & (~IMGBLKSTATUS_OFFLINE)),

	// OFFLINE -> SYNC
	BLS_LOADING		= (IMGBLKSTATUS_LOADING		& (~IMGBLKSTATUS_ONLINE) | IMGBLKSTATUS_OFFLINE),
	// SYNC -> OFFLINE
	BLS_UNLOADING	= (IMGBLKSTATUS_UNLOADING	& (~IMGBLKSTATUS_ONLINE) & (~IMGBLKSTATUS_OFFLINE)),

	// Added
	BLS_INITLOADING	= (IMGBLKSTATUS_INITLOADING),
	BLS_SAMPLING	= (IMGBLKSTATUS_SAMPLING),
	BLS_EDITING		= (IMGBLKSTATUS_EDITING)
};

enum IMGBLOCK_DATASTATUS
{
	BDS_EMPTY		= 0,
	BDS_PART		= 1,
	BDS_FULL		= 3

	//BDS_INITING		= 4,
	//BDS_EDITING		= 8
};

enum IMGBLOCK_RENDER_STATUS
{
	BRS_NORENDER	= 0,
	BRS_RENDER		= 1,
	BRS_MARGIN		= 2
};

enum IMGLEVEL_STATUS
{
	LLS_EMPTY		= -1,
	LLS_UNLOAD		= 0,
	LLS_PARTLOAD	= 1,	// either block is PARTLOAD
	LLS_LOADED		= 2		// all blocks are LOADED
};

enum IMGDISP_STATUS
{
	ILS_EMPTY		= -1,
	ILS_UNLOAD		= 1,	// levels setup but not loaded
	ILS_PARTLOAD	= 2,	// either level is PARTLOAD
	ILS_LOADED		= 3		// image loader is open
};

enum IMGDISP_DOWNSAMPLEMODE
{
	LSM_BASE			= 1,
	LSM_CHAIN			= 2
};
typedef IMGDISP_DOWNSAMPLEMODE	IMGDISP_VSAMPLEMODE;

enum IMGDISP_DOWNSAMPLEBLOCKSALIGNMODE
{
	DSBAM_NONE			= 1,
	DSBAM_ALIGNED		= 2
};
typedef IMGDISP_DOWNSAMPLEBLOCKSALIGNMODE	IMGDISP_BLOCKSALIGNMODE;

enum IMGDISP_ILLUSTRATIONMODE
{
	ILLUS_RENDER		= 1,
	ILLUS_LOAD			= 2,
	//ILLUS_DATA			= 3,
	ILLUS_CUSTOMIZED	= 4
};
typedef IMGDISP_ILLUSTRATIONMODE	IMGDISP_ILLUSMODE;

#pragma endregion Enums Definition


#pragma region Helper

// Image data level buffer - base
template<typename T>
struct IMG_BLOCKBUF : ImgBuf<T>
{
public:
	// Core type
	typedef	T					iDim;
	// Aux type
	typedef	RECTX<T>			IRECT;
	typedef	POINTX<T>			IPOINT, IVEC2;
public:
	typedef vector<vector<IMGBLOCK_DATASTATUS>>		vec2blkstatus;

	IRECT			rcBlock;
	IRECT			rcRegion;
	vec2blkstatus	vec2BlkStatus;

	IMG_BLOCKBUF():
		ImgBuf			(),
		rcBlock			(),
		rcRegion		(),
		vec2BlkStatus	()
	{
	}
	IMG_BLOCKBUF& operator = (IMG_BLOCKBUF &&other)
	{
		ImgBuf::operator=(std::forward<ImgBuf>(other));

		rcBlock			= other.rcBlock;
		rcRegion		= other.rcRegion;
		vec2BlkStatus	= std::forward<vec2blkstatus>(other.vec2BlkStatus);

		other.IMG_BLOCKBUF::Clear();

		return *this;
	}

	bool		HasData() const
	{
		return ImgBuf::HasData();
	}
	iret		Clear()
	{
		ImgBuf::Clear();

		rcBlock			= IRECT();
		rcRegion		= IRECT();
		vec2BlkStatus.clear();

		return IMGSYS_RET::ISR_SUCCEED;
	}
};

#pragma endregion Helper


#pragma region ImgBlock

/************************
 ImgBlock
*************************/
#define IMGBLOCK_LOCK_INTERNAL				scope_guard scgLockInternal;\
											_lock.LockGuard(scgLockInternal);
#define IMGBLOCK_LOCKSCG_INTERNAL(SCG)		_lock.LockGuard(SCG);
#define IMGBLOCK_TRYLOCK_INTERNAL(RET)		scope_guard scgLockInternal;\
											(RET) = _lock.TryLockGuard(scgLockInternal);
#define IMGBLOCK_UNLOCK_INTERNAL			scgLockInternal.Release();

#define IMGBLOCK_LOCKWRITE_INTERNAL			scope_guard scgLockWriteInternal;\
											_lock.LockWriteGuard(scgLockWriteInternal);
#define IMGBLOCK_UNLOCKWRITE_INTERNAL		scgLockWriteInternal.Release();

#define IMGBLOCK_TRYLOCKIREAD_INTERNAL(RET)	scope_guard scgLockIReadInternal;\
											(RET) = _lock.TryLockIReadGuard(scgLockIReadInternal);
#define IMGBLOCK_LOCKIREAD_INTERNAL			scope_guard scgLockIReadInternal;\
											_lock.LockIReadGuard(scgLockIReadInternal);

#define IMGBLOCK_LOCKOTHER_INTERNAL(OTHER)	scope_guard scgLockOtherInternal;\
											(OTHER)._lock.LockGuard(scgLockOtherInternal);
#define IMGBLOCK_UNLOCKOTHER_INTERNAL		scgLockOtherInternal.Release();

class DLLEXPORT ImgBlock : protected IBlock<iDimB>, protected IImgDataBlock<iDimB>
{
public:
	// Core type
	typedef iDimB					iDim;
	// Aux type
	typedef	RECTX<iDim>				IRECT;
	typedef	POINTX<iDim>			IPOINT, IVEC2;

protected:
	// Lock
	mutable icrwb_lock	_lock;

	// Status
	IMGBLOCK_LOADSTATUS	_sLoad;
	IMGBLOCK_DATASTATUS	_sData;

	// Flag
	mutable IMGBLOCK_RENDER_STATUS _statusR;
	mutable atom<bool>	_bUpdated;
	mutable atom<bool>	_bInitLoad;
	
protected:
#pragma region Internal
	iret			ClearInternal();
	iret			SetupInternal(
		IMGDATA_STORAGE modeStore,
		idxblk iBlkX, idxblk iBlkY,
		IMGDISP_PIXELFORMAT format,
		iDim xBlkSrc, iDim yBlkSrc, iDim width, iDim height,
		void *pDataGMAP = nullptr, iDim strideGMAP = INVALID_STRIDE) LOCKCONTROLED;
#pragma endregion Internal
	
#pragma region Setup
	iret			SetSpecification(
		idxblk ix, idxblk iy,
		iDim xSrcPos, iDim ySrcPos,
		iDim width, iDim height, idepth depth, iDim stride = INVALID_STRIDE);
#pragma endregion Setup

	void			PostUpdateSpec();

protected:
	LFCTYPE void	PreAssign() LFCOVERRIDE;
	LFCTYPE void	ClearPreAssign() LFCOVERRIDE;
	LFCTYPE void	ClearMove() LFCOVERRIDE;
	void			Release();
private:
	// Disable copy-ctor, = operator
	ImgBlock(const ImgBlock &blk);
	ImgBlock&		operator = (const ImgBlock &blk);
public:
	ImgBlock();
	ImgBlock(ImgBlock &&blk);
	~ImgBlock();

	iret			AssignMove(ImgBlock &blk) LOCKCONTROLED;
	ImgBlock&		operator = (ImgBlock &&blk);
	
	virtual iret	Clear() OVERRIDE LOCKCONTROLED;

#pragma region Status
	// Whether block structure is built
	inline bool		IsBuilt() const
	{
		return ( _sLoad != IMGBLOCK_LOADSTATUS::BLS_EMPTY );
	}
	inline bool		IsInconsistentDataAvailable() const
	{
		return ( _sLoad == IMGBLOCK_LOADSTATUS::BLS_SYNC );
	}
	inline bool		IsUnwritable() const// updating or empty
	{
		return ( _sLoad != IMGBLOCK_LOADSTATUS::BLS_SYNC );
	}
	
	inline bool		SetStatus_Unsafe(IMGBLOCK_LOADSTATUS s)
	{
		_sLoad = s;
		return true;
	}
	inline bool		SetDataStatus_Unsafe(IMGBLOCK_DATASTATUS s)
	{
		_sData = s;
		return true;
	}
	inline void		SetRenderStatus(IMGBLOCK_RENDER_STATUS rs) const
	{
		_statusR = rs;
	}
	bool			IsInitLoadDataStatus_Unsafe() const;
	bool			IsUpdateDataStatus_Unsafe() const;
	bool			IsLoadStatus_Unsafe() const;
	bool			IsUnLoadStatus_Unsafe() const;
	inline IMGBLOCK_LOADSTATUS GetStatus_Unsafe() const;
	inline IMGBLOCK_DATASTATUS GetDataStatus_Unsafe() const
	{
		return _sData;
	}
	inline IMGBLOCK_RENDER_STATUS GetRenderStatus() const;
	iret			SetStatusAvailable_Unsafe(bool bFull = false);
	iret			SetStoreMode(IMGDATA_STORAGE modeStore);
#pragma endregion Status

#pragma region Flag
	iret			SetUpdateFlag(bool bUpdate) const;
	bool			IsUpdateFlagSet() const;
	bool			CheckResetUpdateFlag() const;
	iret			SetInitLoadFlag(bool bUpdate) const;
	bool			IsInitLoadFlagSet() const;
	bool			CheckResetInitLoadFlag() const;
#pragma endregion Flag
	
#pragma region Setup
	iret			Setup(
		idxblk iBlkX, idxblk iBlkY,
		IMGDISP_PIXELFORMAT format,
		iDim xBlkSrc, iDim yBlkSrc, iDim width, iDim height,
		void *pData = nullptr, iDim strideSrc = INVALID_STRIDE) LOCKCONTROLED;
	iret			Setup(
		IMGDATA_STORAGE modeStore,
		idxblk iBlkX, idxblk iBlkY,
		IMGDISP_PIXELFORMAT format,
		iDim xBlkSrc, iDim yBlkSrc, iDim width, iDim height,
		void *pData, iDim strideSrc) LOCKCONTROLED;
#pragma endregion Setup
	
	iret			LockIRead(scope_guard &scgLockIRead, ms_t1 msTimeout = LOCK_TIME_INFINITE) LOCKCONTROLED const;
	iret			LockWrite(scope_guard &scgLockWrite, ms_t1 msTimeout = LOCK_TIME_INFINITE) LOCKCONTROLED const;
	iret			LockBlock(scope_guard &scgLockBlock, ms_t1 msTimeout = LOCK_TIME_INFINITE) LOCKCONTROLED const;

#pragma region Load/Unload/Update
	iret			Load() LOCKCONTROLED;
	iret			Unload() LOCKCONTROLED;
	iret			Update(void *p, iDim w, iDim h, iDim x, iDim y) LOCKCONTROLED;
#pragma endregion Load/Unload/Update

#pragma region Render
	// Realtime render
	iret			Render(
		void* pBufDest, iDim wBufDest, iDim hBufDest, iDim strideBuf,
		iDim xDest, iDim yDest, iDim wDest, iDim hDest,
		int interpolation = IPPI_INTER_NN) const LOCKCONTROLED;
#pragma endregion Render
};

#pragma endregion ImgBlock


#pragma region ImgLevel

/************************
 ImgLevel
*************************/
#define IMGLEVEL_LOCK_INTERNAL				scope_guard scgLockInternal;\
											_lock.LockGuard(scgLockInternal);
#define IMGLEVEL_LOCKSCG_INTERNAL(SCG)		_lock.LockGuard(SCG);
#define IMGLEVEL_TRYLOCK_INTERNAL(RET)		scope_guard scgLockInternal;\
											(RET) = _lock.TryLockGuard(scgLockInternal);
#define IMGLEVEL_UNLOCK_INTERNAL			scgLockInternal.Release();

#define IMGLEVEL_LOCKWRITE_INTERNAL			scope_guard scgLockWriteInternal;\
											_lock.LockWriteGuard(scgLockWriteInternal);
#define IMGLEVEL_UNLOCKWRITE_INTERNAL		scgLockWriteInternal.Release();

#define IMGLEVEL_TRYLOCKIREAD_INTERNAL(RET)	scope_guard scgLockIReadInternal;\
											(RET) = _lock.TryLockIReadGuard(scgLockIReadInternal);
#define IMGLEVEL_LOCKIREAD_INTERNAL			scope_guard scgLockIReadInternal;\
											_lock.LockIReadGuard(scgLockIReadInternal);
#define IMGLEVEL_LOCKIREADT_INTERNAL(T, RET)	scope_guard scgLockIReadInternal;\
												RET = _lock.LockIReadGuard(scgLockIReadInternal, T);
#define IMGLEVEL_LOCKREAD_INTERNAL			scope_guard scgLockReadInternal;\
											_lock.LockReadGuard(scgLockReadInternal);
#define IMGLEVEL_LOCKREADT_INTERNAL(T, RET)	scope_guard scgLockReadInternal;\
											RET = _lock.LockReadGuard(scgLockReadInternal, T);
#define IMGLEVEL_LOCKIREADSCG_INTERNAL(SCG)	_lock.LockIReadGuard(SCG);

#define IMGLEVEL_LOCKOTHER_INTERNAL(OTHER)		scope_guard scgLockOtherInternal;\
												(OTHER)._lock.LockGuard(scgLockOtherInternal);
#define IMGLEVEL_LOCKIREADOTHER_INTERNAL(OTHER)	scope_guard scgLockOtherIReadInternal;\
												(OTHER)._lock.LockIReadGuard(scgLockOtherIReadInternal);
#define IMGLEVEL_LOCKREADOTHER_INTERNAL(OTHER)	scope_guard scgLockOtherReadInternal;\
												(OTHER)._lock.LockReadGuard(scgLockOtherReadInternal);
#define IMGLEVEL_LOCKREADOTHERT_INTERNAL(OTHER, T, RET)	scope_guard scgLockOtherReadInternal;\
														RET = (OTHER)._lock.LockReadGuard(scgLockOtherReadInternal, T);
#define IMGLEVEL_LOCKWRITEOTHER_INTERNAL(OTHER)	scope_guard scgLockOtherWriteInternal;\
												(OTHER)._lock.LockWriteGuard(scgLockOtherWriteInternal);
#define IMGLEVEL_UNLOCKOTHER_INTERNAL			scgLockOtherInternal.Release();

//template class DLLEXPORT vector<iratio>;
//template class DLLEXPORT Blocker::arr_divdst;
//template class DLLEXPORT vector<ImgBlock>;
//template class DLLEXPORT vector<vector<ImgBlock>>;

class DLLEXPORT ImgLevel : protected IImgDataLevel<iDimB>
{
public:
	// Core type
	typedef iDimB					iDim;
	// Aux type
	typedef	RECTX<iDim>				IRECT;
	typedef	POINTX<iDim>			IPOINT, IVEC2;

	// Blocker type
	typedef	Blocker<iDim>			BLOCKERBASE;
	typedef	Blocker_C1<iDim>		BLOCKER;

	typedef	BLOCKER::idxblk			idxblk;
	typedef BLOCKER::arr_divratio	arr_divratio;
	typedef BLOCKER::arr_divsrc		arr_divsrc;
	typedef BLOCKER::arr_divdst		arr_divdst;

	// Level type
	typedef	int						idxlvl;
protected:
	typedef vector<vector<ImgBlock>>	matblk;
	typedef unordered_map<IMGBLOCK_RENDER_STATUS, COLOR4B> color_map;
	
protected:
	// Lock
	mutable icrwb_lock	_lock;

	// Status
	IMGLEVEL_STATUS	_status;

	// Level index
	idxlvl			_level;

	// Blocker
	BLOCKER			_blocker;
	// Blocks
	matblk			_blocks;

	// Settings
	IMGDISP_BLOCKSALIGNMODE _blocksAlign;
	color_map		_mapColorRender;

	ms_t1			__msTimeoutLockSetupData;

protected:
#pragma region Helper
#pragma region Helper-LevelAccess
	iret			GetLevelAccessInternal(
		ImgBuf &imgBuf,
		const IRECT &rcBlkAccess) const;
	iret			GetLevelAccessInternalMMAP(
		ImgBuf &imgBuf,
		const IRECT &rcBlkAccess) const;
	iret			GetLevelAccessInternalGMAP(
		ImgBuf &imgBuf,
		const IRECT &rcBlkAccess) const;
#pragma endregion Helper-LevelAccess
	iret			GetLevelBlocksDataStatus_Unsafe(
		ImgLevel &lvlBase, const IRECT &rcBlkCur,
		vector<vector<IMGBLOCK_DATASTATUS>> &vec2BlkStatus) const;
	iret			GetLevelSuitedImg(
		const ImgBuf &imgSrc,
		ImgBuf &imgBuf, bool bAbortIfSame = false) const;
	iret			GetLevelSuitedImg(
		ImgLevel &lvlBase, const IRECT &rcBlkCur,
		ImgBuf &imgBuf, vector<vector<IMGBLOCK_DATASTATUS>> &vec2BlkStatus,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE) const;
	iret			GetLevelSuitedImgGMAP(
		ImgLevel &lvlBase, const IRECT &rcBlkCur,
		ImgBuf &imgBuf, vector<vector<IMGBLOCK_DATASTATUS>> &vec2BlkStatus,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE) const;
	iret			GetLevelSuitedImg_FlatGMAP(
		ImgLevel &lvlBase, const IRECT &rcBlkCur,
		ImgBuf &imgBuf, vector<vector<IMGBLOCK_DATASTATUS>> &vec2BlkStatus,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE) const;
	iret			GetLevelSuitedImg_AlignedGMAP(
		ImgLevel &lvlBase, const IRECT &rcBlkCur,
		ImgBuf &imgBuf, vector<vector<IMGBLOCK_DATASTATUS>> &vec2BlkStatus,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE) const;
	iret			LockBlocks(const IRECT &rcBlk, LOCK_MODE lockMode,
		vector<vector<scope_guard>> &vec2ScgLock, scope_guard &scgBlkStatusRecover,
		ms_t1 msTimeoutBlk = LOCK_TIME_INFINITE); // TODO Temp
	string			GetLevelName();
#pragma endregion Helper
	
#pragma region Setup
	// Setup Data structure
	iret			SetupDataStructure(iDim wLvl, iDim hLvl, IMGDISP_PIXELFORMAT format);
	// Setup Blocker
	iret			SetupBlocker();
	iret			SetupBlocker(const ImgLevel &lvlBase);
	// Setup blocks
	iret			SetupBlocks();
	// Setup structure
	iret			SetupStructure(
		idxlvl idxLvl, 
		iDim wLvl, iDim hLvl, IMGDISP_PIXELFORMAT format);
	iret			SetupStructure(
		const ImgLevel &lvlBase);
	// Setup all data
	iret			SetupData(const ImgBuf &imgSrc = ImgBuf());
	iret			SetupData(ImgLevel &lvlBase);
#pragma endregion Setup

#pragma region Internal
	// Setup level
	iret			SetupInternal(
		idxlvl idxLvl,
		iDim wLvl, iDim hLvl, IMGDISP_PIXELFORMAT format,
		const ImgBuf &imgSrc = ImgBuf());
	iret			SetupInternal(
		ImgLevel &lvlBase);
	iret			ClearInternal();
#pragma endregion Internal
	
#pragma region Set Blocks Data
	// Set data of specific blocks
	iret			SetBlocksDataInternal(
		const ImgBuf &imgBuf, const IRECT &rcBlkSet,
		IMG_UPDATE_TYPE updateType = IMG_UPDATE_TYPE::IUT_UPDATE,
		const vector<vector<IMGBLOCK_DATASTATUS>> *vec2BlkStatus = nullptr,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE);
	iret			SetBlocksDataGMAP(
		const ImgBuf &imgBuf,
		const IRECT &rcBlkSet, IRECT &rcSetActual,
		IMG_UPDATE_TYPE updateType = IMG_UPDATE_TYPE::IUT_UPDATE,
		const vector<vector<IMGBLOCK_DATASTATUS>> *vec2BlkStatus = nullptr,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE);
#pragma endregion Set Blocks Data
	
#pragma region Load/Unload/Update
	// InitLoad
	iret			InitLoadBlocksInternal(
		const ImgBuf &imgBuf,
		const IRECT &rcBlkLoad,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE);

	iret			ExtractInitLoadRegionRowInternal(
		IRECT &rcBlkLoad,
		scope_guard &scgRecoverFlag, bool &bRemain) const;
	iret			ExtractInitLoadRegionRowInternal(
		const IRECT &rcROI,
		IRECT &rcBlkLoad,
		scope_guard &scgRecoverFlag, bool &bRemain) const;

	// UpdateSampling
	iret			UpdateSamplingInternal(
		const ImgBuf &imgBuf,
		const IRECT &rcBlkUpdate,
		const vector<vector<IMGBLOCK_DATASTATUS>> *vec2BlkStatus = nullptr,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE);

	iret			ExtractUpdateSamplingRegionRow(
		IRECT &rcBlkUpdate,
		scope_guard &scgRecoverFlag, bool &bRemain) const;
	iret			UpdateSamplingTaskGMAP(
		ImgLevel &lvlBase, const IRECT &rcBlkUpdate,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE);
	iret			UpdateSamplingMergedInternal(
		ImgLevel &lvlBase, vector<IRECT> &vecRCUpdate, bool &bRemain,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE);
	iret			UpdateSamplingMergedInternalGMAP(
		ImgLevel &lvlBase, vector<IRECT> &vecRCUpdate, bool &bRemain,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE);
#pragma endregion Load/Unload/Update

	void			PostUpdate(IMGLEVEL_STATUS status = IMGLEVEL_STATUS::LLS_UNLOAD);

protected:
	LFCTYPE void	ClearPreAssign() LFCOVERRIDE;
	LFCTYPE void	ClearMove() LFCOVERRIDE;
	void			Release();
private:
	// Disable copy-ctor, = operator
	ImgLevel(ImgLevel &lvl);
	ImgLevel&		operator = (ImgLevel &lvl);
public:
	ImgLevel();
	ImgLevel(ImgLevel &&lvl);
	~ImgLevel();
	
	iret			AssignMove(ImgLevel &lvl) LOCKCONTROLED;
	ImgLevel&		operator = (ImgLevel &&lvl);

	virtual iret	Clear() OVERRIDE LOCKCONTROLED;

#pragma region Status
	inline bool		IsBuilt() const
	{
		return _status != IMGLEVEL_STATUS::LLS_EMPTY;
	}
	inline bool		IsFullLoaded() const
	{
		return _status == IMGLEVEL_STATUS::LLS_LOADED;
	}
#pragma endregion Status
	
#pragma region Get Info
	inline const BLOCKERBASE&	GetBlockerConst(scope_guard &scgBlocker) const LOCKCONTROLED;
#pragma endregion Get Info

#pragma region Settings
	inline iDim		GetWidth() const LOCKCONTROLED;
	inline iDim		GetHeight() const LOCKCONTROLED;
	iDim			GetBlockSize() const;
	iret			SetBlockSize(iDim szBlk) LOCKCONTROLED;
	inline idxblk	GetNBlockX() const LOCKCONTROLED;
	inline idxblk	GetNBlockY() const LOCKCONTROLED;
	inline IMGDISP_PIXELFORMAT	GetPixelFormat() const LOCKCONTROLED;
	inline const matblk* GetBlocksRefConst(scope_guard &scgLock) const LOCKCONTROLED;

	bool			ClearRenderStatus() const LOCKCONTROLED;
	iret			SetTempFileDir(const string &tmpFileDir) LOCKCONTROLED;
	iret			SetStoreMode(IMGDATA_STORAGE modeStore) LOCKCONTROLED;
	iret			SetBlocksAlignMode(IMGDISP_BLOCKSALIGNMODE modeAlign) LOCKCONTROLED;
	iret			SetSettings(iDim szBlk, IMGDATA_STORAGE modeStore, 
		IMGDISP_BLOCKSALIGNMODE modeAlign, const string &tmpFileDir = "");
#pragma endregion Settings

#pragma region Setup
	iret			Setup(
		idxlvl idxLvl,
		IMGDISP_PIXELFORMAT format, iDim wLvl, iDim hLvl,
		const ImgBuf &imgSrc = ImgBuf()) LOCKCONTROLED;
	iret			Setup(
		IMGDATA_STORAGE modeStore,
		idxlvl idxLvl, 
		IMGDISP_PIXELFORMAT format, iDim wLvl, iDim hLvl,
		const ImgBuf &imgSrc = ImgBuf()) LOCKCONTROLED;
	iret			Setup(
		ImgLevel &lvlBase, iDim &wLvl, iDim &hLvl) LOCKCONTROLED;
#pragma endregion Setup

#pragma region Load/Unload/Update
	iret			SetUpdateFlag(const IRECT &rcBlkUpdate, bool bUpdate) const LOCKCONTROLED;
	iret			SetUpdateFlag(const ImgLevel &lvlBase, const IRECT &rcBlkUpdate, bool bUpdate) const LOCKCONTROLED;
	iret			SetInitLoadFlag() const LOCKCONTROLED;
	
	iret			ExtractInitLoadRegionRow(
		IRECT &rcBlkLoad,
		scope_guard &scgFlagRecover, bool &bRemain,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE) const LOCKCONTROLED;
	iret			InitLoadBlock(
		const ImgBuf &imgBuf,
		const IPOINT &ptBlkLoad,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE) LOCKCONTROLED;
	iret			InitLoadBlocks(
		const ImgBuf &imgBuf,
		const IRECT &rcBlkLoad,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE) LOCKCONTROLED;

	iret			UpdateSamplingMerged(
		ImgLevel &lvlBase, vector<IRECT> &vecRCUpdate, bool &bRemain,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE) LOCKCONTROLED;// Automatic
#pragma endregion Load/Unload/Update
	
#pragma region Render
	// Realtime reder

	// ImgLevel.Render:
	//  pBuf: pointer of buffer (start address of buffer)
	//  wBuf, hBuf: width, height of buffer
	//  stride: stride of buffer
	//  wTarget, hTarget: width, height of target image. (origin image is zoomed to this size)
	//  xImg, yImg, wImg, hImg: rect of target image to be rendered
	iret			Render(
		void* pBuf, iDim wBuf, iDim hBuf, iDim strideBuf,
		iDim xTran, iDim yTran,
		iDim wTarget, iDim hTarget) const LOCKCONTROLED;
	iret			Render0(
		void* pBuf, iDim wBuf, iDim hBuf, iDim strideBuf,
		iDim xTran, iDim yTran,
		iDim wTarget, iDim hTarget) const LOCKCONTROLED;
	iret			RenderIllustration(
		void *pBuf, iDim wBuf, iDim hBuf, iDim strideBuf,
		const IVEC2 &sizetarget, const RECTXZ &rcTarget,
		bool bBlocks = true, bool bClipRegion = true,
		IMGDISP_ILLUSMODE modeIllus = IMGDISP_ILLUSMODE::ILLUS_RENDER) const LOCKCONTROLED;
#pragma endregion Render

#pragma region Obsolete
#ifdef USE_IMGLEVEL_OBSOLETE
	iret			UpdateSampling(
		ImgLevel &lvlBase, const IRECT &rcBlkIdx, IRECT &rcBlkIdxUpdate,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE) LOCKCONTROLED;
#endif
#pragma endregion Obsolete
};

#pragma endregion ImgLevel


#pragma region ImgDisp

/************************
 ImgDisp
*************************/
#define IMGDISP_LOCK_INTERNAL				scope_guard scgLockInternal;\
											_lock.LockGuard(scgLockInternal);
#define IMGDISP_LOCKSCG_INTERNAL(SCG)		_lock.LockGuard(SCG);
#define IMGDISP_LOCKSCGT_INTERNAL(SCG, T)	_lock.LockGuard(SCG, T);
#define IMGDISP_TRYLOCK_INTERNAL(RET)		scope_guard scgLockInternal;\
											(RET) = _lock.TryLockGuard(scgLockInternal);
#define IMGDISP_UNLOCK_INTERNAL				scgLockInternal.Release();

#define IMGDISP_LOCKWRITE_INTERNAL			scope_guard scgLockWriteInternal;\
											_lock.LockWriteGuard(scgLockWriteInternal);
#define IMGDISP_UNLOCKWRITE_INTERNAL		scgLockWriteInternal.Release();

#define IMGDISP_TRYLOCKIREAD_INTERNAL(RET)	scope_guard scgLockIReadInternal;\
											(RET) = _lock.TryLockIReadGuard(scgLockIReadInternal);
#define IMGDISP_LOCKIREAD_INTERNAL			scope_guard scgLockIReadInternal;\
											_lock.LockIReadGuard(scgLockIReadInternal);
#define IMGDISP_UNLOCKIREAD_INTERNAL		scgLockIReadInternal.Release();

#define IMGDISP_LOCKREAD_INTERNAL			scope_guard scgLockReadInternal;\
											_lock.LockReadGuard(scgLockReadInternal);

#define IMGDISP_LOCKREADT_INTERNAL(T, RET)	scope_guard scgLockReadInternal;\
											RET = _lock.LockReadGuard(scgLockReadInternal, T);

#define IMGDISP_LOCKOTHER_INTERNAL(OTHER)	scope_guard scgLockOtherInternal;\
											(OTHER)._lock.LockGuard(scgLockOtherInternal);
#define IMGDISP_UNLOCKOTHER_INTERNAL		scgLockOtherInternal.Release();

#define IMGDISP_BLOCKSIZEMAX_DEF			4096
#define IMGDISP_BLOCKSIZE_DEF				1024
#define IMGDISP_LEVELSIZEMIN_DEF			256

//template class DLLEXPORT vector<ImgLevel>;

class DLLEXPORT ImgDisp : protected IImgSpec<iDimB>, protected IImgBuffer
{
public:
	// Core type
	typedef iDimB					iDim;

	// Aux type
	typedef	RECTX<iDim>				IRECT;
	typedef	POINTX<iDim>			IPOINT, IVEC2;
	
	// Blocker type
	typedef	Blocker<iDim>			BLOCKERBASE;
	typedef	Blocker_C1<iDim>		BLOCKER;
	typedef	BLOCKER::idxblk			idxblk;

	// Level type
	typedef	ImgLevel::idxlvl		idxlvl;

	// Loader type
	typedef ImgLoader<iDim>			IMGLOADER;

protected:
	// Misc type
	typedef	ImgRegion<iDim>			IMGREGION;
	typedef	BiSwap<ImgRegion<iDim>>	rg_swapper;
private:
	// Aux type
	typedef ImgBuf<iDim>			ImgBuf;

public:
	static bool __bPrepared;

	static bool	Prepare();

protected:
	// Lock
	mutable icrwb_lock	_lock;

	// Status
	IMGDISP_STATUS		_status;

	// Image loader
	IMGLOADER			_loader;

	// Levels
	ImgLevel			_level0;
	vector<ImgLevel>	_levels;

	// Worker thread
	Event				_evtROIChange;
	Event				_evtInitLoad;
	Event				_evtUpdateSample;
	ThreadStoppable		_threadInitLoad;
	ThreadStoppable		_threadUpdateSample;
	ThreadPoolStoppable	_poolInitLoad;
	ThreadPoolStoppable	_poolUpdateSample;
	ThreadPoolStoppable	_poolReleaseMemory;

	// ROI Region Swapper
	mutable rg_swapper	_rgROI;

	// Settings
	IMGDATA_STORAGE			_store;
	IMGDISP_VSAMPLEMODE		_lvlsSample;
	iDim					_sizeBlock;
	COLOR4B					_colorBufferBkg;
	COLOR4B					_colorBufferIllus;
	string					_tmpFileDir;

	iDim					__maxBlockSize;
	iDim					__defBlockSize;
	iDim					__minLevelSize;
	ms_t1					__msTimeoutExtractInitLoadRegion;
	ms_t1					__msTimeoutUpdateSamplingTask;
	ms_t1					__msTimeoutInitLoadBlockRowTask;
	ms_t1					__msTimeoutOpenImage;

protected:
#pragma region Helper
	void			InitSettings();
	const ImgLevel*	GetRenderLevelConst(iDim wd, iDim hd) const;
	inline const BLOCKERBASE&	BaseBlockerConst(scope_guard &scgBlocker);
	inline iret		LockWithStopFlagSet(scope_guard &scgLock,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE);
#pragma endregion Helper

#pragma region Internal
	iret			ClearInternal();
#pragma endregion Internal
	
#pragma region Setup
	iret			SetupStructure(iDim width, iDim height, IMGDISP_PIXELFORMAT format);
	iret			SetupLevels(const ImgBuf &imgSrc = ImgBuf());
	
	void			PostUpdateSpec();
	void			PostUpdate(IMGDISP_STATUS status = IMGDISP_STATUS::ILS_UNLOAD);
	
	iret			SetupInternal(iDim width, iDim height, IMGDISP_PIXELFORMAT format,
		const ImgBuf &imgSrc = ImgBuf());
#pragma endregion Setup
	
#pragma region Load/Unload/Update
	// Load Image
	iret			LoadImageData(ImgBuf &imgBuf,
		const IRECT &rcBlkLoad, IRECT &rcLoad,
		bool *bInterrupt = nullptr);

	// Init Load
	iret			InitLoadPartInternal(IRECT rcSrc,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE);

	iret			ExtractInitLoadRegionRowInternal(IRECT &rcBlkLoad,
		scope_guard &scgRecoverFlag, bool &bRemain,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE) const;
	iret			InitLoadBlockInternal(const IPOINT &ptBlkLoad, bool *bInterrupt = nullptr,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE);
	iret			InitLoadBlocksInternal(const IRECT &rcBlkLoad, bool *bInterrupt = nullptr,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE);

	// Update Sampling
	iret			UpdateSamplingMergedInternal(bool &bRemainLevel, bool *bInterrupt = nullptr,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE);

	// Helper
	iret			PostBlocksUpdate(const IRECT &rcBlkUpdate);
	iret			SetUpdateFlag(const IRECT &rcBlkUpdate, bool bUpdate) const;
	iret			SetUpdateFlagRemaining(const IRECT &rcBlkUpdate, idxlvl lv) const;
#pragma endregion Load/Unload/Update

#pragma region Thread
	// Task
	void			InitLoadBlockRowTask(
		const IRECT &rcBlkInitLoad, bool bRemain, scope_guard_comp &scgcRecover,
		bool *bInterrupt,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE);
	void			UpdateSamplingBlockRowTask(bool *bInterrupt = nullptr,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE); // Automatic

	// InitLoad Thread
	void			ThreadInitLoad(bool *bInterrupt) LOCKCONTROLED;
	void			ThreadInitLoadBlock(bool *bInterrupt) LOCKCONTROLED;
	void			ThreadInitLoadBlockRow(bool *bInterrupt) LOCKCONTROLED;

	// UpdateSampling Thread
	void			ThreadUpdateSampling(bool *bInterrupt) LOCKCONTROLED;
	void			ThreadUpdateSamplingBlock(bool *bInterrupt) LOCKCONTROLED;
	void			ThreadUpdateSamplingBlockRow(bool *bInterrupt) LOCKCONTROLED;
	// Unload/Load Thread
	void			ThreadUnloadBlock(bool *bInterrupt) LOCKCONTROLED;
	void			ThreadCacheBlock(bool *bInterrupt) LOCKCONTROLED;
	// Helper
	void			WaitAllThreads();
	void			SetThreadsStopFlag();
#pragma endregion Thread

protected:
	LFCTYPE void	ClearPreAssign() LFCOVERRIDE;
	LFCTYPE void	ClearMove();
	void			Release();
private:
	// Disable copy-ctor, = operator
	ImgDisp(ImgDisp &disp);
	ImgDisp&		operator = (ImgDisp &disp);
public:
	ImgDisp();
	ImgDisp(ImgDisp &&disp);
	~ImgDisp();

	iret			AssignMove(ImgDisp &disp) LOCKCONTROLED;
	ImgDisp&		operator = (ImgDisp &&disp);

	iret			Clear(ms_t1 msTimeoutLock = LOCK_TIME_INFINITE) LOCKCONTROLED;

#pragma region Status
	inline bool		HasImage() const
	{
		return _status != IMGDISP_STATUS::ILS_EMPTY;
	}
	inline bool		IsBuilt() const
	{
		return _status != IMGDISP_STATUS::ILS_EMPTY;
	}
	inline bool		IsFullLoaded() const
	{
		return _status == IMGDISP_STATUS::ILS_LOADED;
	}
#pragma endregion Status

#pragma region Info/Settings
	inline iDim		GetWidth() LOCKCONTROLED;
	inline iDim		GetHeight() LOCKCONTROLED;
	inline idepth	GetBytesPerPixel() LOCKCONTROLED;

	inline void		SetColorBkg(COLOR4B color);
	inline void		SetColorIllus(COLOR4B color);
	inline iDim		GetBlockSize() const;
	iret			SetBlockSize(iDim size) LOCKCONTROLED;
	iret			SetStoreMode(IMGDATA_STORAGE modeStore) LOCKCONTROLED;
#pragma endregion Info/Settings

#pragma region Open Image
	iret			OpenImage(
		const string &file,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE);
	iret			OpenImage(
		const string &file,
		const RECTXB &rcInitLoad,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE) LOCKCONTROLED;
#pragma endregion Open Image

#pragma region Load/Unload/Update
	// InitLoad
	iret			ExtractInitLoadRegionRow(IRECT &rcBlkLoad,
		scope_guard &scgRecoverFlag, bool &bRemain,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE) const LOCKCONTROLED;
	// InitLoad
	iret			InitLoadBlock(const IPOINT &ptBlkLoad, bool *bInterrupt = nullptr,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE) LOCKCONTROLED;
	iret			InitLoadBlocks(const IRECT &rcBlkLoad, bool *bInterrupt = nullptr,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE) LOCKCONTROLED;

	// UpdateSampling
	iret			UpdateSamplingMerged(bool &bRemainLevel, bool *bInterrupt = nullptr,
		ms_t1 msTimeoutLock = LOCK_TIME_INFINITE) LOCKCONTROLED;
#pragma endregion Load/Unload/Update
	
#pragma region Render
	// Realtime reder
	iret			Render(
		void *pBuf, iDim wBuf, iDim hBuf, iDim strideBuf,
		iDim xTran, iDim yTran,
		iDim wTargetImg, iDim hTargetImg) const LOCKCONTROLED;
	iret			Render0(
		void *pBuf, iDim wBuf, iDim hBuf, iDim strideBuf,
		iDimZ xTarget, iDimZ yTarget,
		iDim wTargetImg, iDim hTargetImg, double zoom) const LOCKCONTROLED;
	iret			RenderIllustration(
		void *pBuf, iDim wBuf, iDim hBuf, iDim strideBuf,
		bool bBlocks = true, bool bClipRegion = true,
		IMGDISP_ILLUSMODE modeIllus = IMGDISP_ILLUSMODE::ILLUS_LOAD) const LOCKCONTROLED;
#pragma endregion Render

protected:
	iret			RenderEdgeIllustration(
		void *pBuf, iDim wBuf, iDim hBuf, iDim strideBuf,
		iDim xTran, iDim yTran,
		iDim wTargetImg, iDim hTargetImg) const LOCKCONTROLED;
	void			Test0();

#pragma region Obsolete
#ifdef USE_IMGDISP_OBSOLETE
	iret			InitLoadBlockRowTaskMerged(IRECT &rcBlkIdxLoad, bool *bInterrupt = nullptr) LOCKCONTROLED;

	iret			UpdateSamplingObsolete(const IRECT &rcBlkIdxUpdate, bool *bInterrupt = nullptr) LOCKCONTROLED;
#endif
#pragma endregion Obsolete
};

#pragma endregion ImgDisp

}

#undef _IMGDISP_SOURCE_FILE_IMGDISP_H
#define _IMGDISP_SOURCE_FILE_IMGDISP_CPP

#include "pch.h"

#include "ImgDisp.h"
#include <ppl.h>

namespace ImgDisplay
{

#pragma region ImgBlock

iret ImgBlock::ClearInternal()
{
	// status
	_sLoad			= IMGBLOCK_LOADSTATUS::BLS_EMPTY;
	_sData			= IMGBLOCK_DATASTATUS::BDS_EMPTY;

	// Render Status & flag
	_statusR		= IMGBLOCK_RENDER_STATUS::BRS_NORENDER;
	_bUpdated		= false;
	_bInitLoad		= false;

	// IImgDataBlock
	IImgDataBlock::Clear();
	// IBlock
	IBlock::Clear();

	return 1;
}


iret ImgBlock::SetupInternal(
	IMGDATA_STORAGE modeStore,
	idxblk iBlkX, idxblk iBlkY,
	IMGDISP_PIXELFORMAT format,
	iDim xBlkSrc, iDim yBlkSrc, iDim width, iDim height,
	void *pDataGMAP, iDim strideGMAP)
{
	// Clear
	if(IsBuilt())
	{
		ClearInternal();
	}

	IMGBLOCK_LOADSTATUS sLoadFrom = IMGBLOCK_LOADSTATUS::BLS_BUILDING;
	IMGBLOCK_LOADSTATUS sLoadTo = IMGBLOCK_LOADSTATUS::BLS_SYNC;
	switch(modeStore)
	{
	case IMGDATA_STORAGE::IDS_GMAP:
		sLoadTo = IMGBLOCK_LOADSTATUS::BLS_SYNC;
		break;
	case IMGDATA_STORAGE::IDS_MMAP:
		sLoadTo = IMGBLOCK_LOADSTATUS::BLS_READY;// TODO
		break;
	default:
		break;
	}

	//
	// Update status
	//
	_sLoad	= sLoadFrom;

	// Set store mode
	IImgDataBlock::SetStoreMode(modeStore);

	// Set Specification
	idepth depth = ImgBase::GetFormatDepth(format);
	RET_ON_NEG(
		SetSpecification(
			iBlkX, iBlkY, xBlkSrc, yBlkSrc,
			width, height, depth, strideGMAP));

	// Set data ptr TODO
	void *pDataBlock = nullptr;
	switch(IImgDataBlock::_store)
	{
	case IMGDATA_STORAGE::IDS_GMAP:
		pDataBlock = (byte*)pDataGMAP + _offset;
		break;
	case IMGDATA_STORAGE::IDS_MMAP:
		break;
	default:
		break;
	}

	// IImgDataBlock
	RET_ON_NEG(
		IImgDataBlock::Setup(width, height, format, "ImgBlock???", pDataBlock, strideGMAP));

	//
	// Update status
	//
	_sLoad	= sLoadTo;

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgBlock::SetSpecification(
	idxblk ix, idxblk iy,
	iDim xSrcPos, iDim ySrcPos,
	iDim width, iDim height, idepth depth, iDim stride)
{
	RET_ON_NEG(
		IBlock::SetBlock(ix, iy, xSrcPos, ySrcPos, width, height, depth, stride));

	PostUpdateSpec();

	return IMGSYS_RET::ISR_SUCCEED;
}

void ImgBlock::PostUpdateSpec()
{
}

ImgBlock::ImgBlock():
	IBlock(),
	IImgDataBlock(),
	_lock			(),
	_sLoad			(IMGBLOCK_LOADSTATUS::BLS_EMPTY),
	_sData			(IMGBLOCK_DATASTATUS::BDS_EMPTY),
	_statusR		(IMGBLOCK_RENDER_STATUS::BRS_NORENDER),
	_bUpdated		(false),
	_bInitLoad		(false)
{
}

ImgBlock::ImgBlock(ImgBlock &&other):
	IBlock(),
	IImgDataBlock(),
	_lock			(),
	_sLoad			(IMGBLOCK_LOADSTATUS::BLS_EMPTY),
	_sData			(IMGBLOCK_DATASTATUS::BDS_EMPTY),
	_statusR		(IMGBLOCK_RENDER_STATUS::BRS_NORENDER),
	_bUpdated		(false),
	_bInitLoad		(false)
{
	// Assign
	AssignMove(other);
}

ImgBlock& ImgBlock::operator = (ImgBlock &&other)
{
	// Assign
	AssignMove(other);

	return *this;
}

iret ImgBlock::AssignMove(ImgBlock &other)
{
	// ======>> LOCK OTHER <<=======
	IMGBLOCK_LOCKOTHER_INTERNAL(other);
	// ======>> LOCK <<=======
	IMGBLOCK_LOCK_INTERNAL;

	// Clear before assignment
	ImgBlock::ClearPreAssign();
	// pre assignment
	other.ImgBlock::PreAssign();

	// Assign
	// [IImgDataBlock]
	IImgDataBlock::AssignMove(other);
	// [IBlock]
	IBlock::AssignMove(other);
	// Assign [Status] last
	_statusR		= other._statusR;
	_bUpdated		= std::forward<atom<bool>>(other._bUpdated);
	_bInitLoad		= std::forward<atom<bool>>(other._bInitLoad);
	_sData			= other._sData;
	_sLoad			= other._sLoad;
	
	// ======>> UNLOCK <<=======
	IMGBLOCK_UNLOCK_INTERNAL;

	// Clear after move
	other.ImgBlock::ClearMove();

	// ======>> UNLOCK OTHER <<=======
	IMGBLOCK_UNLOCKOTHER_INTERNAL;

	return IMGSYS_RET::ISR_SUCCEED;
}

ImgBlock::~ImgBlock()
{
	// ======>> LOCK <<=======
	IMGBLOCK_LOCK_INTERNAL;

	Release();
}

void ImgBlock::PreAssign()
{
	//
	// Update status
	//
	_sLoad			= IMGBLOCK_LOADSTATUS::BLS_DYING;
	_sData			= IMGBLOCK_DATASTATUS::BDS_EMPTY;
}

void ImgBlock::ClearPreAssign()
{
	//
	// Update status
	//
	_sLoad			= IMGBLOCK_LOADSTATUS::BLS_BUILDING;
	_sData			= IMGBLOCK_DATASTATUS::BDS_EMPTY;
	
	// [Flag]
	_statusR		= IMGBLOCK_RENDER_STATUS::BRS_NORENDER;
	//_bUpdated		= false;// do not clear _bUpdate
	//_bInitLoad	= false;// do not clear _bInitLoad
}

void ImgBlock::ClearMove()
{
	// [Flag]
	_statusR		= IMGBLOCK_RENDER_STATUS::BRS_NORENDER;
	_bUpdated		= false;
	_bInitLoad		= false;

	// [IImgDataBlock]
	//IImgDataBlock
	// [IBlock]
	//IBlock

	//
	// Update status last
	//
	_sData			= IMGBLOCK_DATASTATUS::BDS_EMPTY;
	_sLoad			= IMGBLOCK_LOADSTATUS::BLS_EMPTY;
}

void ImgBlock::Release()
{
	ImgBlock::ClearInternal();
}

iret ImgBlock::Clear()
{
	// ======>> LOCK <<=======
	IMGBLOCK_LOCK_INTERNAL;

	return ClearInternal();
}

bool ImgBlock::IsInitLoadDataStatus_Unsafe() const
{
	return _sLoad == IMGBLOCK_LOADSTATUS::BLS_SYNC 
		/*&& _sData != IMGBLOCK_DATASTATUS::BDS_FULL*/;
}

bool ImgBlock::IsUpdateDataStatus_Unsafe() const
{
	return _sLoad == IMGBLOCK_LOADSTATUS::BLS_SYNC;
}

bool ImgBlock::IsLoadStatus_Unsafe() const
{
	return _sLoad == IMGBLOCK_LOADSTATUS::BLS_OFFLINE;
}

bool ImgBlock::IsUnLoadStatus_Unsafe() const
{
	return _sLoad == IMGBLOCK_LOADSTATUS::BLS_SYNC;
}

IMGBLOCK_LOADSTATUS ImgBlock::GetStatus_Unsafe() const
{
	return _sLoad;
}

IMGBLOCK_RENDER_STATUS ImgBlock::GetRenderStatus() const
{
	return _statusR;
}

iret ImgBlock::SetStatusAvailable_Unsafe(bool bFull)
{
	// Validate status
	if(!IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	// Set status
	if(IMGBLOCK_DATASTATUS::BDS_FULL != _sData)
	{
		_sData = bFull ? IMGBLOCK_DATASTATUS::BDS_FULL : IMGBLOCK_DATASTATUS::BDS_PART;
	}

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgBlock::SetStoreMode(
	IMGDATA_STORAGE modeStore)
{
	// ======>> LOCK <<=======
	int retLock = -1;
	IMGBLOCK_TRYLOCK_INTERNAL(retLock);
	if(retLock <= 0)
	{
		return IMGSYS_RET::ISR_LOCKFAIL;
	}

	// Validate status
	if(IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	return IImgDataBlock::SetStoreMode(modeStore);
}

iret ImgBlock::SetUpdateFlag(bool bUpdate) const
{
	_bUpdated.set(bUpdate);

	return IMGSYS_RET::ISR_SUCCEED;
}

bool ImgBlock::IsUpdateFlagSet() const
{
	return _bUpdated.get();
}

bool ImgBlock::CheckResetUpdateFlag() const
{
	return _bUpdated.checkandflip(true);
}

iret ImgBlock::SetInitLoadFlag(bool bInitLoad) const
{
	_bInitLoad.set(bInitLoad);

	return IMGSYS_RET::ISR_SUCCEED;
}

bool ImgBlock::IsInitLoadFlagSet() const
{
	return _bInitLoad.get();
}

bool ImgBlock::CheckResetInitLoadFlag() const
{
	return _bInitLoad.checkandflip(true);
}

iret ImgBlock::Setup(
	idxblk iBlkX, idxblk iBlkY,
	IMGDISP_PIXELFORMAT format,
	iDim xBlkSrc, iDim yBlkSrc, iDim width, iDim height,
	void *pData, iDim strideSrc)
{
	// ======>> LOCK <<=======
	IMGBLOCK_LOCK_INTERNAL;

	return SetupInternal(
		IImgDataBlock::_store,
		iBlkX, iBlkY,
		format,
		xBlkSrc, yBlkSrc, width, height,
		pData, strideSrc);
}

iret ImgBlock::Setup(
	IMGDATA_STORAGE modeStore,
	idxblk iBlkX, idxblk iBlkY,
	IMGDISP_PIXELFORMAT format,
	iDim xBlkSrc, iDim yBlkSrc, iDim width, iDim height,
	void *pData, iDim strideSrc)
{
	// ======>> LOCK <<=======
	IMGBLOCK_LOCK_INTERNAL;

	return SetupInternal(
		modeStore,
		iBlkX, iBlkY,
		format,
		xBlkSrc, yBlkSrc, width, height,
		pData, strideSrc);
}

iret ImgBlock::LockIRead(
	scope_guard &scgLockIRead, ms_t1 msTimeout) const
{
	return _lock.LockIReadGuard(scgLockIRead, msTimeout) > 0 ? IMGSYS_RET::ISR_SUCCEED : -1;
}

iret ImgBlock::LockWrite(
	scope_guard &scgLockWrite, ms_t1 msTimeout) const
{
	return _lock.LockWriteGuard(scgLockWrite, msTimeout) > 0 ? IMGSYS_RET::ISR_SUCCEED : -1;
}

iret ImgBlock::LockBlock(
	scope_guard &scgLockBlock, ms_t1 msTimeout) const
{
	return _lock.LockGuard(scgLockBlock, msTimeout) > 0 ? IMGSYS_RET::ISR_SUCCEED : -1;
}

iret ImgBlock::Render(
	void* pBufDest, iDim wBufDest, iDim hBufDest, iDim strideBuf,
	iDim xDest, iDim yDest, iDim x2Dest, iDim y2Dest,
	int interpolation) const
{
	// [Lock Read]
	//Ticker ticker;
	//ticker.Start();
	int retLock = -1;
	IMGBLOCK_TRYLOCKIREAD_INTERNAL(retLock);
	//Logger::Log0(to_string(ticker.Tick()));
	if(retLock <= 0)
	{
		xDest	= max(xDest, 0);
		yDest	= max(yDest, 0);
		x2Dest	= min(x2Dest, wBufDest);
		y2Dest	= min(y2Dest, hBufDest);
		IRECT rcDest(xDest, yDest, x2Dest - 1, y2Dest - 1);
		ImgProcess::Fill_XRGB(
			pBufDest, wBufDest, hBufDest, strideBuf,
			rcDest, RGB_LE(180, 180, 160));
		return IMGSYS_RET::ISR_LOCKFAIL;
	}

	// Validate status
	if (!IsInconsistentDataAvailable())
	{
		xDest	= max(xDest, 0);
		yDest	= max(yDest, 0);
		x2Dest	= min(x2Dest, wBufDest);
		y2Dest	= min(y2Dest, hBufDest);
		IRECT rcDest(xDest, yDest, x2Dest - 1, y2Dest - 1);
		ImgProcess::Fill_XRGB(
			pBufDest, wBufDest, hBufDest, strideBuf,
			rcDest, RGB_LE(88, 44, 22));
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	// Render
	return
		ImgProcess::RenderClip_XRGB(
			ImgBuf::pImg, ImgBuf::_width, ImgBuf::_height, ImgBuf::_stride,
			pBufDest, wBufDest, hBufDest, strideBuf,
			xDest, yDest, x2Dest, y2Dest,
			interpolation);
}

#pragma endregion ImgBlock


#pragma region ImgLevel

iret ImgLevel::GetLevelSuitedImg(
	const ImgBuf &imgSrc,
	ImgBuf &imgBuf, bool bAbortIfSame) const
{
	// Clear out image buffer first
	imgBuf.Clear();

	// Validate status
	if(!IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	// Validate basic
	if(!imgSrc.HasData())
	{
		return IMGSYS_RET::ISR_NULLIMG;
	}

	// Scale img
	iDim wImgSrc = imgSrc.GetWidth();
	iDim hImgSrc = imgSrc.GetHeight();
	if(_width != wImgSrc || _height != hImgSrc)
	{
		RETVAL_ON_NEG_AND(
			imgBuf.ScaleFrom(imgSrc, _width, _height),
			IMGSYS_RET::ISR_FAIL,
			Logger::Log0("ImgLevel::GetLevelSuitedImg: Scale image failed"););
	}
	else
	{
		if(bAbortIfSame)
		{
			return IMGSYS_RET::ISR_NOOPERATION;
		}

		RET_ON_NEG(
			imgSrc.Clone(imgBuf));
	}

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::GetLevelAccessInternal(
	ImgBuf &imgBuf,
	const IRECT &rcBlkAccess) const
{
	switch (_store)
	{
	case ImgDisplay::IDS_GMAP:
		return GetLevelAccessInternalGMAP(imgBuf, rcBlkAccess);
		break;
	case ImgDisplay::IDS_MMAP:
		return GetLevelAccessInternalMMAP(imgBuf, rcBlkAccess);
		break;
	default:
		return IMGSYS_RET::ISR_UNKNOWNOP;
		break;
	}

	return IMGSYS_RET::ISR_UNKNOWNOP;
}

iret ImgLevel::GetLevelAccessInternalMMAP(
	ImgBuf &imgBuf,
	const IRECT &rcBlkAccess) const
{
	return IMGSYS_RET::ISR_UNKNOWNOP;
}

iret ImgLevel::GetLevelAccessInternalGMAP(
	ImgBuf &imgBuf,
	const IRECT &rcBlkAccess) const
{
	const string logH = "ImgLevel::GetLevelAccessInternalGMAP: ";

	// Clear out image buffer first
	imgBuf.Clear();

	// Validate status
	if(!IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	RET_ON_NEG(
		imgBuf.AccessFrom(*this, rcBlkAccess));

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::GetLevelBlocksDataStatus_Unsafe(
	ImgLevel &lvlBase, const IRECT &rcBlkCur,
	vector<vector<IMGBLOCK_DATASTATUS>> &vec2BlkStatus) const
{
	// Clear out first
	vec2BlkStatus.clear();

	// Validate Status
	if(!lvlBase.IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}
	// Validate basic
	if(rcBlkCur.IsInvalid_Out(_blocker.GetNBlockX(), _blocker.GetNBlockY()))
	{
		return IMGSYS_RET::ISR_INVBLKRANGE;
	}

	// Get base/current blocker
	const BLOCKERBASE &blockerCur = _blocker;
	const BLOCKERBASE &blockerBase = lvlBase._blocker;

	// Get blocks data status
	vec2BlkStatus.resize(rcBlkCur.Height(), vector<IMGBLOCK_DATASTATUS>(rcBlkCur.Width()));
	for(idxblk y = rcBlkCur.top; y <= rcBlkCur.bottom; ++y)
	{
		for(idxblk x = rcBlkCur.left; x <= rcBlkCur.right; ++x)
		{
			// Get base level full block index
			IRECT rcBlkBase0;
			RET_ON_NEG(
				blockerCur.GetAlignedBlocks(blockerBase, IRECT::FromXYWH(x, y, 1, 1), rcBlkBase0));

			IMGBLOCK_DATASTATUS dataStatus = IMGBLOCK_DATASTATUS::BDS_EMPTY;
			bool bNotFull = false;
			bool bNotEmpty = false;
			for(idxblk y0 = rcBlkBase0.top; y0 <= rcBlkBase0.bottom; ++y0)
			{
				for(idxblk x0 = rcBlkBase0.left; x0 <= rcBlkBase0.right; ++x0)
				{
					IMGBLOCK_DATASTATUS dataStatus0 = lvlBase._blocks[y0][x0].GetDataStatus_Unsafe();
					if(IMGBLOCK_DATASTATUS::BDS_EMPTY != dataStatus0)
					{
						bNotEmpty = true;
					}
					if(IMGBLOCK_DATASTATUS::BDS_FULL != dataStatus0)
					{
						bNotFull = true;
					}
				}
			}

			if(!bNotFull)
			{
				dataStatus = IMGBLOCK_DATASTATUS::BDS_FULL;
			}
			else if(!bNotEmpty)
			{
				dataStatus = IMGBLOCK_DATASTATUS::BDS_EMPTY;
			}
			else if(bNotFull || bNotEmpty)
			{
				dataStatus = IMGBLOCK_DATASTATUS::BDS_PART;
			}
			vec2BlkStatus[y - rcBlkCur.top][x - rcBlkCur.left] = dataStatus;
		}
	}

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::GetLevelSuitedImg(
	ImgLevel &lvlBase, const IRECT &rcBlkCur,
	ImgBuf &imgBuf, vector<vector<IMGBLOCK_DATASTATUS>> &vec2BlkStatus,
	ms_t1 msTimeoutLock) const
{
	switch(_store)
	{
	case IMGDATA_STORAGE::IDS_MMAP:
		return IMGSYS_RET::ISR_UNKNOWNOP;
		break;
	case IMGDATA_STORAGE::IDS_GMAP:
		return GetLevelSuitedImgGMAP(lvlBase, rcBlkCur,
			imgBuf, vec2BlkStatus, msTimeoutLock);
		break;
	default:
		return IMGSYS_RET::ISR_UNKNOWNOP;
		break;
	}

	return IMGSYS_RET::ISR_UNKNOWNOP;
}

iret ImgLevel::GetLevelSuitedImgGMAP(
	ImgLevel &lvlBase, const IRECT &rcBlkCur,
	ImgBuf &imgBuf, vector<vector<IMGBLOCK_DATASTATUS>> &vec2BlkStatus,
	ms_t1 msTimeoutLock) const
{
	switch (_blocksAlign)
	{
	case IMGDISP_BLOCKSALIGNMODE::DSBAM_NONE:
		return GetLevelSuitedImg_FlatGMAP(lvlBase, rcBlkCur, imgBuf, vec2BlkStatus, msTimeoutLock);
		break;
	case IMGDISP_BLOCKSALIGNMODE::DSBAM_ALIGNED:
		return GetLevelSuitedImg_AlignedGMAP(lvlBase, rcBlkCur, imgBuf, vec2BlkStatus, msTimeoutLock);
		break;
	default:
		return IMGSYS_RET::ISR_UNKNOWNOP;
		break;
	}
	
	return IMGSYS_RET::ISR_UNKNOWNOP;
}

iret ImgLevel::GetLevelSuitedImg_FlatGMAP(
	ImgLevel &lvlBase, const IRECT &rcBlkCur,
	ImgBuf &imgBuf, vector<vector<IMGBLOCK_DATASTATUS>> &vec2BlkStatus,
	ms_t1 msTimeoutLock) const
{
	const string logH = "ImgLevel::GetLevelSuitedImg: ";

	// Clear out image buffer first
	imgBuf.Clear();
	// Clear out vec2 first
	vec2BlkStatus.clear();

	if(&lvlBase == this)
	{
		return IMGSYS_RET::ISR_INVARGS;
	}
	// Validate status
	if(!lvlBase.IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}
	// Validate status
	if(!IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	// Get base/current blocker
	const BLOCKERBASE &blockerBase = lvlBase._blocker;
	const BLOCKERBASE &blockerCur = _blocker;

	// Log string
	const string logErrGetBaseBlkIdx = "Fail to get block index range of base level#" + to_string(lvlBase._level);
	const string logErrGetCurBlk = "Fail to get block range of current level#" + to_string(_level);
	const string logErrGetBaseBlk = "Fail to get block range of base level#" + to_string(lvlBase._level);

	// Get base level full block index
	IRECT rcBlkBase;
	RET_ON_NEG_AND(
		blockerCur.GetAlignedBlocks(blockerBase, rcBlkCur, rcBlkBase),
		Logger::Log0(logH, logErrGetBaseBlkIdx););

	// Get Dest/current & Src/base range
	IRECT rcCur;
	RET_ON_NEG_AND(
		blockerCur.GetBlockEdge(rcBlkCur, rcCur),
		Logger::Log0(logH, logErrGetCurBlk););
	IRECT rcBase;
	RET_ON_NEG_AND(
		blockerBase.GetBlockEdge(rcBlkBase, rcBase),
		Logger::Log0(logH, logErrGetBaseBlk););

	// Get Base level image access buffer
	ImgBuf imgBufSrc;
	RET_ON_NEG(
		lvlBase.GetLevelAccessInternalGMAP(imgBufSrc, rcBase));

	// Scale image
	RET_ON_NEG(
		imgBuf.ScaleFrom(imgBufSrc, rcCur.Width(), rcCur.Height()));

	// Get blocks status
	RET_ON_NEG(
		GetLevelBlocksDataStatus_Unsafe(lvlBase, rcBlkCur, vec2BlkStatus));

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::GetLevelSuitedImg_AlignedGMAP(
	ImgLevel &lvlBase, const IRECT &rcBlkCur,
	ImgBuf &imgBuf, vector<vector<IMGBLOCK_DATASTATUS>> &vec2BlkStatus,
	ms_t1 msTimeoutLock) const
{
	const string logH = "ImgLevel::GetLevelSuitedImg_AlignedGMAP: ";

	// Clear out image buffer first
	imgBuf.Clear();
	// Clear out vec2 first
	vec2BlkStatus.clear();

	if(&lvlBase == this)
	{
		return IMGSYS_RET::ISR_INVARGS;
	}
	// Validate status
	if(!lvlBase.IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}
	// Validate status
	if(!IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	// Get base/current blocker
	const BLOCKERBASE &blockerBase = lvlBase._blocker;
	const BLOCKERBASE &blockerCur = _blocker;

	// Log string
	const string logErrGetBaseBlk = "Fail to get block range of base level#" + to_string(lvlBase._level);
	const string logErrGetCurBlk = "Fail to get block range of current level#" + to_string(_level);
	const string logErrGetRegionSplit = "Fail to get stable region split";
	const string logErrGetScaleBaseBlkIdx = "Fail to get scale block index range of base level#" + to_string(lvlBase._level);
	const string logErrGetScaleCurBlk = "Fail to get scale block range of current level#" + to_string(_level);
	const string logErrGetScaleBaseBlk = "Fail to get scale block range of base level#" + to_string(lvlBase._level);
	const string logErrSetupImgBuf = "Setup temp image buffer failed";

	// Get Dest/current region
	IRECT rcCurFull;
	RET_ON_NEG_AND(
		blockerCur.GetBlockEdge(rcBlkCur, rcCurFull),
		Logger::Log0(logH, logErrGetCurBlk););

	// Get Stable regions array
	vector<IRECT> vecRCStable;
	RETVAL_ON_NEG_AND(
		blockerCur.GetStableBlocksSplit(rcBlkCur, vecRCStable),
		IMGSYS_RET::ISR_FAIL,
		Logger::Log0(logH, logErrGetRegionSplit););

	// Get Image Scale regions
	vector<std::pair<IRECT, IRECT>> vecRCScale;
	for(int i = 0; i < vecRCStable.size(); ++i)
	{
		IRECT rcScaleBlkCur = vecRCStable[i];

		// Get Src/base region
		IRECT rcScaleBlkBase;
		RET_ON_NEG_AND(
			blockerCur.GetAlignedBlocks(blockerBase, rcScaleBlkCur, rcScaleBlkBase),
			Logger::Log0(logH, logErrGetScaleBaseBlkIdx););

		// Get Dest/current & Src/base region
		IRECT rcScaleCur;
		RET_ON_NEG_AND(
			blockerCur.GetBlockEdge(rcScaleBlkCur, rcScaleCur),
			Logger::Log0(logH, logErrGetScaleCurBlk););
		IRECT rcScaleBase;
		RET_ON_NEG_AND(
			blockerBase.GetBlockEdge(rcScaleBlkBase, rcScaleBase),
			Logger::Log0(logH, logErrGetScaleBaseBlk););

		//  Get Dest/current offset region
		IRECT rcScaleCurRel = rcScaleCur;
		rcScaleCurRel.Offset(rcCurFull.BasePoint().Inversed());

		vecRCScale.emplace_back(rcScaleCurRel, rcScaleBase);
	}

	// Create temp image buffer
	ImgBuf imgBufTemp;
	RETVAL_ON_NEG_AND(
		imgBufTemp.Setup(rcCurFull.Width(), rcCurFull.Height(), _format),
		IMGSYS_RET::ISR_FAIL,
		Logger::Log0(logH, logErrSetupImgBuf););

	// Get base level full block index
	IRECT rcBlkBase;
	RET_ON_NEG_AND(
		blockerCur.GetAlignedBlocks(blockerBase, rcBlkCur, rcBlkBase),
		Logger::Log0(logH, logErrGetBaseBlk););

	// Lock src/base level blocks
	//Logger::Log0("ImgLevel::UpdateSampling: Locking Blocks(IRead) " + rcBlkBase.ToString());
	vector<vector<scope_guard>> v2ScgLockBlocks;
	scope_guard scgRecoverBlkStatus;
	RET_ON_NEG(
		lvlBase.LockBlocks(rcBlkBase, LOCK_MODE::LKM_IREAD, v2ScgLockBlocks, scgRecoverBlkStatus, msTimeoutLock));
	scgRecoverBlkStatus.Disable();

	// Scale to image buffer
	for(int i = 0; i < vecRCScale.size(); ++i)
	{
		IRECT rcDest	= vecRCScale[i].first;
		IRECT rcSrc		= vecRCScale[i].second;

		ImgBuf imgBufSrc;
		RET_ON_NEG(
			lvlBase.GetLevelAccessInternalGMAP(imgBufSrc, rcSrc));
		RET_ON_NEG(
			imgBufTemp.ScaleFrom(imgBufSrc, rcDest));
	}

	// Get blocks status
	//Logger::Log0(logH, "Begin to get blocks data status");
	RET_ON_NEG(
		GetLevelBlocksDataStatus_Unsafe(lvlBase, rcBlkCur, vec2BlkStatus));
	//Logger::Log0(logH, "Blocks data status got");

	// Set to image buf
	imgBuf	= std::move(imgBufTemp);

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::LockBlocks(
	const IRECT &rcBlk, LOCK_MODE lockMode,
	vector<vector<scope_guard>> &vec2ScgLock, scope_guard &scgBlkStatusRecover,
	ms_t1 msTimeoutBlk)
{
	// Clear out vec
	vec2ScgLock.clear();

	// Validate status
	if(!IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	Ticker ticker;
	ticker.Start();

	// Get lock function
	function<iret(const ImgBlock*, scope_guard &, ms_t1)> funcLock;
	switch (lockMode)
	{
	case LKM_LOCK:
		break;
	case LKM_BLOCK:
		funcLock = std::bind(&ImgBlock::LockBlock, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3);
		break;
	case LKM_WRITE:
		funcLock = std::bind(&ImgBlock::LockWrite, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3);
		break;
	case LKM_READ:
		break;
	case LKM_IREAD:
		funcLock = std::bind(&ImgBlock::LockIRead, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3);
		break;
	default:
		break;
	}
	if(funcLock._Empty())
	{
		return IMGSYS_RET::ISR_INVARGS;
	}

	// Scope guard for out params recover
	scope_guard scgOut(
		[&](){
			vec2ScgLock.clear();
		});

	// Lock blocks and store block status
	vec2ScgLock.clear();
	vec2ScgLock.resize(rcBlk.Height());
	vector<vector<IMGBLOCK_LOADSTATUS>> v2BlkStatus(rcBlk.Height());
	for(idxblk y = rcBlk.top; y <= rcBlk.bottom; ++y)
	{
		idxblk iVY = y - rcBlk.top;
		vec2ScgLock[iVY].clear();
		for(idxblk x = rcBlk.left; x <= rcBlk.right; ++x)
		{
			// Get lock timeout
			double tc = ticker.Tick();
			ms_t1 msLock = LOCK_TIME_INFINITE;
			if(msTimeoutBlk != LOCK_TIME_INFINITE)
			{
				msLock = (ms_t1)(msTimeoutBlk - tc*1000);
				if(msLock <= 0)
				{
					return IMGSYS_RET::ISR_LOCKFAIL;
				}
			}

			// Lock block
			scope_guard scgLockBlk;
			if(funcLock(&(_blocks[y][x]), scgLockBlk, msLock) < 0)
			{
				return IMGSYS_RET::ISR_LOCKFAIL;
			}
			vec2ScgLock[iVY].emplace_back(std::move(scgLockBlk));

			// Store Block status
			IMGBLOCK_LOADSTATUS statusBlk = _blocks[y][x].GetStatus_Unsafe();
			v2BlkStatus[iVY].emplace_back(statusBlk);
		}
	}

	scgOut.Disable();

	// Scope guard for blocks status recovery
	scgBlkStatusRecover.SetAndEnable(
		std::bind([this, v2BlkStatus, rcBlk]()
		{
			for(idxblk y = rcBlk.top, j = 0; y <= rcBlk.bottom; ++y)
			{
				idxblk iVY = y - rcBlk.top;
				for(idxblk x = rcBlk.left; x <= rcBlk.right; ++x)
				{
					_blocks[y][x].SetStatus_Unsafe(v2BlkStatus[iVY][x - rcBlk.left]);
				}
			}
		}));

	return IMGSYS_RET::ISR_SUCCEED;
}

string ImgLevel::GetLevelName()
{
	string name = "Local-BIDLevel" + to_string(_level) + Logging::GetSystemTimeStr2();
	return name;
}

iret ImgLevel::SetupBlocker()
{
	// Init blocker
	RET_ON_NEG(
		_blocker.Setup(_width, _height));
	
	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::SetupBlocker(
	const ImgLevel &lvlBase)
{
	// Init blocker
	RET_ON_NEG(
		_blocker.Setup(lvlBase._blocker));
	
	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::SetupStructure(
	idxlvl idxLvl, 
	iDim wLvl, iDim hLvl, IMGDISP_PIXELFORMAT format)
{
	Logger::Log0("ImgLevel::SetupStructure");
	// Set level info
	_level		= idxLvl;

	// Setup data structure
	RET_ON_NEG(
		SetupDataStructure(wLvl, hLvl, format));

	// Setup blocker
	RET_ON_NEG(
		SetupBlocker());

	// Setup blocks
	RET_ON_NEG(
		SetupBlocks());

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::SetupStructure(
	const ImgLevel &lvlBase)
{
	// Set level info
	_level		= lvlBase._level + 1;
	// >> Overflow [idxlvl] <<
	if(_level < lvlBase._level)
	{
		return IMGSYS_RET::ISR_INVARGS;
	}

	// Setup blocker first
	RET_ON_NEG(
		SetupBlocker(lvlBase));
	iDim wLvl = _blocker.GetWidth();
	iDim hLvl = _blocker.GetHeight();
	
	// Setup data structure
	RET_ON_NEG(
		SetupDataStructure(wLvl, hLvl, lvlBase._format));

	// Setup blocks
	RET_ON_NEG(
		SetupBlocks());

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::SetupDataStructure(
	iDim wLvl, iDim hLvl, IMGDISP_PIXELFORMAT format)
{
	Logger::Log0("ImgLevel::SetupDataStructure");
	string nameLevel = GetLevelName();

	// Store mode
	switch(_store)
	{
	case IMGDATA_STORAGE::IDS_MMAP:
		return IMGSYS_RET::ISR_UNKNOWNOP;
		break;
	case IMGDATA_STORAGE::IDS_GMAP:
		// Setup image data
		RET_ON_NEG(
			IImgDataLevel::Setup(wLvl, hLvl, format, nameLevel));
		Logger::Log0("ImgLevel::SetupBlocks: Level#" + to_string(_level) +
			" MMap-'" + nameLevel + "' built");

		break;
	default:
		return IMGSYS_RET::ISR_UNKNOWNOP;
		break;
	}

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::SetupBlocks()
{
	// Validate blocker status
	if(!_blocker.IsSet())
	{
		return IMGSYS_RET::ISR_INVMEMBER;
	}

	// Setup blocks matrix
	idxblk nBlkX = _blocker.GetNBlockX();
	idxblk nBlkY = _blocker.GetNBlockY();
	_blocks.clear();
	_blocks.resize(nBlkY);
	for (idxblk j = 0; j < nBlkY; ++j)
	{
		_blocks[j].resize(nBlkX);
	}

	// Set blocks
	const arr_divsrc& arrDivSrcX = _blocker.GetSrcVecX();
	const arr_divsrc& arrDivSrcY = _blocker.GetSrcVecY();
	for (idxblk y = 0; y < _blocks.size(); ++y)
	{
		for (idxblk x = 0; x < _blocks[y].size(); ++x)
		{
			iDim xBlk		= arrDivSrcX[x];
			iDim yBlk		= arrDivSrcY[y];
			iDim x2Blk		= arrDivSrcX[x + 1];
			iDim y2Blk		= arrDivSrcY[y + 1];

			RET_ON_NEG(
				_blocks[y][x].Setup(
					_store,
					x, y,
					_format,
					xBlk, yBlk, x2Blk - xBlk, y2Blk - yBlk,
					GetPData(), _stride));
		}
	}

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::SetupData(
	const ImgBuf &imgSrc)
{
	// Validate basic
	if (!imgSrc.HasData())
	{
		return IMGSYS_RET::ISR_NULLIMG;
	}

	// Adapt the image to the level
	ImgBuf imgBuf;
	int ret = GetLevelSuitedImg(imgSrc, imgBuf);
	RET_ON_NEG(
		ret);
	// use origin imgbuf if not
	const ImgBuf& imgBufLvl = (IMGSYS_RET::ISR_NOOPERATION == ret)?
		imgSrc : imgBuf;

	// Get blocks index range
	IRECT rcBlkIdx;
	RET_ON_NEG(
		_blocker.GetBlockRangeRect(rcBlkIdx));

	// Set blocks data
	return SetBlocksDataInternal(imgBufLvl,
		rcBlkIdx, IMG_UPDATE_TYPE::IUT_INIT, nullptr, __msTimeoutLockSetupData);
}

iret ImgLevel::SetupData(
	ImgLevel &lvlBase)
{
	// Get blocks index range
	IRECT rcBlkCur;
	RET_ON_NEG(
		_blocker.GetBlockRangeRect(rcBlkCur));

	// Adapt the image to the level
	ImgBuf imgBuf;
	vector<vector<IMGBLOCK_DATASTATUS>> vec2BlkStatus;
	RET_ON_NEG(
		GetLevelSuitedImg(lvlBase, rcBlkCur, imgBuf, vec2BlkStatus));

	// Set blocks data
	return SetBlocksDataInternal(imgBuf,
		rcBlkCur, IMG_UPDATE_TYPE::IUT_INIT, &vec2BlkStatus, __msTimeoutLockSetupData);
}

iret ImgLevel::SetupInternal(
	idxlvl idxLvl,
	iDim wLvl, iDim hLvl, IMGDISP_PIXELFORMAT format,
	const ImgBuf &imgSrc)
{
	// Clear
	if(IsBuilt())
	{
		ClearInternal();
	}

	// Set specification
	RET_ON_NEG(
		SetupStructure(idxLvl, wLvl, hLvl, format));

	// PostUpdate #1 (necessary)
	PostUpdate(IMGLEVEL_STATUS::LLS_UNLOAD);
	
	// Set data
	bool bData = imgSrc.HasData();
	if(bData)
	{
		RET_ON_NEG(
			SetupData(imgSrc));
	}
	
	// PostUpdate #2
	PostUpdate(
		bData ? IMGLEVEL_STATUS::LLS_LOADED : IMGLEVEL_STATUS::LLS_UNLOAD);

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::SetupInternal(
	ImgLevel &lvlBase)
{
	// Validate status
	if(!lvlBase.IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	// Clear
	if(IsBuilt())
	{
		ClearInternal();
	}
	
	// Set specification
	RET_ON_NEG(
		SetupStructure(lvlBase));

	bool bData = lvlBase._status == IMGLEVEL_STATUS::LLS_LOADED ||
		lvlBase._status == IMGLEVEL_STATUS::LLS_PARTLOAD;
	// Set data
	if(bData)
	{
		RET_ON_NEG(
			SetupData(lvlBase));
	}

	PostUpdate(
		bData ? IMGLEVEL_STATUS::LLS_LOADED : IMGLEVEL_STATUS::LLS_UNLOAD);

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::ClearInternal()
{
	// Status & info
	_status			= IMGLEVEL_STATUS::LLS_EMPTY;
	_level			= -1;
	// Blocker
	_blocker.Clear();
	// Blocks
	_blocks.clear();
	// let memory released
	//_blocks.swap(vector<vector<ImgBlock>>());

	// IImgDataLevel (Clear last)
	IImgDataLevel::Clear();

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::SetBlocksDataInternal(
	const ImgBuf &imgBuf, const IRECT &rcBlkSet,
	IMG_UPDATE_TYPE updateType,
	const vector<vector<IMGBLOCK_DATASTATUS>> *vec2BlkStatus,
	ms_t1 msTimeoutLock)
{
	IRECT rcSetActual;
	switch(_store)
	{
	case IMGDATA_STORAGE::IDS_MMAP:
		return IMGSYS_RET::ISR_UNKNOWNOP;
		break;
	case IMGDATA_STORAGE::IDS_GMAP:
		return SetBlocksDataGMAP(imgBuf,
			rcBlkSet, rcSetActual, updateType, vec2BlkStatus, msTimeoutLock);
		break;
	default:
		return IMGSYS_RET::ISR_UNKNOWNOP;
		break;
	}

	return IMGSYS_RET::ISR_UNKNOWNOP;
}

iret ImgLevel::SetBlocksDataGMAP(
	const ImgBuf &imgBuf,
	const IRECT &rcBlkSet, IRECT &rcSetActual,
	IMG_UPDATE_TYPE updateType,
	const vector<vector<IMGBLOCK_DATASTATUS>> *vec2BlkStatus,
	ms_t1 msTimeoutLock)
{
	Ticker ticker;

	// Validate status
	if(!IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	// Validate basic
	if(!imgBuf.HasData())
	{
		return IMGSYS_RET::ISR_NULLIMG;
	}

	// Validate block index range
	RETVAL_ON_FALSE(
		_blocker.IsInsideBlock(rcBlkSet),
		IMGSYS_RET::ISR_INVBLKRANGE);


	// Update type
	IMGBLOCK_LOADSTATUS blockStatusFrom = IMGBLOCK_LOADSTATUS::BLS_SYNC;
	IMGBLOCK_LOADSTATUS blockStatusUpdate = IMGBLOCK_LOADSTATUS::BLS_EDITING;
	IMGBLOCK_LOADSTATUS blockStatusTo = IMGBLOCK_LOADSTATUS::BLS_SYNC;
	LOCK_MODE blockLockMode = LOCK_MODE::LKM_WRITE;
	switch (updateType)
	{
	case ImgDisplay::IUT_INIT:
		blockStatusUpdate = IMGBLOCK_LOADSTATUS::BLS_INITLOADING;
		break;
	case ImgDisplay::IUT_UPDATE:
		blockStatusUpdate = IMGBLOCK_LOADSTATUS::BLS_EDITING;
		break;
	default:
		return IMGSYS_RET::ISR_INVARGS;
	}

	// Calculate rcCopy
	IRECT rcCopy;
	RETVAL_ON_NEG(
		_blocker.GetBlockEdge(rcBlkSet, rcCopy),
		IMGSYS_RET::ISR_FAIL);
	//RETVAL_ON_TRUE(
	//	rcLoad.IsInvalid_Out(_width, _height)
	//	, IMGSYS_RET::ISR_INVBLKRANGE);
	// Clip load block range
	rcCopy.CorrectSize(imgBuf.GetWidth(), imgBuf.GetHeight());

	// Lock blocks
	vector<vector<scope_guard>> v2ScgLockBlocks;
	scope_guard scgRecoverBlkStatus;
	//Logger::Log0("ImgLevel::SetBlocksDataGMAP: Locking Blocks(Write)" + rcBlkIdx.ToString());
	RET_ON_NEG(
		LockBlocks(rcBlkSet, blockLockMode, v2ScgLockBlocks, scgRecoverBlkStatus, msTimeoutLock));

	Logger::Log0("ImgLevel::SetBlocksDataGMAP: Locked");

	ticker.Start();

	idxblk iBlkX = rcBlkSet.left;
	idxblk iBlkY = rcBlkSet.top;
	idxblk iBlkR = rcBlkSet.right;
	idxblk iBlkB = rcBlkSet.bottom;

	// Validate Blocks status
	for(idxblk y = iBlkY; y <= iBlkB; ++y)
	{
		for(idxblk x = iBlkX; x <= iBlkR; ++x)
		{
			if(!_blocks[y][x].IsUpdateDataStatus_Unsafe())
			{
				return IMGSYS_RET::ISR_INVSTATUS;
			}
		}
	}

	// Update blocks status - EDITING
	for(idxblk y = iBlkY; y <= iBlkB; ++y)
	{
		for(idxblk x = iBlkX; x <= iBlkR; ++x)
		{
			_blocks[y][x].SetStatus_Unsafe(blockStatusUpdate);
		}
	}

	// Get Base level image access buffer
	ImgBuf imgBufLevel;
	RET_ON_NEG(
		GetLevelAccessInternalGMAP(imgBufLevel, rcCopy));

	Logger::Log0("ImgLevel::SetBlocksDataGMAP: get buf" 
		"rcCopy:" + rcCopy.ToString() + "w:" + to_string(imgBuf.GetWidth()) +
		"h:" + to_string(imgBuf.GetHeight()));
	// Copy data
	IRECT rcSrc = IRECT::FromXYWH(0, 0, rcCopy.Width(), rcCopy.Height());
	RET_ON_NEG(
		imgBuf.CopyTo(rcSrc, imgBufLevel));
	
	Logger::Log0("ImgLevel::SetBlocksDataGMAP: Data copy");
	// Update blocks data status
	if(ImgDisplay::IUT_UPDATE == updateType)
	{
		if(nullptr == vec2BlkStatus)
		{
			return IMGSYS_RET::ISR_POSTPROCESSFAIL;
		}

		for(idxblk y = iBlkY; y <= iBlkB; ++y)
		{
			idxblk iy = y - iBlkY;
			bool bYStatus = iy< vec2BlkStatus->size();
			for(idxblk x = iBlkX; x <= iBlkR; ++x)
			{
				idxblk ix = x - iBlkX;
				bool bXStatus = false;
				if(bYStatus)
				{
					bXStatus = ix < (*vec2BlkStatus)[iy].size();
				}

				if(bXStatus)
				{
					if(IMGBLOCK_DATASTATUS::BDS_FULL == (*vec2BlkStatus)[iy][ix])
					{
						_blocks[y][x].SetStatusAvailable_Unsafe(true);
					}
					else if(IMGBLOCK_DATASTATUS::BDS_PART == (*vec2BlkStatus)[iy][ix])
					{
						_blocks[y][x].SetStatusAvailable_Unsafe(false);
					}
				}
			}
		}
	}
	else
	{
		// Calculate blocks data status region
		IRECT rcUpdate;
		IRECT rcUpdateFull;
		RETVAL_ON_NEG(
			_blocker.GetFullAndPartOverlapBlocks(rcCopy, rcUpdate, rcUpdateFull),
			IMGSYS_RET::ISR_POSTPROCESSFAIL);

		for(idxblk y = iBlkY; y <= iBlkB; ++y)
		{
			for(idxblk x = iBlkX; x <= iBlkR; ++x)
			{
				if(rcUpdateFull.IsPointInside(IPOINT(x, y)))
				{
					_blocks[y][x].SetStatusAvailable_Unsafe(true);
				}
				else
				{
					_blocks[y][x].SetStatusAvailable_Unsafe(false);
				}
			}
		}
	}

	// Unlock/ Recover
	scgRecoverBlkStatus.Release();
	v2ScgLockBlocks.clear();

	Logger::Log0("ImgLevel::SetBlocksDataGMAP: "
		"Level#" + to_string(_level) + " Block Region " + rcBlkSet.ToString() + 
		" Locked time=" + to_string(ticker.Tick()) + "s");

	// Output
	rcSetActual = rcCopy;

	// Shrink test
	/*Logger::Log0("shrink");
	iDim w = _width - 100;
	iDim h = _height - 100;

	size_t nCopy = w*_depth;
	void *pRowDest = ((byte*)pDataLvl + nCopy);
	void *pRow = ((byte*)pDataLvl + _stride);
	for(int j = 1; j < h; ++j
		, GO_STRIDE(pRow, _stride), GO_STRIDE(pRowDest, nCopy))
	{
		memmove_s(pRowDest, nCopy, pRow, nCopy);
	}	
	Logger::Log0("shrink done");*/

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::InitLoadBlocksInternal(
	const ImgBuf &imgBuf,
	const IRECT &rcBlkLoad,
	ms_t1 msTimeoutLock)
{
	return SetBlocksDataInternal(imgBuf, rcBlkLoad, IMG_UPDATE_TYPE::IUT_INIT, nullptr, msTimeoutLock);
}


iret ImgLevel::ExtractInitLoadRegionRowInternal(
	IRECT &rcBlkLoad,
	scope_guard &scgRecoverFlag, bool &bRemain) const
{
	// Validate status
	if(!IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	idxblk nBlockX = _blocker.GetNBlockX();
	idxblk nBlockY = _blocker.GetNBlockY();

	// Store 'InitLoad flag recover'
	vector<std::pair<idxblk, idxblk>> vecBlkIdxRecover;
	
	if(IMGDATA_STORAGE::IDS_GMAP == _store)
	{
		// Find InitLoad region
		idxblk iRowF = -1;
		idxblk iRowR = -1;
		idxblk iRow = 0;
		for(iRow = 0; iRow < nBlockY; ++iRow)
		{
			bool bRowInitLoad = false;
			for(idxblk ix = 0; ix < nBlockX; ++ix)
			{
				// Check and reset InitLoad flag Here!
				if(_blocks[iRow][ix].CheckResetInitLoadFlag())
				{
					// store block index(to be recover status)
					vecBlkIdxRecover.emplace_back(iRow, ix);

					bRowInitLoad = true;
				}
			}

			if(bRowInitLoad)
			{
				if(-1 == iRowF)
				{
					iRowF = iRow;
				}
				iRowR = iRow;
				break;// Limit 1 row
			}
		}

		// Validate region is found
		bool bRegionFound = 
			iRowF >= 0 && iRowF <= nBlockY - 1 &&
			iRowR >= 0 && iRowR <= nBlockY - 1 &&
			iRowF <= iRowR;
		RETVAL_ON_FALSE(
			bRegionFound,
			IMGSYS_RET::ISR_NOTFOUND);

		// ScopeGuard for InitLoad flag recover
		scgRecoverFlag.SetAndEnable(
			[vecBlkIdxRecover, this]()
			{
				size_t nRecover = vecBlkIdxRecover.size();
				if(nRecover > 0)
				{
					for(size_t i = 0; i < nRecover; ++i)
					{
						_blocks[vecBlkIdxRecover[i].first][vecBlkIdxRecover[i].second].SetInitLoadFlag(true);
					}
					//bRemain = true;
				}
			});

		// Check whether there is remaining UpdateSampling row
		for(idxblk iRowRemain = iRowR + 1; iRowRemain < nBlockY; ++iRowRemain)
		{
			bool bRowInitLoad = false;
			for(idxblk ix = 0; ix < nBlockX; ++ix)
			{
				if(_blocks[iRowRemain][ix].IsInitLoadFlagSet())
				{
					bRowInitLoad = true;
					break;
				}
			}

			if(bRowInitLoad)
			{
				bRemain = true;
				break;
			}
		}

		// Get rcBlkIdxLoad
		rcBlkLoad = IRECT::FromXYWH(0, iRowF, nBlockX, (iRowR - iRowF + 1));

		//Logger::Log0("ImgLevel::ExtractInitLoadRegionRowInternal: "
		//	"Init Load region got " + rcBlkLoad.ToString() +
		//	", bRemain=" + (string)(bRemain ? "true" : "false"));
	}

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::UpdateSamplingInternal(
	const ImgBuf &imgBuf,
	const IRECT &rcBlkUpdate,
	const vector<vector<IMGBLOCK_DATASTATUS>> *vec2BlkStatus,
	ms_t1 msTimeoutLock)
{
	// Validate status
	if(!IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	return SetBlocksDataInternal(imgBuf, rcBlkUpdate, IMG_UPDATE_TYPE::IUT_UPDATE, vec2BlkStatus, msTimeoutLock);
}

iret ImgLevel::ExtractUpdateSamplingRegionRow(
	IRECT &rcBlkUpdate,
	scope_guard &scgRecoverFlag, bool &bRemain) const
{
	// Validate status
	if(!IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	// Update bRemain
	bRemain = false;

	idxblk nBlockX = _blocker.GetNBlockX();
	idxblk nBlockY = _blocker.GetNBlockY();

	// Store 'UpdateSampling flag recover'
	vector<std::pair<idxblk, idxblk>> vecBlkIdxRecover;

	if(IMGDATA_STORAGE::IDS_GMAP == _store)
	{
		// Find UpdateSampling region
		idxblk iRowF = -1;
		idxblk iRowR = -1;
		idxblk iRow = 0;
		for(iRow = 0; iRow < nBlockY; ++iRow)
		{
			bool bRowUpdate = false;
			for(idxblk ix = 0; ix < nBlockX; ++ix)
			{
				// Check and reset UpdateSampling flag Here!
				if(_blocks[iRow][ix].CheckResetUpdateFlag())
				{
					// store block index(to be recover status)
					vecBlkIdxRecover.emplace_back(iRow, ix);

					bRowUpdate = true;
				}
			}

			if(bRowUpdate)
			{
				if(-1 == iRowF)
				{
					iRowF = iRow;
				}
				iRowR = iRow;
			}
			else
			{
				if(-1 != iRowF)
				{
					break;
				}
			}
		}

		// Validate region is found
		bool bRegionFound = 
			iRowF >= 0 && iRowF <= nBlockY - 1 &&
			iRowR >= 0 && iRowR <= nBlockY - 1 &&
			iRowF <= iRowR;
		RETVAL_ON_FALSE(
			bRegionFound,
			IMGSYS_RET::ISR_INVBLKRANGE);

		// ScopeGuard for UpdateSampling flag recover
		scgRecoverFlag.SetAndEnable(
			[vecBlkIdxRecover, this]()
			{
				size_t nRecover = vecBlkIdxRecover.size();
				if(nRecover > 0)
				{
					for(size_t i = 0; i < nRecover; ++i)
					{
						_blocks[vecBlkIdxRecover[i].first][vecBlkIdxRecover[i].second].SetUpdateFlag(true);
					}
				}
			});

		// Check whether there is remaining UpdateSampling row
		for(idxblk iRowRemain = iRowR + 2; iRowRemain < nBlockY; ++iRowRemain)
		{
			bool bRowUpdate = false;
			for(idxblk ix = 0; ix < nBlockX; ++ix)
			{
				if(_blocks[iRowRemain][ix].IsUpdateFlagSet())
				{
					bRowUpdate = true;
					break;
				}
			}

			if(bRowUpdate)
			{
				bRemain = true;
				break;
			}
		}

		// Get rcBlkIdxUpdate
		rcBlkUpdate = IRECT::FromXYWH(0, iRowF, nBlockX, (iRowR - iRowF + 1));
	}

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::UpdateSamplingTaskGMAP(
	ImgLevel &lvlBase, const IRECT &rcBlkUpdate,
	ms_t1 msTimeoutLock)
{
	// Validate block index range
	RETVAL_ON_FALSE(
		_blocker.IsInsideBlock(rcBlkUpdate),
		IMGSYS_RET::ISR_INVBLKRANGE);

	// Get suited level image
	ImgBuf imgBuf;
	vector<vector<IMGBLOCK_DATASTATUS>> vec2BlkStatus;
	RET_ON_NEG_AND(
		GetLevelSuitedImg_AlignedGMAP(lvlBase, rcBlkUpdate, imgBuf, vec2BlkStatus, msTimeoutLock),
		Logger::Log0("ImgLevel::UpdateSamplingTaskGMAP: "
		"Fail to get suited image of level#" + to_string(_level)););
	//Logger::Log0(logH, "Sampling image of level#" + to_string(_level) + " got" + "[" + to_string(ticker.Cycle()) + "]");

	// UpdateSamplingInternal
	RET_ON_NEG(
		UpdateSamplingInternal(imgBuf, rcBlkUpdate, &vec2BlkStatus, msTimeoutLock));

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::UpdateSamplingMergedInternal(
	ImgLevel &lvlBase, vector<IRECT> &vecRCUpdate, bool &bRemain,
	ms_t1 msTimeoutLock)
{
	switch (_store)
	{
	case ImgDisplay::IDS_GMAP:
		return UpdateSamplingMergedInternalGMAP(lvlBase, vecRCUpdate, bRemain, msTimeoutLock);
		break;
	case ImgDisplay::IDS_MMAP:
		return IMGSYS_RET::ISR_UNKNOWNOP;
		break;
	default:
		return IMGSYS_RET::ISR_UNKNOWNOP;
		break;
	}

	return IMGSYS_RET::ISR_UNKNOWNOP;
}

iret ImgLevel::UpdateSamplingMergedInternalGMAP(
	ImgLevel &lvlBase, vector<IRECT> &vecRCUpdate, bool &bRemain,
	ms_t1 msTimeoutLock)
{
	const string logH = "ImgLevel::UpdateSamplingMergedInternal: ";

	// Validate status
	if(!IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	Ticker ticker;
	ticker.Start();

	// Extract update region
	IRECT rcUpdate;
	scope_guard scgRecoverFlag;
	if(IMGDATA_STORAGE::IDS_GMAP == _store)
	{
		iret ret = ExtractUpdateSamplingRegionRow(rcUpdate, scgRecoverFlag, bRemain);
		RETVAL_ON_NEG_AND(
			ret,
			IMGSYS_RET::ISR_NOTFOUND,
			Logger::Log0(logH, "No region found to be updated sampling for level#" + to_string(_level)););
	}
	else
	{
		return IMGSYS_RET::ISR_UNKNOWNOP;
	}

	//Logger::Log0(logH, "Region to be Updated sampling found: " +
	//	rcUpdate.ToString());

	// ScopeGuard for remaining InitLoad
	scope_guard scgRemain(
		[&bRemain](){
			bRemain = true;}
	);
	

	// UpdateSamplingInternal
	iret ret = UpdateSamplingTaskGMAP(lvlBase, rcUpdate, msTimeoutLock);
	RET_ON_NEG_AND(
		ret,
		Logger::Log0(logH, "Failed, ret = " + to_string(ret)););
	// Add Updatesampling region
	vecRCUpdate.emplace_back(rcUpdate);

	//Logger::Log0(logH, "Level#" + to_string(_level) +
	//	" Sampling updated " + rcUpdate.ToString() + "  [" + to_string(ticker.Cycle()) + "]");

	// Disable ScopeGuard
	scgRecoverFlag.Disable();
	scgRemain.Disable();

	return IMGSYS_RET::ISR_SUCCEED;
}

void ImgLevel::PostUpdate(
	IMGLEVEL_STATUS status)
{
	// TODO: Judge whether part load
	_status = status;
}

ImgLevel::ImgLevel():
	IImgDataLevel	(),
	_lock			(),
	_status			(IMGLEVEL_STATUS::LLS_EMPTY),
	_level			(-1),
	_blocker		(),
	_blocks			(),
	_blocksAlign	(IMGDISP_BLOCKSALIGNMODE::DSBAM_ALIGNED),
	_mapColorRender	(),
	__msTimeoutLockSetupData(-1)
{
}

ImgLevel::ImgLevel(ImgLevel &&other):
	IImgDataLevel	(),
	_lock			(),
	_status			(IMGLEVEL_STATUS::LLS_EMPTY),
	_level			(-1),
	_blocker		(),
	_blocks			(),
	_blocksAlign	(IMGDISP_BLOCKSALIGNMODE::DSBAM_ALIGNED),
	_mapColorRender	(),
	__msTimeoutLockSetupData(-1)
{
	// Assign
	AssignMove(other);
}

ImgLevel& ImgLevel::operator = (ImgLevel &&other)
{
	// Assign
	AssignMove(other);

	return *this;
}

iret ImgLevel::AssignMove(ImgLevel &other)
{
	// ======>> LOCK OTHER <<=======
	IMGLEVEL_LOCKOTHER_INTERNAL(other);
	// ======>> LOCK <<=======
	IMGLEVEL_LOCK_INTERNAL;
		
	// Clear before assignment
	ImgLevel::ClearPreAssign();

	// [Level index]
	_level			= other._level;
	// [Blocker]
	_blocker.AssignMove(std::forward<BLOCKER>(other._blocker));
	// [Blocks]
	_blocks			= std::forward<matblk>(other._blocks);
	// [Settings]
	_blocksAlign	= other._blocksAlign;
	_mapColorRender	= std::forward<color_map>(other._mapColorRender);
	__msTimeoutLockSetupData = other.__msTimeoutLockSetupData;
	// [IImgDataLevel]
	IImgDataLevel::AssignMove(other);
	// Assign [Status] last
	_status			= other._status;

	// ======>> UNLOCK <<=======
	IMGLEVEL_UNLOCK_INTERNAL;

	// Clear after move
	other.ImgLevel::ClearMove();
	
	// ======>> UNLOCK OTHER <<=======
	IMGLEVEL_UNLOCKOTHER_INTERNAL;

	return IMGSYS_RET::ISR_SUCCEED;
}

ImgLevel::~ImgLevel()
{
	// ======>> LOCK <<=======
	IMGLEVEL_LOCK_INTERNAL;

	Release();
}

iret ImgLevel::Clear()
{
	// ======>> LOCK <<=======
	IMGLEVEL_LOCK_INTERNAL;

	return ClearInternal();
}

void ImgLevel::ClearPreAssign()
{
	// [Status]
	_status			= IMGLEVEL_STATUS::LLS_EMPTY;
	// [Level index]
	_level			= -1;
	// [Blocker]
	// [Blocks]
	// [Settings]
}

void ImgLevel::ClearMove()
{
	// [Status]
	_status			= IMGLEVEL_STATUS::LLS_EMPTY;

	// [level index]
	_level			= -1;

	// [Blocker]
	//_blocker

	// [Blocks]
	//  let memory released
	_blocks.swap(matblk());

	// [Settings]
	_blocksAlign	= IMGDISP_BLOCKSALIGNMODE::DSBAM_ALIGNED;
	//_mapColorRender
	__msTimeoutLockSetupData = LOCK_TIME_INFINITE;
}

void ImgLevel::Release()
{
	ImgLevel::ClearPreAssign();
}

const ImgLevel::BLOCKERBASE& ImgLevel::GetBlockerConst(
	scope_guard &scgBlocker) const
{
	// ======>> LOCK IREAD <<=======
	IMGLEVEL_LOCKIREADSCG_INTERNAL(scgBlocker);
	return _blocker;
}

ImgLevel::iDim ImgLevel::GetWidth() const
{
	// ======>> LOCK IREAD <<=======
	IMGLEVEL_LOCKIREAD_INTERNAL;
	return _width;
}
ImgLevel::iDim ImgLevel::GetHeight() const
{
	// ======>> LOCK IREAD <<=======
	IMGLEVEL_LOCKIREAD_INTERNAL;
	return _height;
}

ImgLevel::iDim ImgLevel::GetBlockSize() const
{
	// ======>> LOCK IREAD <<=======
	IMGLEVEL_LOCKIREAD_INTERNAL;
	return _blocker.GetBlockSize();
}

iret ImgLevel::SetBlockSize(iDim szBlk)
{
	// ======>> LOCK <<=======
	IMGLEVEL_LOCK_INTERNAL;

	// Validate status
	if(IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	return _blocker.SetBlockSize(szBlk);
}

ImgLevel::idxblk ImgLevel::GetNBlockX() const
{
	// ======>> LOCK IREAD <<=======
	IMGLEVEL_LOCKIREAD_INTERNAL;

	// Validate status
	if(!IsBuilt())
	{
		return -1;
	}

	return _blocker.GetNBlockX();
}

ImgLevel::idxblk ImgLevel::GetNBlockY() const
{
	// ======>> LOCK IREAD <<=======
	IMGLEVEL_LOCKIREAD_INTERNAL;

	// Validate status
	if(!IsBuilt())
	{
		return -1;
	}

	return _blocker.GetNBlockY();
}

IMGDISP_PIXELFORMAT ImgLevel::GetPixelFormat() const
{
	// ======>> LOCK IREAD <<=======
	IMGLEVEL_LOCKIREAD_INTERNAL;

	return _format;
}

const ImgLevel::matblk* ImgLevel::GetBlocksRefConst(
	scope_guard &scgLock) const
{
	// ======>> LOCK IREAD <<=======
	IMGLEVEL_LOCKIREADSCG_INTERNAL(scgLock);

	// Validate status
	if(!IsBuilt())
	{
		return nullptr;
	}

	return &_blocks;
}

bool ImgLevel::ClearRenderStatus() const
{
	// ======>> LOCK IREAD <<=======
	IMGLEVEL_LOCKIREAD_INTERNAL;

	for (idxblk j = 0; j < (idxblk)_blocks.size(); ++j)
	{
		for (idxblk i = 0; i < (idxblk)_blocks[j].size(); ++i)
		{
			_blocks[j][i].SetRenderStatus(IMGBLOCK_RENDER_STATUS::BRS_NORENDER);
		}
	}

	return true;
}

iret ImgLevel::SetTempFileDir(
	const string &tmpFileDir)
{
	// ======>> LOCK <<=======
	int retLock = -1;
	IMGLEVEL_TRYLOCK_INTERNAL(retLock);
	if(retLock <= 0)
	{
		return IMGSYS_RET::ISR_LOCKFAIL;
	}

	// Validate status
	if(IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	return IImgDataLevel::SetTempFileDir(tmpFileDir);
}

iret ImgLevel::SetStoreMode(
	IMGDATA_STORAGE modeStore)
{
	// ======>> LOCK <<=======
	int retLock = -1;
	IMGLEVEL_TRYLOCK_INTERNAL(retLock);
	if(retLock <= 0)
	{
		return IMGSYS_RET::ISR_LOCKFAIL;
	}

	// Validate status
	if(IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	RET_ON_NEG(
		IImgDataLevel::SetStoreMode(modeStore));

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::SetBlocksAlignMode(IMGDISP_BLOCKSALIGNMODE modeAlign)
{
	// ======>> LOCK <<=======
	int retLock = -1;
	IMGLEVEL_TRYLOCK_INTERNAL(retLock);
	if(retLock <= 0)
	{
		return IMGSYS_RET::ISR_LOCKFAIL;
	}

	// Validate status
	if(IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	_blocksAlign = modeAlign;

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::SetSettings(
	iDim szBlk, IMGDATA_STORAGE modeStore, 
	IMGDISP_BLOCKSALIGNMODE modeAlign, const string &tmpFileDir)
{
	RET_ON_NEG(
		SetBlockSize(szBlk));
	RET_ON_NEG(
		SetStoreMode(modeStore));
	RET_ON_NEG(
		SetBlocksAlignMode(modeAlign));
	RET_ON_NEG(
		SetTempFileDir(tmpFileDir));

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::Setup(
	idxlvl idxLvl,
	IMGDISP_PIXELFORMAT format, iDim wLvl, iDim hLvl,
	const ImgBuf &imgSrc)
{
	// ======>> LOCK <<=======
	IMGLEVEL_LOCK_INTERNAL;

	// Set internal
	RET_ON_NEG(
		SetupInternal(idxLvl, wLvl, hLvl, format, imgSrc));

	return IMGSYS_RET::ISR_SUCCEED;
}

int ImgLevel::Setup(
	IMGDATA_STORAGE modeStore,
	idxlvl idxLvl, 
	IMGDISP_PIXELFORMAT format, iDim wLvl, iDim hLvl,
	const ImgBuf &imgSrc)
{
	// ======>> LOCK <<=======
	IMGLEVEL_LOCK_INTERNAL;

	RET_ON_NEG(
		IImgDataLevel::SetStoreMode(modeStore));

	// Set internal
	RET_ON_NEG(
		SetupInternal(idxLvl, wLvl, hLvl, format, imgSrc));

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::Setup(
	ImgLevel &lvlBase, iDim &wLvl, iDim &hLvl)
{
	// ======>> LOCK OTHER <<=======
	IMGLEVEL_LOCKOTHER_INTERNAL(lvlBase);
	// Validate status
	if(!lvlBase.IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	// ======>> LOCK <<=======
	IMGLEVEL_LOCK_INTERNAL;

	RET_ON_NEG(
		IImgDataLevel::SetStoreMode(lvlBase._store));
	
	// Set internal
	RET_ON_NEG(
		SetupInternal(lvlBase));

	// Out value
	wLvl = _width;
	hLvl = _height;

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::SetUpdateFlag(
	const IRECT &rcBlkUpdate, bool bUpdate) const
{
	// ======>> LOCK IREAD <<=======
	IMGLEVEL_LOCKIREAD_INTERNAL;

	// Validate status
	if(!IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	// Validate block index range
	RETVAL_ON_FALSE(
		_blocker.IsInsideBlock(rcBlkUpdate),
		IMGSYS_RET::ISR_INVBLKRANGE);

	// Set update flag
	//Logger::Log0("ImgLevel::SetUpdateFlag: " "To-'" + (string)(bUpdate ? "true":"false") + '\'' +
	//	"rcBlkIdx:" + rcBlkIdx.ToString());
	for(idxblk y = rcBlkUpdate.top; y <= rcBlkUpdate.bottom; ++y)
	{
		for(idxblk x = rcBlkUpdate.left; x <= rcBlkUpdate.right; ++x)
		{
			_blocks[y][x].SetUpdateFlag(bUpdate);
		}
	}

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::SetUpdateFlag(
	const ImgLevel &lvlBase, const IRECT &rcBlkUpdate, bool bUpdate) const
{
	// ======>> LOCK READ OTHER <<=======
	IMGLEVEL_LOCKIREADOTHER_INTERNAL(lvlBase);
	// Validate status
	if(!lvlBase.IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	// ======>> LOCK IREAD <<=======
	IMGLEVEL_LOCKIREAD_INTERNAL;
	// Validate status
	if(!IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	// Get base/current blocker
	const BLOCKERBASE &blockerBase = lvlBase._blocker;
	const BLOCKERBASE &blockerCur = _blocker;

	// Get Up level block index
	IRECT rcBlkUpdateCur;
	RET_ON_NEG_AND(
		blockerBase.GetOverlapBlocks(blockerCur, rcBlkUpdate, rcBlkUpdateCur),
		Logger::Log0("ImgLevel::SetUpdateFlag: Fail to load level " + to_string(_level) +
			": fail to get up level block index range of level " + to_string(_level) + rcBlkUpdate.ToString()););

	// Validate block index range
	RETVAL_ON_FALSE(
		_blocker.IsInsideBlock(rcBlkUpdateCur),
		IMGSYS_RET::ISR_INVBLKRANGE);

	// Set update flag
	//Logger::Log0("ImgLevel::SetUpdateFlag: " "To-'" + (string)(bUpdate ? "true":"false") + '\'' +
	//	"rcBlkIdx:" + rcBlkIdxCur.ToString());
	for(idxblk y = rcBlkUpdateCur.top; y <= rcBlkUpdateCur.bottom; ++y)
	{
		for(idxblk x = rcBlkUpdateCur.left; x <= rcBlkUpdateCur.right; ++x)
		{
			_blocks[y][x].SetUpdateFlag(bUpdate);
		}
	}

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::SetInitLoadFlag() const
{
	// ======>> LOCK IREAD <<=======
	IMGLEVEL_LOCKIREAD_INTERNAL;
	// Validate status
	if(!IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	idxblk nBlockX = _blocker.GetNBlockX();
	idxblk nBlockY = _blocker.GetNBlockY();

	for(idxblk y = 0; y < nBlockY; ++y)
	{
		for(idxblk x = 0; x < nBlockX; ++x)
		{
			_blocks[y][x].SetInitLoadFlag(true);
		}
	}

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::ExtractInitLoadRegionRow(
	IRECT &rcBlkLoad,
	scope_guard &scgRecoverFlag, bool &bRemain,
	ms_t1 msTimeoutLock) const
{
	// ======>> LOCK IREAD <<=======
	int retLock = -1;
	IMGLEVEL_LOCKIREADT_INTERNAL(msTimeoutLock, retLock);
	RETVAL_ON_NP(
		retLock,
		IMGSYS_RET::ISR_LOCKFAIL);

	return ExtractInitLoadRegionRowInternal(rcBlkLoad, scgRecoverFlag, bRemain);
}

iret ImgLevel::InitLoadBlock(
	const ImgBuf &imgBuf,
	const IPOINT &ptBlkLoad,
	ms_t1 msTimeoutLock)
{
	// ======>> LOCK READ <<=======
	int retLock = -1;
	IMGLEVEL_LOCKREADT_INTERNAL(msTimeoutLock, retLock);
	RETVAL_ON_NP(
		retLock,
		IMGSYS_RET::ISR_LOCKFAIL);

	// Get load rect
	IRECT rcBlkLoad = IRECT::FromTLBR(ptBlkLoad, ptBlkLoad);

	// Set blocks data
	RET_ON_NEG(
		InitLoadBlocksInternal(imgBuf, rcBlkLoad, msTimeoutLock));

	PostUpdate(IMGLEVEL_STATUS::LLS_PARTLOAD);

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::InitLoadBlocks(
	const ImgBuf &imgBuf,
	const IRECT &rcBlkLoad,
	ms_t1 msTimeoutLock)
{
	// ======>> LOCK READ <<=======
	int retLock = -1;
	IMGLEVEL_LOCKREADT_INTERNAL(msTimeoutLock, retLock);
	RETVAL_ON_NP(
		retLock,
		IMGSYS_RET::ISR_LOCKFAIL);

	// Set blocks data
	RET_ON_NEG(
		InitLoadBlocksInternal(imgBuf, rcBlkLoad, msTimeoutLock));

	PostUpdate(IMGLEVEL_STATUS::LLS_PARTLOAD);

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::UpdateSamplingMerged(
	ImgLevel &lvlBase, vector<IRECT> &vecRCUpdate, bool &bRemain,
	ms_t1 msTimeoutLock) 
{
	// Clear out vec
	vecRCUpdate.clear();

	// ======>> LOCK READ OTHER <<=======
	int retLock = -1;
	IMGLEVEL_LOCKREADOTHERT_INTERNAL(lvlBase, msTimeoutLock, retLock);
	RETVAL_ON_NP(
		retLock,
		IMGSYS_RET::ISR_LOCKFAIL);
	// Validate status
	if(!lvlBase.IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	// ======>> LOCK READ <<=======
	IMGLEVEL_LOCKREADT_INTERNAL(msTimeoutLock, retLock);
	RETVAL_ON_NP(
		retLock,
		IMGSYS_RET::ISR_LOCKFAIL);

	// UpdateSamplingMergedInternal
	iret ret = UpdateSamplingMergedInternal(lvlBase, vecRCUpdate, bRemain, msTimeoutLock);
	RET_ON_NEG(
		ret);

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::Render(
	void* pBuf, iDim wBuf, iDim hBuf, iDim strideBuf,
	iDim xTran, iDim yTran,
	iDim wTarget, iDim hTarget) const
{
	// ASSERTED HERE:
	//  all block render status are already cleared to 'IMGBLOCK_RENDER_STATUS.BRS_NORENDER'
	
	// ======>> LOCK IREAD <<=======
	int retLock = -1;
	IMGLEVEL_TRYLOCKIREAD_INTERNAL(retLock);
	if(retLock <= 0)
	{
		Logger::Log0("ImgLevel::Render: lock failed");
		return IMGSYS_RET::ISR_LOCKFAIL;
	}

	// Validate status
	if(!IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}
	// Validate basic
	if(nullptr == pBuf)
	{
		return IMGSYS_RET::ISR_NULLIMG;
	}
	if(wBuf < 0 || hBuf < 0)
	{
		return IMGSYS_RET::ISR_INVDESTSIZE;
	}
	if(wTarget <= 0 || hTarget <= 0)
	{
		return IMGSYS_RET::ISR_INVRCSRC;
	}

	// Target spec
	IVEC2 sizeTarget = IVEC2(wTarget, hTarget);
	RECTXZ rcTarget = RECTXZ(-xTran, -yTran, wBuf - xTran - 1, hBuf - yTran - 1);

	// Get rendering blocks region
	IRECT rcIdx;
	IRECT rcIdxFull;
	
	IVEC2 vecOffset = IVEC2(-xTran, - yTran);
	arr_divdst vecDivX;
	arr_divdst vecDivY;
	RET_ON_NEG(
		_blocker.SetBlockDestAndGetRegion(
			rcTarget, sizeTarget, vecOffset,
			rcIdx, rcIdxFull, vecDivX, vecDivY));
	
	// Set render status
	idxblk iBlkXF = rcIdx.left;
	idxblk iBlkYF = rcIdx.top;
	idxblk iBlkXR = rcIdx.right;
	idxblk iBlkYR = rcIdx.bottom;
	idxblk iBlkXFE = rcIdxFull.left;
	idxblk iBlkYFE = rcIdxFull.top;
	idxblk iBlkXRE = rcIdxFull.right;
	idxblk iBlkYRE = rcIdxFull.bottom;
	ClearRenderStatus();// Clear first
	if (iBlkXF != iBlkXFE)
	{
		for (idxblk j = iBlkYF; j <= iBlkYR; ++j)
		{
			_blocks[j][iBlkXF].SetRenderStatus(IMGBLOCK_RENDER_STATUS::BRS_MARGIN);
		}
	}
	if (iBlkXR != iBlkXRE)
	{
		for (idxblk j = iBlkYF; j <= iBlkYR; ++j)
		{
			_blocks[j][iBlkXR].SetRenderStatus(IMGBLOCK_RENDER_STATUS::BRS_MARGIN);
		}
	}
	if (iBlkYF != iBlkYFE)
	{
		for (idxblk i = iBlkXF; i <= iBlkXR; ++i)
		{
			_blocks[iBlkYF][i].SetRenderStatus(IMGBLOCK_RENDER_STATUS::BRS_MARGIN);
		}
	}
	if (iBlkYR != iBlkYRE)
	{
		for (idxblk i = iBlkXF; i <= iBlkXR; ++i)
		{
			_blocks[iBlkYR][i].SetRenderStatus(IMGBLOCK_RENDER_STATUS::BRS_MARGIN);
		}
	}
	for (idxblk j = iBlkYFE; j <= iBlkYRE; ++j)
	{
		for (idxblk i = iBlkXFE; i <= iBlkXRE; ++i)
		{
			_blocks[j][i].SetRenderStatus(IMGBLOCK_RENDER_STATUS::BRS_RENDER);
		}
	}


	double xFactor = (double)wTarget / _width;
	//IPPI_INTER_LINEAR.IPPI_INTER_CUBIC
	int interpolation = IPPI_INTER_NN;
	if (xFactor >= 2)
	{
		interpolation = IPPI_INTER_NN;
	}
	else if (xFactor >= 1)
	{
		interpolation = IPPI_INTER_LINEAR;
	}
	else
	{
		interpolation = IPPI_INTER_CUBIC;
	}

	//// [Multi-Thread strategy]
	//vector<boost::thread> vecThr;
	//vector<int> vecThrEnd;
	//for (idxblk j = iBlkYF; j <= iBlkYR; ++j)
	//{
	//	for (idxblk i = iBlkXF; i <= iBlkXR; ++i)
	//	{
	//		vecThrEnd.push_back(0);
	//		int &bEnd = vecThrEnd[vecThrEnd.size() - 1];
	//		int idxBEnd = vecThrEnd.size() - 1;
	//		vecThr.emplace_back(std::bind([&](int i, int j, int k)
	//			{
	//				_blocks[j][i].Render(
	//					pBufDest, wBufDest, hBufDest, strideBuf,
	//					vecDivX[i], vecDivY[j], vecDivX[i + 1], vecDivY[j + 1],
	//					interpolation);
	//				//bEnd = 1;
	//				vecThrEnd[k] = 1;
	//			}, i, j, idxBEnd)
	//			);
	//	}
	//}
	////Logger::Log0("end create render blocks threads");
	///*for(int it = 0; it < vecThr.size(); ++it)
	//{
	//	if(vecThr[it].joinable())
	//	{
	//		vecThr[it].join();
	//	}
	//}*/
	//while(true)
	//{
	//	bool bEnd = true;
	//	for(int ie = 0; ie < vecThrEnd.size(); ++ie)
	//	{
	//		if(vecThrEnd[ie] == 0)
	//		{
	//			bEnd = false;
	//			break;
	//		}
	//	}
	//	if(bEnd)
	//	{
	//		break;
	//	}
	//}
	
	vector<std::pair<idxblk, idxblk>> vecBlk;
	for (idxblk j = iBlkYF; j <= iBlkYR; ++j)
	{
		for (idxblk i = iBlkXF; i <= iBlkXR; ++i)
		{
			vecBlk.emplace_back(std::pair<int, int>(j, i));
		}
	}
	Concurrency::parallel_for(0, (int)(vecBlk.size()), 
		[&](int idx)
			{
				idxblk y = vecBlk[idx].first;
				idxblk x = vecBlk[idx].second;
				_blocks[y][x].Render(
					pBuf, wBuf, hBuf, strideBuf,
					vecDivX[x], vecDivY[y], vecDivX[x + 1], vecDivY[y + 1],
					interpolation);
			}
		);

	// [Origin strategy]
	/*for (idxblk j = iBlkYF; j <= iBlkYR; ++j)
	{
		for (idxblk i = iBlkXF; i <= iBlkXR; ++i)
		{
			_blocks[j][i].Render(
				pBufDest, wBufDest, hBufDest, strideBuf,
				vecDivX[i], vecDivY[j], vecDivX[i + 1], vecDivY[j + 1],
				interpolation);
		}
	}*/

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::Render0(
	void* pBuf, iDim wBuf, iDim hBuf, iDim strideBuf,
	iDim xTran, iDim yTran,
	iDim wTarget, iDim hTarget) const
{
	// ASSERTED HERE:
	//  all block render status are already cleared to 'IMGBLOCK_RENDER_STATUS.BRS_NORENDER'
	
	// ======>> LOCK IREAD <<=======
	int retLock = -1;
	IMGLEVEL_TRYLOCKIREAD_INTERNAL(retLock);
	if(retLock <= 0)
	{
		Logger::Log0("ImgLevel::Render: lock failed");
		return IMGSYS_RET::ISR_LOCKFAIL;
	}

	// Validate status
	if(!IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}
	// Validate basic
	if(nullptr == pBuf)
	{
		return IMGSYS_RET::ISR_NULLIMG;
	}
	if(wBuf < 0 || hBuf < 0)
	{
		return IMGSYS_RET::ISR_INVDESTSIZE;
	}
	if(wTarget <= 0 || hTarget <= 0)
	{
		return IMGSYS_RET::ISR_INVRCSRC;
	}

	// Target spec
	IVEC2 sizeTarget = IVEC2(wTarget, hTarget);
	RECTXZ rcTarget = RECTXZ(-xTran, -yTran, wBuf - xTran - 1, hBuf - yTran - 1);

	// Get rendering blocks region
	IRECT rcIdx;
	IRECT rcIdxFull;
	
	IVEC2 vecOffset = IVEC2(-xTran, - yTran);
	arr_divdst vecDivX;
	arr_divdst vecDivY;
	RET_ON_NEG(
		_blocker.SetBlockDestAndGetRegion(
			rcTarget, sizeTarget, vecOffset,
			rcIdx, rcIdxFull, vecDivX, vecDivY));
	
	// Set render status
	idxblk iBlkXF = rcIdx.left;
	idxblk iBlkYF = rcIdx.top;
	idxblk iBlkXR = rcIdx.right;
	idxblk iBlkYR = rcIdx.bottom;


	double xFactor = (double)wTarget / _width;
	//IPPI_INTER_LINEAR.IPPI_INTER_CUBIC
	int interpolation = IPPI_INTER_NN;
	if (xFactor >= 2)
	{
		interpolation = IPPI_INTER_NN;
	}
	else if (xFactor >= 1)
	{
		interpolation = IPPI_INTER_LINEAR;
	}
	else
	{
		interpolation = IPPI_INTER_CUBIC;
	}

	// [Multi-Thread strategy]
	/*vector<std::pair<idxblk, idxblk>> vecBlk;
	for (idxblk j = iBlkYF; j <= iBlkYR; ++j)
	{
		for (idxblk i = iBlkXF; i <= iBlkXR; ++i)
		{
			vecBlk.emplace_back(std::pair<int, int>(j, i));
		}
	}
	Concurrency::parallel_for(0, (int)(vecBlk.size()), 
		[&](int idx)
			{
				idxblk y = vecBlk[idx].first;
				idxblk x = vecBlk[idx].second;
				_blocks[y][x].Render(
					pBuf, wBuf, hBuf, strideBuf,
					vecDivX[x], vecDivY[y], vecDivX[x + 1], vecDivY[y + 1],
					interpolation);
			}
		);*/

	// [Origin strategy]
	for (idxblk j = iBlkYF; j <= iBlkYR; ++j)
	{
		for (idxblk i = iBlkXF; i <= iBlkXR; ++i)
		{
			_blocks[j][i].Render(
				pBuf, wBuf, hBuf, strideBuf,
				vecDivX[i], vecDivY[j], vecDivX[i + 1], vecDivY[j + 1],
				interpolation);
		}
	}

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgLevel::RenderIllustration(
	void *pBuf, iDim wBuf, iDim hBuf, iDim strideBuf,
	const IVEC2 &sizetarget, const RECTXZ &rcTarget,
	bool bBlocks, bool bClipRegion,
	IMGDISP_ILLUSTRATIONMODE modeIllus) const
{
	// ======>> LOCK IREAD <<=======
	int retLock = -1;
	IMGLEVEL_TRYLOCKIREAD_INTERNAL(retLock);
	if(retLock <= 0)
	{
		return IMGSYS_RET::ISR_LOCKFAIL;
	}
	
	// Validate status
	if(!IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}
	// Validate basic
	if (nullptr == pBuf)
	{
		return IMGSYS_RET::ISR_NULLIMG;
	}
	if(wBuf <= 0 || hBuf <= 0)
	{
		return IMGSYS_RET::ISR_INVDESTSIZE;
	}

	// Divide illustration blocks
	arr_divdst arrDivIllX;
	arr_divdst arrDivIllY;
	iret ret = _blocker.GetBlockDestDivideArray(
		IVEC2(wBuf, hBuf), arrDivIllX, arrDivIllY);
	// Fail to get divide
	if(ret < 0)
	{
		COLOR4B colorErr = RGB_LE(190, 102, 102);

		ImgProcess::Fill_XRGB(
			pBuf, wBuf, hBuf, strideBuf,
			IRECT::FromXYWH(0, 0, wBuf, hBuf), colorErr);

		return IMGSYS_RET::ISR_NULLMEM;
	}
	
	// Render
	if(bBlocks)
	{
		LARGE_INTEGER tick = {0};
		QueryPerformanceCounter(&tick);
		srand((unsigned int)tick.QuadPart);

		COLOR4B colors[3] = {
			RGB_LE(220, 220, 220),
			RGB_LE(160, 204, 132),
			RGB_LE(149, 168, 211)};
		for (idxblk j = 0; j < (idxblk)arrDivIllY.size() - 1; ++j)
		{
			iDim fy = arrDivIllY[j];
			iDim ry = arrDivIllY[j + 1] - 1;
			for (idxblk i = 0; i < (idxblk)arrDivIllX.size() - 1; ++i)
			{
				iDim fx = arrDivIllX[i];
				iDim rx = arrDivIllX[i + 1] - 1;
				iDim wx = rx - fx;

				COLOR4B color = COLOR4B_LE_BLACK;
				if(IMGDISP_ILLUSTRATIONMODE::ILLUS_RENDER == modeIllus)
				{
					size_t idxColor = (size_t)(_blocks[j][i].GetRenderStatus());
					color = colors[idxColor];
				}
				else if(IMGDISP_ILLUSTRATIONMODE::ILLUS_LOAD == modeIllus)
				{
					IMGBLOCK_LOADSTATUS statusBlk = _blocks[j][i].GetStatus_Unsafe();
					IMGBLOCK_DATASTATUS statusDataBlk = _blocks[j][i].GetDataStatus_Unsafe();
					switch (statusBlk)
					{
					case IMGBLOCK_LOADSTATUS::BLS_EMPTY:
						color = COLOR4B_LE_BLACK;
						break;
					case IMGBLOCK_LOADSTATUS::BLS_READY:
						color = RGB_LE(252, 243, 120);
						break;
					case IMGBLOCK_LOADSTATUS::BLS_LIVE:
						break;
					case IMGBLOCK_LOADSTATUS::BLS_OFFLINE:
						break;
					case IMGBLOCK_LOADSTATUS::BLS_SYNC:
						switch (statusDataBlk)
						{
						case IMGBLOCK_DATASTATUS::BDS_EMPTY:
							color = RGB_LE(240, 250, 250);//210, 211, 161
							break;
						case IMGBLOCK_DATASTATUS::BDS_PART:
							color = RGB_LE(200, 220, 160);
							break;
						case IMGBLOCK_DATASTATUS::BDS_FULL:
							color = RGB_LE(160, 200, 80);
							break;
						default:
							break;
						}
						break;
					case IMGBLOCK_LOADSTATUS::BLS_OPENING:
						color = RGB_LE(164, 182, 234);
						break;
					case IMGBLOCK_LOADSTATUS::BLS_LOADING:
						break;
					case IMGBLOCK_LOADSTATUS::BLS_UNLOADING:
						break;
					case IMGBLOCK_LOADSTATUS::BLS_BUILDING:
						color = RGB_LE(186, 207, 81);
						break;
					case IMGBLOCK_LOADSTATUS::BLS_DYING:
						color = RGB_LE(253, 145, 145);
						break;
					case IMGBLOCK_LOADSTATUS::BLS_INITLOADING:
						color = RGB_LE(234, 217, 153);//234, 217, 153
						break;
					case IMGBLOCK_LOADSTATUS::BLS_EDITING:
						color = RGB_LE(160, 210, 250);
						break;
					default:
						break;
					}
				}

				double bias = 8.0 * rand() / RAND_MAX;
				color = RGB_LE(
					COL_PART(R_PART_LE(color) + bias),
					COL_PART(G_PART_LE(color) + bias),
					COL_PART(B_PART_LE(color) + bias));

				ImgProcess::Fill_XRGB(
					pBuf, wBuf, hBuf, strideBuf,
					IRECT(fx, fy, rx, ry), color);
			}
		}
	}

	float alphaBase = 0.8f;
	if(bBlocks)
	{
		alphaBase = 0.3f;
	}
	if (bClipRegion)
	{
		iDim x = 0, y = 0, r = 0, b = 0;
		if (sizetarget.IsZeroNegative())
		{
			return IMGSYS_RET::ISR_INVTARGETSIZE;
		}

		x = max((iDim)((double)(rcTarget.left) / sizetarget.x * wBuf), 0);
		y = max((iDim)((double)(rcTarget.top) / sizetarget.y * hBuf), 0);
		r = min((iDim)ceil((double)(rcTarget.right + 1) / sizetarget.x * wBuf) - 1, wBuf - 1);
		b = min((iDim)ceil((double)(rcTarget.bottom + 1) / sizetarget.y * hBuf) - 1, hBuf - 1);

		iDim w = r - x + 1;
		iDim h = b - y + 1;
		if (!(x >= 0 && y >= 0 &&
			w > 0 && h > 0 &&
			r < wBuf && b < hBuf
			))
		{
			return IMGSYS_RET::ISR_INVRCSRC;
		}

		COLOR4B colorClipBase = RGB_LE(180, 160, 140);
		isize sizeClip = max(1, w * h);
		double colorScale = GetScale_InvProp(
			(double)sizeClip, 0.5, 1.0, 512, 1.0);
		COLOR4B colorClip = RGB_LE(
			R_PART_LE(colorClipBase),
			G_PART_LE(colorClipBase) * colorScale,
			B_PART_LE(colorClipBase) * colorScale);

		dword* pRow = (dword*)pBuf + y * wBuf;
		for (iDim j = y; j <= b; ++j, GO_STRIDE(pRow, strideBuf))
		{
			for (iDim i = x; i <= r; ++i)
			{
				dword c = pRow[i];
				float alpha = 1.0f;
				if (G_PART_LE_PURE(c) > 200)
				{
					alpha = alphaBase;
				}
				pRow[i] = RGB_LE(
					(alpha * R_PART_LE(colorClip) + (1 - alpha) * R_PART_LE(c)),
					(alpha * G_PART_LE(colorClip) + (1 - alpha) * G_PART_LE(c)),
					(alpha * B_PART_LE(colorClip) + (1 - alpha) * B_PART_LE(c))
					);
			}
		}
	}

	return IMGSYS_RET::ISR_SUCCEED;
}

#pragma endregion ImgLevel


#pragma region ImgDisp

bool ImgDisp::__bPrepared = ImgDisp::Prepare();

bool ImgDisp::Prepare()
{
	Logger::Log0("ImgDisp: Prepared");

	__bPrepared = true;
	return __bPrepared;
}

void ImgDisp::InitSettings()
{
	// Set pool name
	_poolInitLoad.SetName("InitLoad");
	_poolUpdateSample.SetName("UpdateSampling");
	_poolReleaseMemory.SetName("ReleaseMemory");

	// Get Temp file dir
	_tmpFileDir = (string)"C:\\" + "Environment\\MMap\\";

	/*char	strTmpPath[MAX_PATH];
	if(0 != GetTempPathA(sizeof(strTmpPath), strTmpPath))
	{
		_tmpFileDir = string(strTmpPath);
	}*/

	/*char *buf = _getcwd_dbg(NULL, 0);
	if(NULL == buf)
	{
		return E_FAIL;
	}
	scope_guard scgCWDBuf(
		[&buf](){
			if(nullptr != buf)
			{
				free(buf);
				buf = nullptr;
			}
		});*/
	//fileName = string(strTmpPath) + "\\MMap" + '\\' + name;
	//fileName = boost::filesystem::initial_path<boost::filesystem::path>().string() + "\\MMap" + '\\' + name;
	
}

const ImgLevel* ImgDisp::GetRenderLevelConst(
	iDim wd, iDim hd) const
{
	const ImgLevel *pLevel = &_level0;
	for (idxlvl i = (idxlvl)_levels.size() - 1; i >= 0; --i)
	{
		if (wd < _levels[i].GetWidth() && hd < _levels[i].GetHeight())
		{
			pLevel = &_levels[i];
			break;
		}
	}

	//double rate = 0.9;
	//if (levels != null)
	//{
	//	for (idxlvl i = 1; i < _levels.size(); ++i)
	//	{
	//		double thre = (rate * levels[i].w * levels[i].w 
	//			+ (1 - rate) * levels[i].w * levels[i - 1].w);
	//		if (wd * wd > thre)
	//		{
	//			level = levels[i - 1];
	//			break;
	//		}
	//	}
	//}
	//double thre0 = (rate * levels[0].w * levels[0].w
	//	+ (1 - rate) * level0.w * level0.w);
	//if (wd * wd > thre0)
	//{
	//	level = level0;
	//}

	return pLevel;
}

const ImgDisp::BLOCKERBASE& ImgDisp::BaseBlockerConst(
	scope_guard &scgBlocker)
{
	return _level0.GetBlockerConst(scgBlocker);
}

inline iret ImgDisp::LockWithStopFlagSet(
	scope_guard &scgLock,
	ms_t1 msTimeoutLock)
{
	// Stop threads stop flag
	SetThreadsStopFlag();

	// ======>> LOCK <<=======
	int retLock = -1;
	retLock = IMGDISP_LOCKSCGT_INTERNAL(scgLock, msTimeoutLock);
	return retLock;
}

iret ImgDisp::ClearInternal()
{
	Logger::Log0("ImgDisp::Clear(): Begin");

	// Status
	_status			= IMGDISP_STATUS::ILS_EMPTY;

	// Worker thread
	WaitAllThreads();
	Logger::Log0("ImgDisp::Clear(): WaitAllThreads");

	_poolInitLoad.Clear();
	_poolUpdateSample.Clear();
	_poolReleaseMemory.Clear();
	Logger::Log0("ImgDisp::Clear(): ThreadPool cleared");

	// Image loader
	_loader.Clear();
	Logger::Log0("ImgDisp::Clear(): Image loader cleared");

	// Levels
	_level0.Clear();
	_levels.clear();
	Logger::Log0("ImgDisp::Clear(): Levels cleared");
	//_levels.swap(vector<ImgLevel>());// let memory released

	// IImgSpec
	IImgSpec::Clear();

	// IImgBuffer
	IImgBuffer::Clear();

	// BiSwap
	_rgROI.Clear();

	// Settings - do not clear
	
	Logger::Log0("ImgDisp::Clear(): Done");

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgDisp::SetupStructure(
	iDim width, iDim height, IMGDISP_PIXELFORMAT format)
{
	RET_ON_NEG(
		IImgSpec::SetSpec(width, height, format));
	
	PostUpdateSpec();

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgDisp::SetupLevels(
	const ImgBuf &imgSrc)
{
	// Level size
	iDim wLvl = _width;
	iDim hLvl = _height;

	IMGDISP_BLOCKSALIGNMODE mBlockAlign = IMGDISP_BLOCKSALIGNMODE::DSBAM_ALIGNED;
	// Setup level#0
	idxlvl idxLevel = 0;
	RET_ON_NEG(
		_level0.SetSettings(_sizeBlock, _store, mBlockAlign, _tmpFileDir));
	RET_ON_NEG(
		_level0.Setup(idxLevel, _format, wLvl, hLvl, imgSrc));
	// Set InitLoad flag
	RET_ON_NEG(
		_level0.SetInitLoadFlag());

	Logger::Log0("ImgDisp::SetupLevels: Level#0 set up");

	// Setup level#n
	_levels.reserve(2);// TODO

	ImgLevel *pLvlLast = &_level0;
	while (!(wLvl < __minLevelSize && hLvl < __minLevelSize)
		|| pLvlLast->GetNBlockX() > 1 || pLvlLast->GetNBlockY() > 1)
	{
		++idxLevel;
		
		_levels.emplace_back(ImgLevel());
		ImgLevel &lvl = _levels.back();
		
		// Set level settings
		RET_ON_NEG(
			lvl.SetSettings(_sizeBlock, _store, mBlockAlign, _tmpFileDir));

		// Setup level
		if(idxLevel > 1)
		{
			pLvlLast = &(_levels[_levels.size() - 2]);
		}
		RET_ON_NEG(
			lvl.Setup(*pLvlLast, wLvl, hLvl));

		Logger::Log0("ImgDisp::SetupLevels: level#" + to_string(idxLevel) + " set up, "
			"wLvl:" + to_string(wLvl) + ", hLvl:" + to_string(hLvl));

		pLvlLast = &(_levels.back());
	}

	return IMGSYS_RET::ISR_SUCCEED;
}

void ImgDisp::PostUpdateSpec()
{
}

void ImgDisp::PostUpdate(
	IMGDISP_STATUS statusToBeSet)
{
	// Update status
	_status = statusToBeSet;
}

iret ImgDisp::SetupInternal(
	iDim width, iDim height, IMGDISP_PIXELFORMAT format,
	const ImgBuf &imgSrc)
{
	// Validate status
	if(IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	// Setup structure
	RET_ON_NEG(
		SetupStructure(width, height, format));

	// Setup levels
	RET_ON_NEG(
		SetupLevels(imgSrc));

	// post update
	PostUpdate(IMGDISP_STATUS::ILS_LOADED);
	
	return IMGSYS_RET::ISR_SUCCEED;
}

void ImgDisp::WaitAllThreads()
{
	Logger::Log0("ImgDisp::WaitAllThreads: Begin");

	// Stop ThreadPool
	//_poolInitLoad.StopTasksAndPool();

	// Stop Loader thread and wait
	_threadInitLoad.StopWait();
	//_threadInitLoad.swap(ThreadStoppable());
	_threadUpdateSample.StopWait();
	
	// Stop ThreadPool and wait
	_poolInitLoad.StopTasksAndPoolWait();
	_poolUpdateSample.StopTasksAndPoolWait();
	_poolReleaseMemory.StopTasksAndPoolWait();

	Logger::Log0("ImgDisp::WaitAllThreads: End");
}

void ImgDisp::SetThreadsStopFlag()
{
	Logger::Log0("ImgDisp::SetThreadsStopFlag");

	// Stop Loader thread
	_threadInitLoad.Stop();
	_threadUpdateSample.Stop();

	// Stop ThreadPool
	_poolInitLoad.StopTasksAndPool();
	_poolUpdateSample.StopTasksAndPool();
	_poolReleaseMemory.StopTasksAndPoolWait();
}

iret ImgDisp::ExtractInitLoadRegionRow(
	IRECT &rcBlkLoad,
	scope_guard &scgRecoverFlag, bool &bRemain,
	ms_t1 msTimeoutLock) const
{
	// ======>> LOCK READ <<=======
	int retLock = -1;
	IMGDISP_LOCKREADT_INTERNAL(msTimeoutLock, retLock);
	RETVAL_ON_NP(
		retLock,
		IMGSYS_RET::ISR_LOCKFAIL);
	
	return ExtractInitLoadRegionRowInternal(rcBlkLoad, scgRecoverFlag, bRemain, msTimeoutLock);
}

void ImgDisp::InitLoadBlockRowTask(
	const IRECT &rcBlkInitLoad, bool bRemain, scope_guard_comp &scgcRecoverInitLoadFlag,
	bool *bInterrupt,
	ms_t1 msTimeoutLock)
{
	const string logH = "ImgDisp::InitLoadBlockRowTask: ";

	Logger::Log0(logH, "====>  Begin  <====");

	// Remained region handler
	if(bRemain)
	{
		Logger::Log0(logH, "Event 'InitLoad' re triggered for remained region");
		_evtInitLoad.Signal();
	}

	//// ScopeGuard for remaining InitLoad event
	//scope_guard scgEventRemain(
	//	[&bRemain, &logH, this](){
	//		if(bRemain)
	//		{
	//			Logger::Log0(logH, "Event 'InitLoad' re triggered for remained region");
	//			_evtInitLoad.Signal();
	//		}}
	//);

	// ScopeGuard for remaining InitLoad
	scope_guard scgRemainedFailed(
		[&logH, this](){
			Logger::Log0(logH, "Event 'InitLoad' re triggered for remained region");
			_evtInitLoad.Signal();
		}
	);

	// ScopeGuard for recover InitLoad flag
	scope_guard scgRecoverInitLoadFlag(std::move(scgcRecoverInitLoadFlag));

	// InitLoadBlocks
	iret ret = InitLoadBlocks(rcBlkInitLoad, bInterrupt, msTimeoutLock);
	if(ret < 0)
	{
		Logger::Log0(logH, "====>  Fail   <====");
		return;
	}

	// Disable ScopeGuard
	scgRecoverInitLoadFlag.Disable();
	scgRemainedFailed.Disable();

	Logger::Log0(logH, "====>  Done   <==== " + rcBlkInitLoad.ToString());
}

void ImgDisp::ThreadInitLoad(
	bool *bInterrupt)
{
	switch (_store)
	{
	case ImgDisplay::IDS_GMAP:
		ThreadInitLoadBlockRow(bInterrupt);
		break;
	case ImgDisplay::IDS_MMAP:
		ThreadInitLoadBlock(bInterrupt);
		break;
	default:
		Logger::Log0("ImgDisp::ThreadInitLoad: Thread not implemented for unknown store mode");
		break;
	}
}

void ImgDisp::ThreadInitLoadBlock(
	bool *bInterrupt)
{
	Logger::Log0("ImgDisp::ThreadInitLoadBlock: Thread-InitLoad begin");

	ms_t1 msTimeoutLock = 100;
	ms_t msSleep = 1;

	while(true)
	{
		// ======>> LOCK IREAD <<=======
		int retLock = -1;
		IMGDISP_LOCKREADT_INTERNAL(msTimeoutLock, retLock);
		if(retLock <= 0)
		{
			// Check stop signal
			if((nullptr != bInterrupt) && *bInterrupt)
			{
				break;
			}

			Sleep(msSleep);
			continue;
		}

		// Validate status
		if(!IsBuilt())
		{
			break;
		}

		// Check stop signal
		if((nullptr != bInterrupt) && *bInterrupt)
		{
			break;
		}
		
		scope_guard scgLockLevel;
		const vector<vector<ImgBlock>> *blocks = _level0.GetBlocksRefConst(scgLockLevel);
		if(nullptr == blocks)
		{
			// Check stop signal
			if((nullptr != bInterrupt) && *bInterrupt)
			{
				break;
			}

			Sleep(msSleep);

			continue;
		}

		for(idxblk iy = 0; iy < blocks->size(); ++iy)
		{
			// Check stop signal
			if((nullptr != bInterrupt) && *bInterrupt)
			{
				break;
			}

			for(idxblk ix = 0; ix < blocks[iy].size(); ++ix)
			{
				// Check stop signal
				if((nullptr != bInterrupt) && *bInterrupt)
				{
					break;
				}

				if(!(*blocks)[iy][ix].IsInitLoadDataStatus_Unsafe())
				{
					Logger::Log0("ImgDisp::ThreadInitLoadBlock: unload block " +
						to_string(iy) + "," + to_string(ix) +
						" found, start loading");

					IPOINT ptIdxBlock = IPOINT(ix, iy);
					
					_poolInitLoad.Commit(
						ThreadPoolStoppable::TaskStoppable(
							std::bind(
								[this, ptIdxBlock](bool *pBInterrupt)
								{
									InitLoadBlock(ptIdxBlock, pBInterrupt, 100);
								},
								std::placeholders::_1)));

					Logger::Log0("ImgDisp::ThreadInitLoadBlock: block " +
						to_string(iy) + "," + to_string(ix) +
						" load finished");
				}

				// Check stop signal
				if((nullptr != bInterrupt) && *bInterrupt)
				{
					break;
				}

				Sleep(msSleep);
			}
		}
		scgLockLevel.Release();

		// Set stop flag
		if(nullptr != bInterrupt)
		{
			*bInterrupt = true;
		}

		// Check stop signal
		if((nullptr != bInterrupt) && *bInterrupt)
		{
			break;
		}

		Sleep(msSleep);
	}

	Logger::Log0("ImgDisp::ThreadInitLoadBlock: Thread-InitLoad end");
}

void ImgDisp::ThreadInitLoadBlockRow(
	bool *bInterrupt)
{
	const string logH = "ImgDisp::ThreadInitLoadBlockRow: ";

	Logger::Log0(logH, "Thread-InitLoad begin");

	ms_t msSleep = 10;
	ms_t msWaitROIChange = 20;
	ms_t msWaitInitLoad = 10;
	s_t sThreadEndCheck = 0;

	Ticker ticker;

	while(true)
	{
		// Wait ROIChange Event
		//Logger::Log0(logH, "Waiting for event 'ROIChange'..");
		int retWait = _evtROIChange.Wait(msWaitROIChange);
		if(retWait >= 0)
		{
			ticker.Start();

			Logger::Log0(logH, "Event 'ROIChange' captured");

			// Check Interrupt Signal
			if((nullptr != bInterrupt) && *bInterrupt)
			{
				break;
			}

			Sleep(msSleep);

			continue;
		}
		
		// Wait InitLoad Event
		retWait = _evtInitLoad.Wait(msWaitInitLoad);
		if(retWait < 0)
		{
			// Check thread end
			if(ticker.Tick() > sThreadEndCheck)
			{
				IRECT rcBlkIdxInitLoad;
				bool bRemain = false;
				scope_guard scgRecoverInitLoadFlag;
				iret ret = ExtractInitLoadRegionRow(rcBlkIdxInitLoad, scgRecoverInitLoadFlag, bRemain, __msTimeoutExtractInitLoadRegion);
				scgRecoverInitLoadFlag.Release();

				if(IMGSYS_RET::ISR_NOTFOUND == (IMGSYS_RET)ret)
				{
					if(_poolInitLoad.TaskCount() == 0)
					{
						_bFullLoaded = true;
					
						// Set stop
						if(nullptr != bInterrupt)
						{
							*bInterrupt = true;
						}

						Logger::Log0(logH, "All rows are init loaded. End Thread 'InitLoad'!");
					}
				}
				ticker.Start();
			}

			// Check Interrupt Signal
			if((nullptr != bInterrupt) && *bInterrupt)
			{
				break;
			}

			Sleep(msSleep);

			continue;
		}

		ticker.Start();

		Logger::Log0(logH, "Event 'InitLoad' captured");
		
		// Check Interrupt Signal
		if((nullptr != bInterrupt) && *bInterrupt)
		{
			break;
		}
#ifdef USE_MERGEDINITLOADTASK
		// Add Task [Strategy #1]
		//_poolInitLoad.Commit(ThreadPoolStoppable::TaskStoppable(
		//	[this](bool *pBInterrupt){
		//		IRECT rcBlkIdxInitLoad;
		//		InitLoadBlockRowTaskMerged(rcBlkIdxInitLoad, pBInterrupt);
		//	}));
		//if(_bFullLoaded)
		//{
		//	Logger::Log0(logH, "All rows are init loaded. Thread end!");
		//	// Set stop
		//	if(nullptr != bInterrupt)
		//	{
		//		*bInterrupt = true;
		//	}
		//}
#else
		// Add InitLoad Task [Strategy #2]
		// Extract region
		IRECT rcBlkIdxInitLoad;
		bool bRemain = false;
		scope_guard scgRecoverInitLoadFlag;
		iret ret = ExtractInitLoadRegionRow(rcBlkIdxInitLoad, scgRecoverInitLoadFlag, bRemain, __msTimeoutExtractInitLoadRegion);
		if(ret > 0)
		{
			// Check Interrupt Signal
			if((nullptr != bInterrupt) && *bInterrupt)
			{
				break;
			}

			// Extract ScopeGuard Component 
			scope_guard_comp scgcRecoverInitLoadFlag(std::move(scgRecoverInitLoadFlag));
	
			// Commit InitLoad Task
			int retCommit = _poolInitLoad.Commit(
				ThreadPoolStoppable::TaskStoppable(
					std::bind(
					[this, rcBlkIdxInitLoad, bRemain, scgcRecoverInitLoadFlag](bool *pBInterrupt) mutable
					{
						InitLoadBlockRowTask(rcBlkIdxInitLoad, bRemain, scgcRecoverInitLoadFlag, pBInterrupt);
					}, std::placeholders::_1)
				)
			);
			// if commit failed
			if(retCommit < 0)
			{
				Logger::Log0(logH, "Task 'InitLoad' commit failed for region " + rcBlkIdxInitLoad.ToString());
				scgRecoverInitLoadFlag.SetFrom(std::move(scgcRecoverInitLoadFlag));
				bRemain = true;
				_evtInitLoad.Signal();
				Logger::Log0(logH, "Event 'InitLoad' re triggered for failed commit");
			}
			else
			{
				Logger::Log0(logH, "1 new Task 'InitLoad' commited, for region" + rcBlkIdxInitLoad.ToString());
			}
		}
		else
		{
			Logger::Log0(logH, "Init Load region not found");
		}
#endif

		// Check Interrupt Signal
		if((nullptr != bInterrupt) && *bInterrupt)
		{
			break;
		}

		Sleep(msSleep);
	}

	// Test
	Test0();

	//_loader.Close();
	//Logger::Log0(logH, "image loader closed");

	Logger::Log0(logH, "Thread-InitLoad end");
}

void ImgDisp::ThreadUpdateSampling(
	bool *bInterrupt)
{
	switch (_store)
	{
	case ImgDisplay::IDS_GMAP:
		ThreadUpdateSamplingBlockRow(bInterrupt);
		break;
	case ImgDisplay::IDS_MMAP:
		ThreadUpdateSamplingBlock(bInterrupt);
		break;
	default:
		Logger::Log0("ImgDisp::ThreadUpdateSampling: Thread not implemented for unknown store mode");
		break;
	}
}

void ImgDisp::ThreadUpdateSamplingBlock(
	bool *bInterrupt) 
{
}

void ImgDisp::ThreadUpdateSamplingBlockRow(
	bool *bInterrupt)
{
	const string logH = "ImgDisp::ThreadUpdateSamplingBlockRow: ";

	Logger::Log0(logH + "Thread-UpdateSampling begin");

	ms_t msSleep = 100;
	ms_t msWait = 100;

	while(true)
	{
		// Wait event
		//Logger::Log0(logH, "Waiting for event 'UpdateSampling'..");
		int ret = _evtUpdateSample.Wait(msWait);
		if(-2 == ret)
		{
			//Logger::Log0(logH, "Wait event 'UpdateSampling' Timeout!");
		}
		else if(ret > 0)
		{
			Logger::Log0(logH, "Event 'UpdateSampling' captured");

			// Add task [Automatic UpdateSampling]
			int retCommit = _poolUpdateSample.Commit(
				ThreadPoolStoppable::TaskStoppable(
					std::bind(
						[this](bool *pBInterrupt)
						{
							UpdateSamplingBlockRowTask(pBInterrupt, __msTimeoutUpdateSamplingTask);
						},
						std::placeholders::_1)));

			if(retCommit < 0)
			{
				Logger::Log0(logH, "Task 'UpdateSampling' commit failed");
			}
			else
			{
				Logger::Log0(logH, "1 new Task 'UpdateSampling' commited");
			}
		}
		
		// Check Interrupt Signal
		if((nullptr != bInterrupt) && *bInterrupt)
		{
			break;
		}

		Sleep(msSleep);
	}
	
	Logger::Log0(logH, "Thread-UpdateSampling end");
}

ImgDisp::ImgDisp():
	IImgSpec			(),
	IImgBuffer			(),
	_lock				(),
	_status				(IMGDISP_STATUS::ILS_EMPTY),
	_loader				(),
	_level0				(),
	_levels				(),
	_evtROIChange		(Event("IMGDISP_EVENT_ROICHANGE" + to_string((int)this))),
	_evtInitLoad		(Event("IMGDISP_EVENT_INITLOAD" + to_string((int)this))),
	_evtUpdateSample	(Event("IMGDISP_EVENT_UPDATESAMPLING" + to_string((int)this))),
	_threadInitLoad		(),
	_threadUpdateSample	(),
	_poolInitLoad		(),
	_poolUpdateSample	(),
	_poolReleaseMemory	(),
	_rgROI				(),
	_store				(IMGDATA_STORAGE::IDS_GMAP),
	_lvlsSample			(IMGDISP_VSAMPLEMODE::LSM_CHAIN),
	_sizeBlock			(IMGDISP_BLOCKSIZE_DEF),
	_colorBufferBkg		(COLOR4B_LE_BLACK),
	_colorBufferIllus	(COLOR4B_LE_BLACK),
	_tmpFileDir			(),
	__maxBlockSize		(IMGDISP_BLOCKSIZEMAX_DEF),
	__defBlockSize		(IMGDISP_BLOCKSIZE_DEF),
	__minLevelSize		(IMGDISP_LEVELSIZEMIN_DEF),
	__msTimeoutExtractInitLoadRegion	(100),
	__msTimeoutUpdateSamplingTask		(100),
	__msTimeoutInitLoadBlockRowTask		(100),
	__msTimeoutOpenImage				(1000)
{
	InitSettings();
}

ImgDisp::ImgDisp(ImgDisp &&disp):
	IImgSpec			(),
	IImgBuffer			(),
	_lock				(),
	_status				(IMGDISP_STATUS::ILS_EMPTY),
	_loader				(),
	_level0				(),
	_levels				(),
	_evtROIChange		(),
	_evtInitLoad		(),
	_evtUpdateSample	(),
	_threadInitLoad		(),
	_threadUpdateSample	(),
	_poolInitLoad		(),
	_poolUpdateSample	(),
	_poolReleaseMemory	(),
	_rgROI				(),
	_store				(IMGDATA_STORAGE::IDS_GMAP),
	_lvlsSample			(IMGDISP_VSAMPLEMODE::LSM_CHAIN),
	_sizeBlock			(IMGDISP_BLOCKSIZE_DEF),
	_colorBufferBkg		(COLOR4B_LE_BLACK),
	_colorBufferIllus	(COLOR4B_LE_BLACK),
	_tmpFileDir			(),
	__maxBlockSize		(IMGDISP_BLOCKSIZEMAX_DEF),
	__defBlockSize		(IMGDISP_BLOCKSIZE_DEF),
	__minLevelSize		(IMGDISP_LEVELSIZEMIN_DEF),
	__msTimeoutExtractInitLoadRegion	(100),
	__msTimeoutUpdateSamplingTask		(100),
	__msTimeoutInitLoadBlockRowTask		(100),
	__msTimeoutOpenImage				(1000)
{
	// Assign
	AssignMove(disp);
}

void ImgDisp::ClearPreAssign()
{
	// Status
	_status				= IMGDISP_STATUS::ILS_EMPTY;
}

void ImgDisp::ClearMove()
{
	// Clear Status first
	_status				= IMGDISP_STATUS::ILS_EMPTY;

	// [IImgSpec, IImgBuffer]
	//IImgSpec
	//IImgBuffer

	// [Image loader]
	//_loader

	// [Levels]
	// Levels
	//_levels.clear();
	_levels.swap(vector<ImgLevel>());// let memory released

	// [Worker thread]
	//_threadInitLoad.swap(_threadInitLoad());

	// [ROI Region Swapper]
	//_rgROI

	// [Settings]
	_store				= IMGDATA_STORAGE::IDS_GMAP;
	_lvlsSample			= IMGDISP_VSAMPLEMODE::LSM_CHAIN;
	_sizeBlock			= IMGDISP_BLOCKSIZE_DEF;
	_colorBufferBkg		= COLOR4B_LE_BLACK;
	_colorBufferIllus	= COLOR4B_LE_BLACK;
	_tmpFileDir			= "";
	__maxBlockSize		= IMGDISP_BLOCKSIZEMAX_DEF;
	__defBlockSize		= IMGDISP_BLOCKSIZE_DEF;
	__minLevelSize		= IMGDISP_LEVELSIZEMIN_DEF;
	__msTimeoutExtractInitLoadRegion	= 100;
	__msTimeoutUpdateSamplingTask		= 100;
	__msTimeoutInitLoadBlockRowTask		= 100;
	__msTimeoutOpenImage				= 1000;

	// Init Settings
	InitSettings();
}

void ImgDisp::Release()
{
	ImgDisp::ClearPreAssign();

	ClearInternal();
}

ImgDisp& ImgDisp::operator = (ImgDisp &&disp)
{
	// Assign
	AssignMove(disp);

	return *this;
}

iret ImgDisp::AssignMove(ImgDisp &disp)
{
	// ======>> LOCK OTHER <<=======
	scope_guard scgLockOther;
	RETVAL_ON_NP(
		disp.LockWithStopFlagSet(scgLockOther),
		IMGSYS_RET::ISR_LOCKFAIL);
	// ======>> LOCK <<=======
	scope_guard scgLock;
	RETVAL_ON_NP(
		LockWithStopFlagSet(scgLock),
		IMGSYS_RET::ISR_LOCKFAIL);

	// Clear before assignment
	ImgDisp::ClearPreAssign();
	
	// Assign
	// [IImgSpec, IImgBuffer]
	IImgSpec::Assign(disp);
	IImgBuffer::AssignMove(disp);
	// [Image loader]
	_loader.AssignMove(std::forward<IMGLOADER>(disp._loader));
	// [Levels]
	_level0.AssignMove(std::forward<ImgLevel>(disp._level0));
	_levels				= std::forward<vector<ImgLevel>>(disp._levels);
	// [Worker thread]
	_evtROIChange		= std::forward<Event>(disp._evtROIChange);
	_evtInitLoad		= std::forward<Event>(disp._evtInitLoad);
	_evtUpdateSample	= std::forward<Event>(disp._evtUpdateSample);
	_threadInitLoad.AssignMove(std::forward<ThreadStoppable>(disp._threadInitLoad));
	_threadUpdateSample.AssignMove(std::forward<ThreadStoppable>(disp._threadUpdateSample));
	_poolInitLoad.AssignMove(std::forward<ThreadPoolStoppable>(disp._poolInitLoad));
	_poolUpdateSample.AssignMove(std::forward<ThreadPoolStoppable>(disp._poolUpdateSample));
	_poolReleaseMemory.AssignMove(std::forward<ThreadPoolStoppable>(disp._poolReleaseMemory));
	// [ROI Region Swapper]
	_rgROI				= std::forward<rg_swapper>(disp._rgROI);
	// [Settings]
	_store				= disp._store;
	_lvlsSample			= disp._lvlsSample;
	_sizeBlock			= disp._sizeBlock;
	_colorBufferBkg		= disp._colorBufferBkg;
	_colorBufferIllus	= disp._colorBufferIllus;
	_tmpFileDir			= std::forward<string>(disp._tmpFileDir);
	__maxBlockSize		= disp.__maxBlockSize;
	__defBlockSize		= disp.__defBlockSize;
	__minLevelSize		= disp.__minLevelSize;
	__msTimeoutExtractInitLoadRegion	= disp.__msTimeoutExtractInitLoadRegion;
	__msTimeoutUpdateSamplingTask		= disp.__msTimeoutUpdateSamplingTask;
	__msTimeoutInitLoadBlockRowTask		= disp.__msTimeoutInitLoadBlockRowTask;
	__msTimeoutOpenImage				= disp.__msTimeoutOpenImage;
	// Assign [Status] last
	_status			= disp._status;

	// ======>> UNLOCK <<=======
	scgLock.Release();

	// Clear after move
	disp.ImgDisp::ClearMove();

	return IMGSYS_RET::ISR_SUCCEED;
}

ImgDisp::~ImgDisp()
{
	// ======>> LOCK <<=======
	scope_guard scgLock;
	LockWithStopFlagSet(scgLock);

	Release();
}

void ImgDisp::SetColorBkg(
	COLOR4B color)
{
	_colorBufferBkg = (color);
}

void ImgDisp::SetColorIllus(
	COLOR4B color)
{
	_colorBufferIllus = (color);
}

ImgDisp::iDim ImgDisp::GetBlockSize() const
{
	return _sizeBlock;
}

iret ImgDisp::SetBlockSize(
	iDim size)
{
	// ======>> LOCK <<=======
	int retLock = -1;
	IMGDISP_TRYLOCK_INTERNAL(retLock);
	if(retLock <= 0)
	{
		Logger::Log0("ImgDisp::SetBlockSize: Failed " + to_string(_sizeBlock));
		return IMGSYS_RET::ISR_LOCKFAIL;
	}

	if (IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	if (size <= INVALID_BLOCKSIZE_DIV || size > __maxBlockSize)
	{
		return IMGSYS_RET::ISR_INVARGS;
	}

	_sizeBlock = size;
	__minLevelSize = _sizeBlock/4;

	_level0.SetBlockSize(_sizeBlock);
	for (idxlvl i = 0; i < (idxlvl)_levels.size(); ++i)
	{
		_levels[i].SetBlockSize(_sizeBlock);
	}
	
	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgDisp::SetStoreMode(
	IMGDATA_STORAGE modeStore)
{
	// ======>> LOCK <<=======
	int retLock = -1;
	IMGDISP_TRYLOCK_INTERNAL(retLock);
	if(retLock <= 0)
	{
		Logger::Log0("ImgDisp::SetStoreMode: Failed " + to_string(_sizeBlock));
		return IMGSYS_RET::ISR_LOCKFAIL;
	}

	// Validate status
	if(IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	_store = modeStore;

	return IMGSYS_RET::ISR_SUCCEED;
}

ImgDisp::iDim ImgDisp::GetWidth()
{
	// ======>> LOCK IREAD<<=======
	IMGDISP_LOCKIREAD_INTERNAL;

	return _width;
}

ImgDisp::iDim ImgDisp::GetHeight()
{
	// ======>> LOCK IREAD<<=======
	IMGDISP_LOCKIREAD_INTERNAL;

	return _height;
}

idepth ImgDisp::GetBytesPerPixel()
{
	// ======>> LOCK IREAD<<=======
	IMGDISP_LOCKIREAD_INTERNAL;

	return _depth;
}

iret ImgDisp::Clear(
	ms_t1 msTimeoutLock)
{
	// ======>> LOCK <<=======
	scope_guard scgLock;
	RETVAL_ON_NP(
		LockWithStopFlagSet(scgLock, msTimeoutLock),
		IMGSYS_RET::ISR_LOCKFAIL);

	ClearInternal();

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgDisp::LoadImageData(
	ImgBuf &imgBuf,
	const IRECT &rcBlkLoad, IRECT &rcLoad,
	bool *bInterrupt)
{
	Logger::Log0("LoadImageData0");
	// Validate status
	if(!IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}
	Logger::Log0("LoadImageData1");

	scope_guard scgBlocker;
	const BLOCKERBASE& blockerBase = BaseBlockerConst(scgBlocker);
	// Validate block index range
	RETVAL_ON_FALSE(
		blockerBase.IsInsideBlock(rcBlkLoad),
		IMGSYS_RET::ISR_INVBLKRANGE);
	
	// Get load range of whole block
	RETVAL_ON_NEG(
		blockerBase.GetBlockEdge(rcBlkLoad, rcLoad),
		IMGSYS_RET::ISR_INVBLKRANGE);
	//RETVAL_ON_TRUE(rcLoad.IsInvalid_Out(_width, _height)
	//	, IMGSYS_RET::ISR_INVBLKRANGE);
	scgBlocker.Release();
	
	Logger::Log0("ImgDisp::LoadImageData: "
		"rcBlkLoad:" + rcBlkLoad.ToString() +
		", rcLoad:" + rcLoad.ToString());

	// Load image
	RET_ON_NEG(
		_loader.ReadXRGB(imgBuf, rcLoad, bInterrupt));
	RETVAL_ON_TRUE(
		!imgBuf.HasData(),
		IMGSYS_RET::ISR_NULLIMG);

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgDisp::InitLoadPartInternal(
	IRECT rcLoadOrigin,
	ms_t1 msTimeoutLock)
{
	// Validate rcLoadOrigin
	rcLoadOrigin.Correct(_width, _height);
	if(rcLoadOrigin.IsInvalid_Out(_width, _height))
	{
		return IMGSYS_RET::ISR_INVRCSRC;
	}

	scope_guard scgBlocker;
	const BLOCKERBASE& blockerBase = BaseBlockerConst(scgBlocker);

	// Load block range
	IRECT rcBlkIdxLoad;
	RETVAL_ON_NEG(
		blockerBase.GetBlockIndex(rcLoadOrigin, rcBlkIdxLoad),
		IMGSYS_RET::ISR_INVBLKRANGE);

	scgBlocker.Release();

	// TODO: extend rcBlkIdxLoad
	//rcBlkIdxLoad.left = 0;
	//rcBlkIdxLoad.right = blockerBase.GetNBlockX() - 1;

	return InitLoadBlocksInternal(rcBlkIdxLoad, nullptr, msTimeoutLock);
}

iret ImgDisp::SetUpdateFlag(
	const IRECT &rcBlkUpdate, bool bUpdate) const
{
	bool bError = false;

	//iret ret = _level0.SetUpdateFlag(rcBlkIdx, true);
	//if(ret < 0)
	//{
	//	bError = true;
	//}

	const bool bLSMChain = (IMGDISP_VSAMPLEMODE::LSM_CHAIN == _lvlsSample);
	for(idxlvl lv = 0; lv < _levels.size(); ++lv)
	{
		iret ret = _levels[lv].SetUpdateFlag(_level0, rcBlkUpdate, true);
		if(ret < 0)
		{
			bError = true;
		}

		if(bLSMChain)
		{
			// If not break, load time will increase?
			//break;
		}
	}

	return bError ? IMGSYS_RET::ISR_FAIL : IMGSYS_RET::ISR_SUCCEED;
}

// Set Update flag from level#lv, where rcBlkIdx is update region of level#(lv - 1)
iret ImgDisp::SetUpdateFlagRemaining(const IRECT &rcBlkUpdate, idxlvl lv) const
{
	// Validate basic
	if(lv <= 0)
	{
		return IMGSYS_RET::ISR_INVARGS;
	}
	
	// Set update flag of remaining levels
	bool bError = false;
	const ImgLevel &lvlBase = _levels[lv - 1];// base level
	for(; lv < _levels.size(); ++lv)
	{
		iret ret = _levels[lv].SetUpdateFlag(lvlBase, rcBlkUpdate, true);
		if(ret < 0)
		{
			bError = true;
		}
		break;
	}

	return bError ? IMGSYS_RET::ISR_FAIL : IMGSYS_RET::ISR_SUCCEED;
}

iret ImgDisp::UpdateSamplingMergedInternal(
	bool &bRemainLevel, bool *bInterrupt,
	ms_t1 msTimeoutLock)
{
	// Validate status
	if(!IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}


	// Base level info
	const bool bLSMChain = (IMGDISP_VSAMPLEMODE::LSM_CHAIN == _lvlsSample);
	ImgLevel *lvBase = &_level0;
	IRECT rcBlkIdxUpdate;

	// Update sampling of upper levels
	for(idxlvl lv = 0; lv < _levels.size(); ++lv)
	{
		// ScopeGuard for remain
		bool bRemain = false;
		scope_guard scgRemain(
			[&bRemain, &bRemainLevel](){
				if(bRemain)
				{
					bRemainLevel = true;
				}
			});

		// UpdateSampling
		vector<IRECT> vecRCUpdate;
		iret ret = _levels[lv].UpdateSamplingMerged(*lvBase, vecRCUpdate, bRemain, msTimeoutLock);
		
		// If failed updatesampling(TODO: not needed)
		//if(ret < 0)
		//{
		//	if(bLSMChain)
		//	{
		//		if(lv > 0)
		//		{
		//			if(!rcBlkIdxUpdate.IsInvalid_Neg())
		//			{
		//				while(true)
		//				{
		//					if(SetUpdateFlagRemaining(rcBlkIdxUpdate, lv) >= 0)
		//					{
		//						break;
		//					}
		//				
		//					Logger::Log0("ImgDisp::UpdateSamplingMergedInternal: Fail to set remaining update flag, continue trying..");
		//					Sleep(100);
		//				}
		//			}
		//		}

		//		bRemain = true;// set remain flag
		//		Logger::Log0("ImgDisp::UpdateSamplingMergedInternal: Fail to update sampling of Level#" + to_string(lv + 1));

		//		continue;
		//	}
		//}

		if(lv >= _levels.size())
		{
			break;
		}

		// Update flag if chain mode
		if(bLSMChain)
		{
			if(vecRCUpdate.size() > 0)
			{
				rcBlkIdxUpdate = vecRCUpdate[0];
				idxlvl lvNext = lv + 1;
				if(lvNext < _levels.size())
				{
					_levels[lvNext].SetUpdateFlag(_levels[lv], rcBlkIdxUpdate, true);
				}
			}
		}

		// Basic level
		if(bLSMChain)
		{
			lvBase = &(_levels[lv]);
		}

		// Check Interrupt Signal
		if(nullptr != bInterrupt && *bInterrupt)
		{
			return IMGSYS_RET::ISR_INTERRUPT;
		}
	}

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgDisp::UpdateSamplingMerged(
	bool &bRemainLevel, bool *bInterrupt,
	ms_t1 msTimeoutLock)
{
	// ======>> LOCK READ <<=======
	int retLock = -1;
	IMGDISP_LOCKREADT_INTERNAL(msTimeoutLock, retLock);
	RETVAL_ON_NP(
		retLock,
		IMGSYS_RET::ISR_LOCKFAIL);

	return UpdateSamplingMergedInternal(bRemainLevel, bInterrupt, msTimeoutLock);
}

void ImgDisp::UpdateSamplingBlockRowTask(
	bool *bInterrupt,
	ms_t1 msTimeoutLock)
{
	const string logH = "ImgDisp::UpdateSamplingBlockRowTask: ";
	
	Logger::Log0(logH, "====>  Begin  <====");
	
	// Scopeguard for remaining UpdateSampling
	bool bRemainLevel = false;
	/*scope_guard scgRemainUpdateSamplingEvent(
		[&bRemainLevel, &logH, this](){
			if(bRemainLevel)
			{
				_evtUpdateSample.Signal();
				Logger::Log0(logH, "Update Sampling Event triggered for remaining region to be updated sampling");
			}
		});*/

	// UpdateSampling
	iret ret = UpdateSamplingMerged(bRemainLevel, bInterrupt, msTimeoutLock);
	if(ret < 0)
	{
		Logger::Log0(logH, "====>  Fail   <====");
		return;
	}

	Logger::Log0(logH, "====>  Done   <====");
}

iret ImgDisp::ExtractInitLoadRegionRowInternal(
	IRECT &rcBlkLoad,
	scope_guard &scgRecoverFlag, bool &bRemain,
	ms_t1 msTimeoutLock) const
{
	// Validate status
	if(!IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	return _level0.ExtractInitLoadRegionRow(rcBlkLoad, scgRecoverFlag, bRemain, msTimeoutLock);
}

iret ImgDisp::InitLoadBlockInternal(
	const IPOINT &ptBlkLoad, bool *bInterrupt,
	ms_t1 msTimeoutLock)
{
	const string logH = "ImgDisp::InitLoadBlockInternal: ";

	Ticker ticker0;
	ticker0.Start();
	Ticker ticker;
	ticker.Start();

	// Validate status
	if(!IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	// Get Load region
	IRECT rcBlkLoad = IRECT::FromPWH(ptBlkLoad, 1, 1);
	Logger::Log0(logH, "Load region:"
		"(" + to_string(ptBlkLoad.x) + "," + to_string(ptBlkLoad.y) + "), " +
		rcBlkLoad.ToString());

	// Load image
	ImgBuf imgBuf;
	IRECT rcLoad;
	RET_ON_NEG(
		LoadImageData(imgBuf, rcBlkLoad, rcLoad, bInterrupt));
	Logger::Log0(logH, "Load image range data done" "[" + to_string(ticker.Cycle()) + "]");

	// Check Interrupt Signal
	if(nullptr != bInterrupt && *bInterrupt)
	{
		return IMGSYS_RET::ISR_INTERRUPT;
	}

	// Set level#0 data
	RET_ON_NEG_AND(
		_level0.InitLoadBlocks(imgBuf, rcBlkLoad, msTimeoutLock),
		Logger::Log0(logH, "Fail to Set level#0 data"););
	Logger::Log0(logH, "Set Level#0 blocks data done" "[" + to_string(ticker.Cycle()) + "]");

	// Post Blocks update
	PostBlocksUpdate(rcBlkLoad);

	// Check Interrupt Signal
	if(nullptr != bInterrupt && *bInterrupt)
	{
		return IMGSYS_RET::ISR_INTERRUPT;
	}

	// Release image
	//imgBuf.Clear();
	scope_guard_comp scgComp;
	if(imgBuf.ExtractScgComp(scgComp) > 0)
	{
		_poolReleaseMemory.Commit(
			ThreadPoolStoppable::TaskStoppable(
			[scgComp](bool *pInterrupt) mutable{
				scope_guard scgImg(std::move(scgComp));
			}));
	}

	Logger::Log0(logH, "Done" "[" + to_string(ticker0.Tick()) + "]");

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgDisp::InitLoadBlocksInternal(
	const IRECT &rcBlkLoad, bool *bInterrupt,
	ms_t1 msTimeoutLock)
{
	const string logH = "ImgDisp::InitLoadBlocksInternal: ";

	Logger::Log0(logH, "Begin. rcLoadBlkIdx:" + rcBlkLoad.ToString());
	Ticker ticker0;
	ticker0.Start();
	Ticker ticker;
	ticker.Start();

	// Validate status
	if(!IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	// Load image
	ImgBuf imgBuf;
	IRECT rcLoad;
	RET_ON_NEG(
		LoadImageData(imgBuf, rcBlkLoad, rcLoad, bInterrupt));
	Logger::Log0(logH, "Load image range data done" "[" + to_string(ticker.Cycle()) + "]");
	
	// Check Interrupt Signal
	if(nullptr != bInterrupt && *bInterrupt)
	{
		return IMGSYS_RET::ISR_INTERRUPT;
	}

	// Set level#0 data
	RET_ON_NEG_AND(
		_level0.InitLoadBlocks(imgBuf, rcBlkLoad, msTimeoutLock),
		Logger::Log0(logH, "Fail to Set level#0 data"););
	//Logger::Log0(logH, "InitLoad Level#0 blocks data done" ", region:" + rcBlkLoad.ToString() + ", "
	//	"[" + to_string(ticker.Cycle()) + "]");

	// Post Blocks update
	PostBlocksUpdate(rcBlkLoad);

	// Check Interrupt Signal
	if(nullptr != bInterrupt && *bInterrupt)
	{
		return IMGSYS_RET::ISR_INTERRUPT;
	}

	// Release image
	//imgBuf.Clear();
	scope_guard_comp scgComp;
	if(imgBuf.ExtractScgComp(scgComp) > 0)
	{
		_poolReleaseMemory.Commit(
			ThreadPoolStoppable::TaskStoppable(
			[scgComp](bool *pInterrupt) mutable{
				scope_guard scgImg(std::move(scgComp));
			}));
	}

	Logger::Log0(logH, "Done [" + to_string(ticker0.Tick()) + "]");

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgDisp::PostBlocksUpdate(
	const IRECT &rcBlkUpdate)
{
	// Update flag
	SetUpdateFlag(rcBlkUpdate, true);

	// Invalidate

	// Event
	_evtUpdateSample.Signal();
	Logger::Log0("ImgDisp::PostBlocksUpdate: " "Update flag set for region" +
		rcBlkUpdate.ToString() + ", and Event 'UpdateSampling' triggered");

	// Update Sampling
	//RET_ON_NEG_AND(
	//	UpdateSamplingBlockRowTask(nullptr),
	//	Logger::Log0("ImgDisp::PostBlocksUpdate: Fail to Update Sampling"););

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgDisp::OpenImage(
	const string &file,
	const RECTXB &rcInitLoad,
	ms_t1 msTimeoutLock)
{
	Logger::Log0("ImgDisp::OpenImage: Load File '" + file + "'");
	
	// ======>> LOCK <<=======
	scope_guard scgLock;
	RETVAL_ON_NP_AND(
		LockWithStopFlagSet(scgLock, msTimeoutLock),
		IMGSYS_RET::ISR_LOCKFAIL,
		Logger::Log0("ImgDisp::OpenImage: Lock Failed!"););

	// Clear if built
	if(HasImage())
	{
		ClearInternal();
	}

	Ticker ticker0;
	ticker0.Start();
	Ticker ticker;
	ticker.Start();

	// Open file
	iret ret = _loader.Open(file);
	if(!_loader.IsOpen())
	{
		return IMGSYS_RET::ISR_OPENFAIL;
	}

	// Get base info
	iDim wImg = _loader.GetImgWidth();
	iDim hImg = _loader.GetImgHeight();
	IMGDISP_PIXELFORMAT format = IMGDISP_PIXELFORMAT::IPF_BGR32;

	// Setup ThreadPool
	// CRASH if nThread > 1
	RETVAL_ON_NEG_AND(
		_poolInitLoad.Set(1),
		IMGSYS_RET::ISR_FAIL,
		Logger::Log0("ImgDisp::OpenImage: Failed! Set InitLoad threadPool failed"););
	RETVAL_ON_NEG_AND(
		_poolInitLoad.SetNTaskMax(2),
		IMGSYS_RET::ISR_FAIL,
		Logger::Log0("ImgDisp::OpenImage: Failed! Set InitLoad threadPool settings failed"););
	Logger::Log0("ImgDisp::OpenImage: Thread Pool-'InitLoad' set");
	RETVAL_ON_NEG_AND(
		_poolUpdateSample.Set(8),
		IMGSYS_RET::ISR_FAIL,
		Logger::Log0("ImgDisp::OpenImage: Failed! Set UpdateSampling threadPool failed"););
	RETVAL_ON_NEG_AND(
		_poolReleaseMemory.Set(2),
		IMGSYS_RET::ISR_FAIL,
		Logger::Log0("ImgDisp::OpenImage: Failed! Set ReleaseMemory threadPool failed"););
	Logger::Log0("ImgDisp::OpenImage: Thread Pool-'UpdateSampling' set");

	// Init levels
	RET_ON_NEG_AND(
		SetupInternal(wImg, hImg, format),
		Logger::Log0("ImgDisp::OpenImage: Failed! SetupInternal failed"););
	Logger::Log0("ImgDisp::OpenImage: Image strcuture built"
		"[" + to_string(ticker.Cycle()) + "]");

	// Load part image
	if(InitLoadPartInternal(
		IRECT(rcInitLoad.left, rcInitLoad.top, rcInitLoad.right, rcInitLoad.bottom), msTimeoutLock) < 0)
	{
		Logger::Log0("ImgDisp::OpenImage: Something error in InitLoadPartInternal");
	}
	else
	{
		Logger::Log0("ImgDisp::OpenImage: Initial Image range loaded"
			"[" + to_string(ticker.Cycle()) + "]");
	}
	//loader.Close();

	// Start loader thread
	RETVAL_ON_NEG_AND(
		_threadInitLoad.Set(boost::bind(&ImgDisp::ThreadInitLoadBlockRow, this, _1)),
		IMGSYS_RET::ISR_FAIL,
		Logger::Log0("ImgDisp::OpenImage: Failed! Set InitLoad worker thread failed"););
	RETVAL_ON_NEG_AND(
		_threadUpdateSample.Set(boost::bind(&ImgDisp::ThreadUpdateSampling, this, _1)),
		IMGSYS_RET::ISR_FAIL,
		Logger::Log0("ImgDisp::OpenImage: Failed! Set UpdateSampling worker thread failed"););
	// TODO signal InitLoad event
	_evtInitLoad.Signal();

	Logger::Log0("ImgDisp::OpenImage: Done" "[" + to_string(ticker0.Cycle()) + "]" + "\n");

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgDisp::OpenImage(
	const string &file,
	ms_t1 msTimeoutLock)
{
	// Get image size
	IMGLOADER loader;
	iret ret = loader.Open(file);
	if(!loader.IsOpen())
	{
		return IMGSYS_RET::ISR_OPENFAIL;
	}
	iDim wImg = loader.GetImgWidth();
	iDim hImg = loader.GetImgHeight();

	// Set load region
	iDim wLoad = wImg;
	wLoad = min(wImg, _sizeBlock);
	iDim hLoad = hImg;
	hLoad = min(hImg, _sizeBlock);
	
	// Load image range
	return OpenImage(
		file,
		RECTXB::FromXYWH(0, 0, wLoad, hLoad),
		msTimeoutLock);

	// Load image
	//void *pImg = nullptr;
	//ret = _loader.ReadAllXRGB(pImg);
	//scope_guard scgImg(std::bind(funcScopeGuardNewList, pImg));
	//if(ret < 0)
	//{
	//	switch (ret)
	//	{
	//	case -5:
	//		return IMGSYS_RET::ISR_ALLOCFAIL;
	//	default:
	//		return IMGSYS_RET::ISR_LOADFAIL;
	//	}
	//}

	//// Get base info
	//_loader.Close();
	//iDim wImg = _loader.GetImgWidth();
	//iDim hImg = _loader.GetImgHeight();
	//itride strideImg = CalcStride(4, wImg);
	//IMGDISP_PIXELFORMAT format = IMGDISP_PIXELFORMAT::BGR32;
	//Logger::Log0("ImgDisp::OpenImage: read whole image done, ret code: " + to_string((_Longlong)ret));

	//// Set image
	//RET_ON_NEG(
	//	SetupInternal(wImg, hImg, format, pImg, wImg, hImg, strideImg));

	//Logger::Log0("ImgDisp::OpenImage: succeeded");
}

iret ImgDisp::InitLoadBlock(
	const IPOINT &ptBlkLoad, bool *bInterrupt,
	ms_t1 msTimeoutLock)
{
	// ======>> LOCK READ <<=======
	int retLock = -1;
	IMGDISP_LOCKREADT_INTERNAL(msTimeoutLock, retLock);
	RETVAL_ON_NP(
		retLock,
		IMGSYS_RET::ISR_LOCKFAIL);

	return InitLoadBlockInternal(ptBlkLoad, bInterrupt, msTimeoutLock);
}

iret ImgDisp::InitLoadBlocks(
	const IRECT &rcBlkLoad, bool *bInterrupt,
	ms_t1 msTimeoutLock)
{
	// ======>> LOCK READ <<=======
	int retLock = -1;
	IMGDISP_LOCKREADT_INTERNAL(msTimeoutLock, retLock);
	RETVAL_ON_NP(
		retLock,
		IMGSYS_RET::ISR_LOCKFAIL);

	return InitLoadBlocksInternal(rcBlkLoad, bInterrupt, msTimeoutLock);
}

iret ImgDisp::Render(
	void *pBuf, iDim wBuf, iDim hBuf, iDim strideBuf,
	iDim xTran, iDim yTran,
	iDim wTargetImg, iDim hTargetImg) const
{
	// ======>> LOCK IREAD <<=======
	int retLock = -1;
	IMGDISP_TRYLOCKIREAD_INTERNAL(retLock);
	if(retLock <= 0)
	{
		return IMGSYS_RET::ISR_LOCKFAIL;
	}

	// Validate self
	if(!HasImage())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	// Validate basic
	if (nullptr == pBuf)
	{
		return IMGSYS_RET::ISR_NULLIMG;
	}
	if (wBuf <= 0 || hBuf <= 0)
	{
		return IMGSYS_RET::ISR_INVDESTSIZE;
	}
	if (wTargetImg <= 0 || hTargetImg <= 0)
	{
		return IMGSYS_RET::ISR_INVTARGETSIZE;
	}

	//
	// ASSERTED HERE:
	//  all the invalidate param situations are handled
	//  render status can be cleared
	// ASSERTED HERE:
	//  wTargetImg, hTargetImg >= 0
	//  wImg, hImg >= 0, pImg not null

	// Choose level
	const ImgLevel *pLevel = GetRenderLevelConst(wTargetImg, hTargetImg);
	if (nullptr == pLevel)
	{
		return IMGSYS_RET::ISR_NULLLVL;
	}

	//
	// Get ROI
	//
	iDimZ xTarget = -xTran;
	iDimZ yTarget = -yTran;
	iDimZ rTarget = wBuf - xTran - 1;// No overflow judgement
	iDimZ bTarget = hBuf - yTran - 1;

	// Validate rcTarget
	IMGREGION ir = IMGREGION(wTargetImg, hTargetImg,
		xTarget, yTarget, rTarget, bTarget);
	if(ir.Invalid())
	{
		return IMGSYS_RET::ISR_INVRCSRC;
	}

	// Store ROI
	int retSetROI = _rgROI.TrySet(ir);
	if(retSetROI <= 0)
	{
		Logger::Log0("ImgDisp::Render: Try set ROI failed!");
	}

	// Calculate dest
	iDim xDest = xTran;
	iDim yDest = yTran;
	iDim rDest = xTran + wTargetImg - 1;
	iDim bDest = yTran + hTargetImg - 1;

	// bOut
	bool bOutX = ((xTran >= wBuf) || XOverflow<iDim>::AddLE(xTran, wTargetImg - 1, 0));
	bool bOutY = ((yTran >= hBuf) || XOverflow<iDim>::AddLE(yTran, hTargetImg - 1, 0));

	// Validate outside >> Overflow <<
	if (bOutX || bOutY)
	{
		pLevel->ClearRenderStatus();
		ImgProcess::Clear_XRGB(pBuf, wBuf, hBuf, strideBuf, _colorBufferBkg);
		RenderEdgeIllustration(
			pBuf, wBuf, hBuf, strideBuf,
			xTran, yTran,
			wTargetImg, hTargetImg);
		return IMGSYS_RET::ISR_NOOPERATION;
	}

	// Clear background
	ImgProcess::FillExclude_XRGB(
		pBuf, wBuf, hBuf, strideBuf,
		_colorBufferBkg,
		xDest, yDest, rDest, bDest);

	// Render
	iret ret = pLevel->Render(
		pBuf, wBuf, hBuf, strideBuf,
		xTran, yTran,
		wTargetImg, hTargetImg);

	RenderEdgeIllustration(
		pBuf, wBuf, hBuf, strideBuf,
		xTran, yTran,
		wTargetImg, hTargetImg);

	return ret;
}

iret ImgDisp::RenderEdgeIllustration(
	void *pBuf, iDim wBuf, iDim hBuf, iDim strideBuf,
	iDim xTran, iDim yTran,
	iDim wTargetImg, iDim hTargetImg) const
{
	// Calculate dest
	iDim xDest = xTran;
	iDim yDest = yTran;
	iDim rDest = xTran + wTargetImg - 1;
	iDim bDest = yTran + hTargetImg - 1;

	// Render edge illustration
	const int margin = 8;
	bool bMOutL = XOverflow<iDim>::AddOF(xDest, -margin);
	bool bMOutT = XOverflow<iDim>::AddOF(yDest, -margin);
	bool bMOutR = XOverflow<iDim>::AddOF(xTran, wTargetImg - 1) || XOverflow<iDim>::AddOF(rDest, margin);
	bool bMOutB = XOverflow<iDim>::AddOF(yTran, hTargetImg - 1) || XOverflow<iDim>::AddOF(bDest, margin);

	int radius = 4;
	COLOR4B color = RGB_LE(180, 220, 160);
	if(!bMOutT)
	{
		if(!bMOutL)
		{
			IPOINT ptLT = IPOINT(xDest - margin, yDest - margin);
			ImgProcess::Circle_XRGB(pBuf, wBuf, hBuf, strideBuf, ptLT, radius, color);
		}
		if(!bMOutR)
		{
			IPOINT ptRT = IPOINT(rDest + margin, yDest - margin);
			ImgProcess::Circle_XRGB(pBuf, wBuf, hBuf, strideBuf, ptRT, radius, color);
		}
	}
	if(!bMOutB)
	{
		if(!bMOutL)
		{
			IPOINT ptLB = IPOINT(xDest - margin, bDest + margin);
			ImgProcess::Circle_XRGB(pBuf, wBuf, hBuf, strideBuf, ptLB, radius, color);
		}
		if(!bMOutR)
		{
			IPOINT ptRB = IPOINT(rDest + margin, bDest + margin);
			ImgProcess::Circle_XRGB(pBuf, wBuf, hBuf, strideBuf, ptRB, radius, color);
		}
	}

	return IMGSYS_RET::ISR_SUCCEED;
}

iret ImgDisp::Render0(
	void *pBuf, iDim wBuf, iDim hBuf, iDim strideBuf,
	iDimZ xTarget, iDimZ yTarget,
	iDim wTargetImg, iDim hTargetImg, double zoom) const
{
	// ======>> LOCK IREAD <<=======
	int retLock = -1;
	IMGDISP_TRYLOCKIREAD_INTERNAL(retLock);
	if(retLock <= 0)
	{
		return IMGSYS_RET::ISR_LOCKFAIL;
	}

	// Validate self
	if(!HasImage())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	//
	// Validate basic
	//
	if (nullptr == pBuf)
	{
		return IMGSYS_RET::ISR_NULLIMG;
	}
	if (wBuf <= 0 || hBuf <= 0)
	{
		return IMGSYS_RET::ISR_INVDESTSIZE;
	}
	if (wTargetImg <= 0 || hTargetImg <= 0)
	{
		return IMGSYS_RET::ISR_INVTARGETSIZE;
	}

	//
	// ASSERTED HERE:
	//  all the invalidate param situations are handled
	//  render status can be cleared
	// ASSERTED HERE:
	//  wTargetImg, hTargetImg >= 0
	//  wImg, hImg >= 0, pImg not null
	iDim z = (iDim)zoom;
	// >> Oveflow <<
	if(XOverflow<iDim>::MulOF(wTargetImg, z) || XOverflow<iDim>::MulOF(hTargetImg, z))
	{
		Logger::Log0("Oveflow TargetImg size z");
		ImgProcess::Clear_XRGB(pBuf, wBuf, hBuf, strideBuf, _colorBufferBkg);
		return IMGSYS_RET::ISR_OVERFLOW;
	}
	wTargetImg *= z;
	hTargetImg *= z;

	//
	// Choose level
	//
	const ImgLevel *pLevel = GetRenderLevelConst(wTargetImg, hTargetImg);
	if (nullptr == pLevel)
	{
		return IMGSYS_RET::ISR_NULLLVL;
	}
	// Clear render status
	pLevel->ClearRenderStatus();

	//
	// Get ROI
	//
	// >> Oveflow [xyTarget*z] <<
	if(XOverflow<iDimZ>::MulOF(-xTarget, z) || XOverflow<iDimZ>::MulOF(-yTarget, z))
	{
		Logger::Log0("Oveflow -xTarget z" + to_string(xTarget) +
			"," + to_string(z));
		ImgProcess::Clear_XRGB(pBuf, wBuf, hBuf, strideBuf, _colorBufferBkg);
		return IMGSYS_RET::ISR_OVERFLOW;
	}
	//iDimZ xTarget = -xTran;
	//iDimZ yTarget = -yTran;
	iDimZ xTran = (-xTarget * z + wBuf / 2);
	iDimZ yTran = (-yTarget * z + hBuf / 2);
	iDimZ rTarget = wBuf - xTran - 1;
	iDimZ bTarget = hBuf - yTran - 1;

	// Validate outside
	bool bOutX = ((xTran >= wBuf) || (xTran + wTargetImg <= 0));
	bool bOutY = ((yTran >= hBuf) || (yTran + hTargetImg <= 0));
	if (bOutX || bOutY)
	{
		ImgProcess::Clear_XRGB(pBuf, wBuf, hBuf, strideBuf, _colorBufferBkg);
		return IMGSYS_RET::ISR_NOOPERATION;
	}

	// Calculate dest
	iDimZ xDest = xTran;
	iDimZ yDest = yTran;
	iDimZ rDest = xTran + wTargetImg - 1;
	iDimZ bDest = yTran + hTargetImg - 1;

	// Clear background
	ImgProcess::FillExclude_XRGB<iDimZ>(
		pBuf, wBuf, hBuf, strideBuf,
		_colorBufferBkg,
		xDest, yDest, rDest, bDest);

	// Render
	iret ret = pLevel->Render0(
		pBuf, wBuf, hBuf, strideBuf,
		xTran, yTran,
		wTargetImg, hTargetImg);

	return ret;
}

iret ImgDisp::RenderIllustration(
	void *pImg, iDim wImg, iDim hImg, iDim strideImg,
	bool bBlocks, bool bClipRegion,
	IMGDISP_ILLUSMODE modeIllus) const
{
	// ======>> LOCK IREAD <<=======
	int retLock = -1;
	IMGDISP_TRYLOCKIREAD_INTERNAL(retLock);
	if(retLock <= 0)
	{
		ImgProcess::Clear_XRGB(pImg, wImg, hImg, strideImg, _colorBufferIllus);
		return IMGSYS_RET::ISR_LOCKFAIL;
	}

	// Validate status
	if(!HasImage())
	{
		ImgProcess::Clear_XRGB(pImg, wImg, hImg, strideImg, _colorBufferIllus);
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	// Clear background
	ImgProcess::Clear_XRGB(pImg, wImg, hImg, strideImg, _colorBufferIllus);

	// Get ROI region
	//Ticker ticker;
	//ticker.Start();
	bool bRS = false;
	IMGREGION rgROI = _rgROI.Get(bRS, 0);
	if(!bRS)
	{
		return IMGSYS_RET::ISR_FAIL;
	}
	//double tc = ticker.Tick();
	//Logger::Log0("BiSwap::Get ms: " + to_string(tc*1000));

	// Get image level
	const ImgLevel *pLevel = GetRenderLevelConst(rgROI._sizeTarget.x, rgROI._sizeTarget.y);
	if (nullptr == pLevel)
	{
		return IMGSYS_RET::ISR_NULLLVL;
	}

	// Render
	iret ret = pLevel->RenderIllustration(
		pImg, wImg, hImg, strideImg,
		rgROI._sizeTarget, rgROI._rcTarget,
		bBlocks, bClipRegion, modeIllus);

	return ret;
}

void ImgDisp::Test0()
{
	Logger::Log0("ImgDisp::Test0: Begin");
	Ticker ticker;

//#define TESTATOM
#ifdef TESTATOM
	atom8<int> ai0(0);
	ticker.Start();
	ai0.inc();
	ai0.dec();
	thread thTestAtom1(
		[&ai0](){
			for(int i = 0; i < 10000; ++i)
			{
				ai0.inc();
			}
		});
	thread thTestAtom2(
		[&ai0](){
			for(int i = 0; i < 10000; ++i)
			{
				ai0.dec();
			}
		});
	thTestAtom1.join();
	thTestAtom2.join();
	Logger::Log0("TestAtom8Int: " + to_string(ai0.get()) + "," + to_string(ticker.Cycle()));

	icrwb_lock lock0;
	int i0 = 0;
	thread thTestLockInt1(
		[&i0, &lock0](){
			for(int i = 0; i < 10000; ++i)
			{
				scope_guard scgLock;
				lock0.LockWriteGuard(scgLock);
				i0++;
			}
		});
	thread thTestLockInt2(
		[&i0, &lock0](){
			for(int i = 0; i < 10000; ++i)
			{
				scope_guard scgLock;
				lock0.LockWriteGuard(scgLock);
				i0--;
			}
		});
	thTestLockInt1.join();
	thTestLockInt2.join();
	Logger::Log0("TestLockInt: " + to_string(i0) + "," + to_string(ticker.Cycle()));

	atom<int> ai1(0);
	thread thTestAtomInt1(
		[&ai1](){
			for(int i = 0; i < 10000; ++i)
			{
				ai1.inc();
			}
		});
	thread thTestAtomInt2(
		[&ai1](){
			for(int i = 0; i < 10000; ++i)
			{
				ai1.dec();
			}
		});
	thTestAtomInt1.join();
	thTestAtomInt2.join();
	Logger::Log0("TestAtomInt: " + to_string(ai1.get()) + "," + to_string(ticker.Cycle()));

	atom<bool> ab0(false);
	ab0.flip();
	ab0.flip();
	thread thTestAtomBool1(
		[&ab0](){
			for(int i = 0; i < 10000; ++i)
			{
				ab0.flip();
			}
		});
	thread thTestAtomBool2(
		[&ab0](){
			for(int i = 0; i < 10000; ++i)
			{
				ab0.flip();
			}
		});
	thTestAtomBool1.join();
	thTestAtomBool2.join();
	Logger::Log0("TestAtomBool: " + to_string(ab0.get()) + "," + to_string(ticker.Cycle()));

	bool tb0(false);
	tb0 = !tb0;
	tb0 = !tb0;
	thread thTestPureBool1(
		[&tb0](){
			for(int i = 0; i < 10000; ++i)
			{
				tb0 = !tb0;
			}
		});
	thread thTestPureBool2(
		[&tb0](){
			for(int i = 0; i < 10000; ++i)
			{
				tb0 = !tb0;
			}
		});
	thTestPureBool1.join();
	thTestPureBool2.join();
	Logger::Log0("TestPureBool: " + to_string(tb0) + "," + to_string(ticker.Cycle()));

#endif

	//ImgBlock b;
	//b = ImgBlock();
	
	// Test pool
	//ThreadPoolStoppable *pool = new ThreadPoolStoppable();
	//*pool = std::move(_poolInitLoad);
	//_poolInitLoad.Clear();
	//pool.ThreadPoolBase::ClearPreAssign();
	//_poolInitLoad.SetSleepCycle(100);

	//_poolInitLoad = ThreadPoolStoppable();

	Logger::Log0("ImgDisp::Test0: End");
}

#pragma endregion ImgDisp

}

#undef _IMGDISP_SOURCE_FILE_IMGDISP_CPP
#define _IMGDISP_SOURCE_FILE_IMGDISPOBSOLETE_CPP

#include "pch.h"

//#include "ImgDisp.h"
//#include <ppl.h>


namespace ImgDisplay
{


#ifdef USE_IMGLEVEL_OBSOLETE

int ImgLevel::UpdateSampling(
	ImgLevel &lvlBase, const IRECT &rcBlkIdxBase, IRECT &rcBlkIdxUpdate,
	ms_t1 msTimeoutLock)
{
	Ticker ticker;
	ticker.Start();

	int retLock = -1;
	// ======>> LOCK READ OTHER <<=======
	IMGLEVEL_LOCKREADOTHERT_INTERNAL(lvlBase, msTimeoutLock, retLock);
	RETVAL_ON_NP(
		retLock,
		IMGSYS_RET::LOCKFAIL);
	// Validate status
	if(!lvlBase.IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	// ======>> LOCK READ <<=======
	IMGLEVEL_LOCKREADT_INTERNAL(msTimeoutLock, retLock);
	RETVAL_ON_NP(
		retLock,
		IMGSYS_RET::LOCKFAIL);
	// Validate status
	if(!IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	const Blocker &blockerBase = lvlBase._blocker;
	const Blocker &blockerCur = _blocker;

	// Get current level block index
	IRECT rcBlkIdxCur;
	RET_ON_NEG_AND(
		blockerBase.GetAlignedBlocks(blockerCur, rcBlkIdxBase, rcBlkIdxCur),
		Logger::Log0("ImgLevel::UpdateSampling: Fail to load level " + to_string(_level) +
			": fail to get down level block index range of level " + to_string(_level)););

	// UpdateSamplingInternal
	int ret = UpdateSamplingInternal(lvlBase, rcBlkIdxCur, msTimeoutLock);
	RET_ON_NEG_AND(
		ret,
		Logger::Log0("ImgLevel::UpdateSampling: Failed, ret = " + to_string(ret)););

	// Out update region
	rcBlkIdxUpdate = rcBlkIdxCur;

	Logger::Log0("ImgLevel::UpdateSampling: Level#" + to_string(_level) + " sampling updated" +
		"[" + to_string(ticker.Cycle()) + "]");

	return IMGSYS_RET::SUCCEED;
}

#endif

#ifdef USE_IMGDISP_OBSOLETE

int ImgDisp::InitLoadBlockRowTaskMerged(
	IRECT &rcBlkIdxLoad, bool *bInterrupt)
{
	const string logH = "ImgDisp::InitLoadBlockRowTask: ";
	
	Logger::Log0(logH, "====>  Begin  <====");

	// ======>> LOCK READ <<=======
	IMGDISP_LOCKREAD_INTERNAL;
	
	bool bRemain = false;
	// ScopeGuard for remaining InitLoad event
	scope_guard scgEventRemain(
		[&bRemain, &logH, this](){
			if(bRemain)
			{
				Logger::Log0(logH, "Event 'InitLoad' re triggered for remained region");
				_evtInitLoad.Signal();
			}}
	);

	// Extract region
	IRECT rcInitLoad;
	// ScopeGuard for InitLoad flag recover
	scope_guard scgRecoverFlag;
	RETVAL_ON_NEG_AND(
		ExtractInitLoadTaskRegionInternal(rcInitLoad, scgRecoverFlag, bRemain, __msTimeoutExtractInitLoadRegion),
		IMGSYS_RET::NOOPERATION,
		Logger::Log0(logH, "InitLoad region not found"););

	// ScopeGuard for remaining InitLoad
	scope_guard scgRemain(
		[&bRemain](){
			bRemain = true;
		});

	// InitLoadBlocksInternal
	int ret = InitLoadBlocksInternal(rcInitLoad, bInterrupt);

	// Disable ScopeGuard
	scgRecoverFlag.Disable();
	scgRemain.Disable();

	// Out rcBlkIdxLoad
	rcBlkIdxLoad = rcInitLoad;

	Logger::Log0(logH, "====>   Done  <====");

	return IMGSYS_RET::SUCCEED;
}

int ImgDisp::UpdateSamplingObsolete(
	const IRECT &rcBlkIdxUpdate, bool *bInterrupt)
{
	// ======>> LOCK READ <<=======
	IMGDISP_LOCKREAD_INTERNAL;

	// Validate status
	if(!IsBuilt())
	{
		return IMGSYS_RET::ISR_INVSTATUS;
	}

	// Base level info
	const bool bLSMChain = (IMGDISP_VSAMPLEMODE::LSM_CHAIN == _lvlsSample);
	ImgLevel *lvBase = &_level0;
	IRECT rcBlkIdxBase = rcBlkIdxUpdate;

	// Update sampling of upper levels
	for(int lv = 0; lv < _levels.size(); ++lv)
	{
		IRECT rcBlkIdxUpdate;
		int ret = _levels[lv].UpdateSampling(*lvBase, rcBlkIdxBase, rcBlkIdxUpdate);
		BREAK_ON_NEG_AND(
			ret,
			Logger::Log0("ImgDisp::UpdateSampling: Fail to update sampling of Level#" + to_string(lv + 1)););

		// Param pass
		if(bLSMChain)
		{
			rcBlkIdxBase = rcBlkIdxUpdate;
			lvBase = &(_levels[lv]);
		}

		// Check Interrupt Signal
		if(nullptr != bInterrupt && *bInterrupt)
		{
			return IMGSYS_RET::INTERRUPT;
		}
	}

	Logger::Log0("ImgDisp::UpdateSampling: Block Region " + rcBlkIdxUpdate.ToString() + " updated sample");
	_level0.SetUpdateFlag(rcBlkIdxUpdate, false);

	return IMGSYS_RET::SUCCEED;
}

#endif

}

#undef _IMGDISP_SOURCE_FILE_IMGDISPOBSOLETE_CPP
